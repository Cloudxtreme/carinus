act_comm.c:   if( IS_NPC( ch ) || !ch->pcdata )
act_comm.c:   drunk = ch->pcdata->condition[COND_DRUNK];
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:   if( channel == CHANNEL_YELL && xIS_SET( ch->in_room->room_flags, ROOM_NOYELL ) )
act_comm.c:      if( ch->master )
act_comm.c:         send_to_char( "I don't think so...\r\n", ch->master );
act_comm.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_SILENCE ) )
act_comm.c:   if( IS_SET( ch->deaf, channel ) && channel != CHANNEL_WARTALK && channel != CHANNEL_YELL )
act_comm.c:   REMOVE_BIT( ch->deaf, channel );
act_comm.c:   if( IS_IMMORTAL(ch) && xIS_SET( ch->act, PLR_WIZINVIS ) )
act_comm.c:            ch_printf( ch, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
act_comm.c:            ch_printf( ch, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
act_comm.c:            ch_printf( ch, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
act_comm.c:            ch_printf( ch, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
act_comm.c:            ch_printf( ch, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
act_comm.c:            ch_printf( ch, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
act_comm.c:         position = ch->position;
act_comm.c:         ch->position = POS_STANDING;
act_comm.c:         ch->position = position;
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:      snprintf( buf2, MAX_STRING_LENGTH, "%s: %s (%s)", IS_NPC( ch ) ? ch->short_descr : ch->name, argument, verb );
act_comm.c:      if( d->connected == CON_PLAYING && vch != ch && !IS_SET( och->deaf, channel ) )
act_comm.c:             ( !IS_NPC( och ) && !IS_SET( och->pcdata->flags, PCFLAG_RETIRED ) ) )
act_comm.c:               && !( och->pcdata->council && !str_cmp( och->pcdata->council->name, "Newbie Council" ) ) ) )
act_comm.c:         if( xIS_SET( vch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( vch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:            && ( vch->in_room->area != ch->in_room->area || xIS_SET( vch->in_room->room_flags, ROOM_NOYELL )
act_comm.c:            || ( ( xIS_SET( vch->in_room->room_flags, ROOM_HOUSE ) || xIS_SET( och->in_room->room_flags, ROOM_HOUSE ) )
act_comm.c:            if( vch->pcdata->clan != ch->pcdata->clan )
act_comm.c:            if( vch->pcdata->council != ch->pcdata->council )
act_comm.c:            if( vch->race != ch->race )
act_comm.c:         if( xIS_SET( ch->act, PLR_WIZINVIS ) && can_see( vch, ch ) && IS_IMMORTAL( vch ) )
act_comm.c:            snprintf( lbuf, MAX_INPUT_LENGTH + 4, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
act_comm.c:         position = vch->position;
act_comm.c:            vch->position = POS_STANDING;
act_comm.c:         if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:            int speakswell = UMIN( knows_language( vch, ch->speaking, ch ),
act_comm.c:                                   knows_language( ch, ch->speaking, vch ) );
act_comm.c:         if( !knows_language( vch, ch->speaking, ch ) && ( !IS_NPC( ch ) || ch->speaking != 0 ) )
act_comm.c:            sbuf = scramble( argument, ch->speaking );
act_comm.c:         if( !IS_NPC( ch ) && ch->pcdata->nuisance
act_comm.c:             && ch->pcdata->nuisance->flags > 7
act_comm.c:             && ( number_percent(  ) < ( ( ch->pcdata->nuisance->flags - 7 ) * 10 * ch->pcdata->nuisance->power ) ) )
act_comm.c:         if( !IS_NPC( vch ) && vch->pcdata->nuisance &&
act_comm.c:             vch->pcdata->nuisance->flags > 7
act_comm.c:             && ( number_percent(  ) < ( ( vch->pcdata->nuisance->flags - 7 ) * 10 * vch->pcdata->nuisance->power ) ) )
act_comm.c:         vch->position = position;
act_comm.c:      if( d->connected == CON_PLAYING && !IS_SET( och->deaf, channel ) && get_trust( vch ) >= level )
act_comm.c:   if( IS_NPC( ch ) || !ch->pcdata->clan
act_comm.c:       || ch->pcdata->clan->clan_type == CLAN_ORDER || ch->pcdata->clan->clan_type == CLAN_GUILD )
act_comm.c:            && !( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, "Newbie Council" ) ) ) )
act_comm.c:   if( IS_NPC( ch ) || !ch->pcdata->clan || ch->pcdata->clan->clan_type != CLAN_ORDER )
act_comm.c:   if( IS_NPC( ch ) || !ch->pcdata->council )
act_comm.c:   if( IS_NPC( ch ) || !ch->pcdata->clan || ch->pcdata->clan->clan_type != CLAN_GUILD )
act_comm.c:   if( !IS_IMMORTAL( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_RETIRED ) )
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:         ch_printf( victim, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see( victim, ch ) ? "Someone" : ch->name );
act_comm.c:   actflags = ch->act;
act_comm.c:      xREMOVE_BIT( ch->act, ACT_SECRETIVE );
act_comm.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
act_comm.c:            ch_printf( vch, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see(vch, ch) ? "Someone" : ch->name );
act_comm.c:      if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:         int speakswell = UMIN( knows_language( vch, ch->speaking, ch ), knows_language( ch, ch->speaking, vch ) );
act_comm.c:      if( !knows_language( vch, ch->speaking, ch ) && ( !IS_NPC( ch ) || ch->speaking != 0 ) )
act_comm.c:         sbuf = scramble( argument, ch->speaking );
act_comm.c:   ch->act = actflags;
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:      snprintf( buf, MAX_STRING_LENGTH, "%s: %s", IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:   actflags = ch->act;
act_comm.c:      xREMOVE_BIT( ch->act, ACT_SECRETIVE );
act_comm.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
act_comm.c:            ch_printf( vch, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see( vch, ch ) ? "Someone" : ch->name );
act_comm.c:      if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:         int speakswell = UMIN( knows_language( vch, ch->speaking, ch ),
act_comm.c:                                knows_language( ch, ch->speaking, vch ) );
act_comm.c:      if( !knows_language( vch, ch->speaking, ch ) && ( !IS_NPC( ch ) || ch->speaking != 0 ) )
act_comm.c:         sbuf = scramble( argument, ch->speaking );
act_comm.c:   ch->act = actflags;
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:      snprintf( buf, MAX_STRING_LENGTH, "%s: %s", IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:   REMOVE_BIT( ch->deaf, CHANNEL_WHISPER );
act_comm.c:         ch_printf( victim, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see( victim, ch ) ? "Someone" : ch->name );
act_comm.c:   if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:      int speakswell = UMIN( knows_language( victim, ch->speaking, ch ),
act_comm.c:                             knows_language( ch, ch->speaking, victim ) );
act_comm.c:   if( !knows_language( vch, ch->speaking, ch ) && ( !IS_NPC( ch ) || ch->speaking != 0 ) )
act_comm.c:   if( !xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) && !IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:                IS_NPC( ch ) ? ch->short_descr : ch->name, argument, IS_NPC( victim ) ? victim->short_descr : victim->name );
act_comm.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOBECKON ) )
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:   if( !IS_NPC( ch ) && ( xIS_SET( ch->act, PLR_SILENCE ) || xIS_SET( ch->act, PLR_NO_TELL ) ) )
act_comm.c:       || ( IS_NPC( victim ) && victim->in_room != ch->in_room )
act_comm.c:         ch_printf( victim, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see( victim, ch ) ? "Someone" : ch->name );
act_comm.c:   ch->retell = victim;
act_comm.c:   REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
act_comm.c:       isalpha( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) )
act_comm.c:      snprintf( buf, MAX_INPUT_LENGTH, "%s told you '%s'\r\n", capitalize( IS_NPC( ch ) ? ch->short_descr : ch->name ), argument );
act_comm.c:      victim->pcdata->lt_index = tolower( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) - 'a';
act_comm.c:   if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:      int speakswell = UMIN( knows_language( victim, ch->speaking, ch ),
act_comm.c:                             knows_language( ch, ch->speaking, victim ) );
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:                IS_NPC( ch ) ? ch->short_descr : ch->name, argument, IS_NPC( victim ) ? victim->short_descr : victim->name );
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_SILENCE ) )
act_comm.c:   if( ( victim = ch->reply ) == NULL )
act_comm.c:         ch_printf( victim, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see( victim, ch ) ? "Someone" : ch->name );
act_comm.c:   REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
act_comm.c:   if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:      int speakswell = UMIN( knows_language( victim, ch->speaking, ch ),
act_comm.c:                             knows_language( ch, ch->speaking, victim ) );
act_comm.c:   if( knows_language( victim, ch->speaking, ch ) || ( IS_NPC( ch ) && !ch->speaking ) )
act_comm.c:      act( AT_TELL, "$n tells you '$t'", ch, scramble( argument, ch->speaking ), victim, TO_VICT );
act_comm.c:   ch->retell = victim;
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:                IS_NPC( ch ) ? ch->short_descr : ch->name, argument, IS_NPC( victim ) ? victim->short_descr : victim->name );
act_comm.c:       isalpha( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) )
act_comm.c:      snprintf( buf, MAX_STRING_LENGTH, "%s told you '%s'\r\n", capitalize( IS_NPC( ch ) ? ch->short_descr : ch->name ),
act_comm.c:      victim->pcdata->lt_index = tolower( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) - 'a';
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:   if( !IS_NPC( ch ) && ( xIS_SET( ch->act, PLR_SILENCE ) || xIS_SET( ch->act, PLR_NO_TELL ) ) )
act_comm.c:   victim = ch->retell;
act_comm.c:         ch_printf( victim, "You attempy to ignore %s, but are unable to do so.\r\n", !can_see( victim, ch ) ? "Someone" : ch->name );
act_comm.c:       isalpha( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) )
act_comm.c:      snprintf( buf, MAX_INPUT_LENGTH, "%s told you '%s'\r\n", capitalize( IS_NPC( ch ) ? ch->short_descr : ch->name ),
act_comm.c:      victim->pcdata->lt_index = tolower( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) - 'a';
act_comm.c:   REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
act_comm.c:   if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:      int speakswell = UMIN( knows_language( victim, ch->speaking, ch ),
act_comm.c:                             knows_language( ch, ch->speaking, victim ) );
act_comm.c:   if( knows_language( victim, ch->speaking, ch ) || ( IS_NPC( ch ) && !ch->speaking ) )
act_comm.c:      act( AT_TELL, "$n tells you '$t'", ch, scramble( argument, ch->speaking ), victim, TO_VICT );
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:                IS_NPC( ch ) ? ch->short_descr : ch->name, argument, IS_NPC( victim ) ? victim->short_descr : victim->name );
act_comm.c:   if( IS_NPC( ch ) || !IS_IMMORTAL( ch ) || !ch->pcdata->tell_history )
act_comm.c:      tindex = ch->pcdata->lt_index;
act_comm.c:   if( ch->pcdata->tell_history[tindex] )
act_comm.c:      send_to_char( ch->pcdata->tell_history[tindex], ch );
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_NO_EMOTE ) )
act_comm.c:   actflags = ch->act;
act_comm.c:      xREMOVE_BIT( ch->act, ACT_SECRETIVE );
act_comm.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
act_comm.c:            ch_printf( vch, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see( vch, ch ) ? "Someone" : ch->name );
act_comm.c:      if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:         int speakswell = UMIN( knows_language( vch, ch->speaking, ch ),
act_comm.c:                                knows_language( ch, ch->speaking, vch ) );
act_comm.c:      if( !knows_language( vch, ch->speaking, ch ) && ( !IS_NPC( ch ) && ch->speaking != 0 ) )
act_comm.c:         sbuf = scramble( buf, ch->speaking );
act_comm.c:   ch->act = actflags;
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:      snprintf( buf, MAX_STRING_LENGTH, "%s %s (emote)", IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
act_comm.c:   if( get_trust( ch ) >= LEVEL_ASCENDANT || is_name( "bug", ch->pcdata->bestowments ) )
act_comm.c:   if( ch->position == POS_FIGHTING
act_comm.c:       || ch->position == POS_EVASIVE
act_comm.c:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
act_comm.c:   if( ch->position < POS_STUNNED )
act_comm.c:   if( !IS_IMMORTAL( ch ) && xIS_SET( ch->in_room->room_flags, ROOM_NOQUIT ) )
act_comm.c:   if( IS_PKILL( ch ) && ch->wimpy > ( int )ch->max_hit / 2.25 )
act_comm.c:   if( ch->position == POS_MOUNTED )
act_comm.c:   snprintf( log_buf, MAX_STRING_LENGTH, "%s has quit (Room %d).", ch->name, ( ch->in_room ? ch->in_room->vnum : -1 ) );
act_comm.c:   if( ch->level >= LEVEL_HERO && !ch->pcdata->pet ) /* Pet crash fix */
act_comm.c:      xREMOVE_BIT( ch->act, PLR_BOUGHT_PET );
act_comm.c:   if( sysdata.save_pets && ch->pcdata->pet )
act_comm.c:      act( AT_BYE, "$N follows $S master into the Void.", ch, NULL, ch->pcdata->pet, TO_ROOM );
act_comm.c:      extract_char( ch->pcdata->pet, TRUE );
act_comm.c:   if( ch->pcdata->clan )
act_comm.c:      save_clan( ch->pcdata->clan );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      xSET_BIT( ch->act, PLR_RIP );
act_comm.c:      xSET_BIT( ch->act, PLR_ANSI );
act_comm.c:      xREMOVE_BIT( ch->act, PLR_RIP );
act_comm.c:      xSET_BIT( ch->act, PLR_ANSI );
act_comm.c:      xREMOVE_BIT( ch->act, PLR_ANSI );
act_comm.c:   if( ch->level < 2 )
act_comm.c:   if( !ch->pcdata->council )
act_comm.c:   if( str_cmp( ch->pcdata->council->name, "Newbie Council" ) )
act_comm.c:      for( gch = first_char; gch; gch = gch->next )
act_comm.c:         if( gch->master == ch && gch != ch )
act_comm.c:   ch_printf( victim, "%s beckons to you...\r\n", ch->name );
act_comm.c:   if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master )
act_comm.c:      act( AT_PLAIN, "But you'd rather follow $N!", ch, NULL, ch->master, TO_CHAR );
act_comm.c:      if( !ch->master )
act_comm.c:   if( ( ch->level - victim->level < -10 || ch->level - victim->level > 10 )
act_comm.c:       && !IS_HERO( ch ) && !( ch->level < 15 && !IS_NPC( victim )
act_comm.c:   if( ch->master )
act_comm.c:   if( ch->master )
act_comm.c:   ch->master = master;
act_comm.c:   ch->leader = NULL;
act_comm.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_PET ) && !IS_NPC( master ) )
act_comm.c:   if( !ch->master )
act_comm.c:   if( IS_NPC( ch ) && !IS_NPC( ch->master ) && ch->master->pcdata->pet == ch )
act_comm.c:      ch->master->pcdata->pet = NULL;
act_comm.c:      xREMOVE_BIT( ch->affected_by, AFF_CHARM );
act_comm.c:      if( !IS_NPC( ch->master ) )
act_comm.c:         ch->master->pcdata->charmies--;
act_comm.c:   if( can_see( ch->master, ch ) )
act_comm.c:      if( !( !IS_NPC( ch->master ) && IS_IMMORTAL( ch ) && !IS_IMMORTAL( ch->master ) ) )
act_comm.c:         act( AT_ACTION, "$n stops following you.", ch, NULL, ch->master, TO_VICT );
act_comm.c:   act( AT_ACTION, "You stop following $N.", ch, NULL, ch->master, TO_CHAR );
act_comm.c:   ch->master = NULL;
act_comm.c:   ch->leader = NULL;
act_comm.c:   if( ch->master )
act_comm.c:   ch->leader = NULL;
act_comm.c:   for( fch = first_char; fch; fch = fch->next )
act_comm.c:      if( fch->master == ch )
act_comm.c:      if( fch->leader == ch )
act_comm.c:         fch->leader = fch;
act_comm.c:   for( och = ch->in_room->first_person; och; och = och_next )
act_comm.c:      och_next = och->next_in_room;
act_comm.c:      if( IS_AFFECTED( och, AFF_CHARM ) && och->master == ch && ( fAll || och == victim ) && !IS_IMMORTAL( och ) )
act_comm.c:      snprintf( log_buf, MAX_STRING_LENGTH, "%s: order %s.", ch->name, argbuf );
act_comm.c:      log_string_plus( log_buf, LOG_NORMAL, ch->level );
act_comm.c:      leader = ch->leader ? ch->leader : ch;
act_comm.c:                 PERS( leader, ch ), ch->level < LEVEL_AVATAR ? " [to lvl]" : "" );
act_comm.c:      for( gch = first_char; gch; gch = gch->next )
act_comm.c:                          gch->level,
act_comm.c:                          IS_NPC( gch ) ? "Mob" : class_table[gch->Class]->who_name,
act_comm.c:            else if( gch->alignment > 750 )
act_comm.c:            else if( gch->alignment > 350 )
act_comm.c:            else if( gch->alignment > 150 )
act_comm.c:            else if( gch->alignment > -150 )
act_comm.c:            else if( gch->alignment > -350 )
act_comm.c:            else if( gch->alignment > -750 )
act_comm.c:            ch_printf( ch, "%-2d %2.2s %3.3s", gch->level, buf, IS_NPC( gch ) ? "Mob" : class_table[gch->Class]->who_name );
act_comm.c:            if( gch->hit < gch->max_hit / 4 )
act_comm.c:            else if( gch->hit < gch->max_hit / 2.5 )
act_comm.c:            ch_printf( ch, "%5d", gch->hit );
act_comm.c:            ch_printf( ch, "/%-5d ", gch->max_hit );
act_comm.c:            if( gch->Class != CLASS_WARRIOR )
act_comm.c:                          IS_VAMPIRE( gch ) ? gch->pcdata->condition[COND_BLOODTHIRST] : gch->mana,
act_comm.c:                          IS_VAMPIRE( gch ) ? 10 + gch->level : gch->max_mana );
act_comm.c:            if( gch->mental_state < -25 || gch->mental_state > 25 )
act_comm.c:                       gch->mental_state > 75 ? "+++" :
act_comm.c:                       gch->mental_state > 50 ? "=++" :
act_comm.c:                       gch->mental_state > 25 ? "==+" :
act_comm.c:                       gch->mental_state > -25 ? "===" :
act_comm.c:                       gch->mental_state > -50 ? "-==" : gch->mental_state > -75 ? "--=" : "---" );
act_comm.c:            ch_printf( ch, "%5d ", gch->move );
act_comm.c:                       gch->race == 0 ? "human" :
act_comm.c:                       gch->race == 1 ? "elf" :
act_comm.c:                       gch->race == 2 ? "dwarf" :
act_comm.c:                       gch->race == 3 ? "hlflng" :
act_comm.c:                       gch->race == 4 ? "pixie" :
act_comm.c:                       gch->race == 6 ? "h-ogre" :
act_comm.c:                       gch->race == 7 ? "h-orc" :
act_comm.c:                       gch->race == 8 ? "h-trol" :
act_comm.c:                       gch->race == 9 ? "h-elf" :
act_comm.c:                       gch->race == 10 ? "gith" :
act_comm.c:                       gch->race == 11 ? "drow" :
act_comm.c:                       gch->race == 12 ? "seaelf" : gch->race == 13 ? "lizard" : gch->race == 14 ? "gnome" : "" );
act_comm.c:            if( gch->level < LEVEL_AVATAR )
act_comm.c:               ch_printf( ch, "%8d ", exp_level( gch, gch->level + 1 ) - gch->exp );
act_comm.c:      if( ch->leader || ch->master )
act_comm.c:      for( gch = first_char; gch; gch = gch->next )
act_comm.c:            gch->leader = NULL;
act_comm.c:            gch->master = NULL;
act_comm.c:      for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
act_comm.c:             && rch->master == ch
act_comm.c:             && !ch->master
act_comm.c:             && !ch->leader
act_comm.c:             && ( ( abs( ch->level - rch->level ) < 9 && IS_PKILL( ch ) == IS_PKILL( rch ) ) || IS_IMMORTAL( ch ) ) )
act_comm.c:            rch->leader = ch;
act_comm.c:   if( ch->master || ( ch->leader && ch->leader != ch ) )
act_comm.c:   if( ( ch->level - victim->level < -8 || ch->level - victim->level > 8 || ( IS_PKILL( ch ) != IS_PKILL( victim ) ) ) && !IS_IMMORTAL( ch ) )
act_comm.c:   if( ch->gold < amount )
act_comm.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
act_comm.c:   if( xIS_SET( ch->act, PLR_AUTOGOLD ) && members < 2 )
act_comm.c:   ch->gold -= amount;
act_comm.c:   ch->gold += share + extra;
act_comm.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
act_comm.c:         gch->gold += share;
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->act, PLR_NO_TELL ) )
act_comm.c:   for( gch = first_char; gch; gch = gch->next )
act_comm.c:         if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:            int speakswell = UMIN( knows_language( gch, ch->speaking, ch ),
act_comm.c:                                   knows_language( ch, ch->speaking, gch ) );
act_comm.c:               ch_printf( gch, "%s tells the group '%s'\r\n", ch->name,
act_comm.c:               ch_printf( gch, "%s tells the group '%s'\r\n", ch->name, argument );
act_comm.c:            ch_printf( gch, "%s tells the group '%s'\r\n", ch->name, argument );
act_comm.c:         if( knows_language( gch, ch->speaking, gch ) || ( IS_NPC( ch ) && !ch->speaking ) )
act_comm.c:            ch_printf( gch, "%s tells the group '%s'\r\n", ch->name, argument );
act_comm.c:            ch_printf( gch, "%s tells the group '%s'\r\n", ch->name, scramble( argument, ch->speaking ) );
act_comm.c:   if( ach->leader )
act_comm.c:      ach = ach->leader;
act_comm.c:   if( bch->leader )
act_comm.c:      bch = bch->leader;
act_comm.c:   if( IS_NPC( ch ) && !ch->speaks )   /* No langs = knows all for npcs */
act_comm.c:   if( IS_NPC( ch ) && IS_SET( ch->speaks, ( language & ~LANG_CLAN ) ) )
act_comm.c:      if( ch->pcdata->clan == cch->pcdata->clan && ch->pcdata->clan != NULL )
act_comm.c:      if( IS_SET( race_table[ch->race]->language, language ) )
act_comm.c:         if( IS_SET( language, lang_array[lang] ) && IS_SET( ch->speaks, lang_array[lang] ) )
act_comm.c:               return ch->pcdata->learned[sn];
act_comm.c:   if( race_table[ch->race]->language & language )
act_comm.c:   if( ch->speaks & language )
act_comm.c:            if( ch->pcdata->learned[sn] >= 99 )
act_comm.c:      ch->speaking = ~LANG_CLAN;
act_comm.c:            if( lang_array[langs] == LANG_CLAN && ( IS_NPC( ch ) || !ch->pcdata->clan ) )
act_comm.c:            ch->speaking = lang_array[langs];
act_comm.c:      if( race_table[ch->race]->language & lang_array[lang] ||
act_comm.c:          lang_array[lang] == LANG_COMMON || ch->pcdata->learned[sn] >= 99 )
act_comm.c:      for( sch = ch->in_room->first_person; sch; sch = sch->next_in_room )
act_comm.c:         if( IS_NPC( sch ) && xIS_SET( sch->act, ACT_SCHOLAR )
act_comm.c:             && knows_language( sch, ch->speaking, ch )
act_comm.c:             && ( !sch->speaking || knows_language( ch, sch->speaking, sch ) ) )
act_comm.c:      if( countlangs( ch->speaks ) >= ( ch->level / 10 ) && ch->pcdata->learned[sn] <= 0 )
act_comm.c:      if( ch->practice < prac )
act_comm.c:      ch->practice -= prac;
act_comm.c:      ch->pcdata->learned[sn] += prct;
act_comm.c:      ch->pcdata->learned[sn] = UMIN( ch->pcdata->learned[sn], 99 );
act_comm.c:      SET_BIT( ch->speaks, lang_array[lang] );
act_comm.c:      if( ch->pcdata->learned[sn] == prct )
act_comm.c:      else if( ch->pcdata->learned[sn] < 60 )
act_comm.c:      else if( ch->pcdata->learned[sn] < 60 + prct )
act_comm.c:      else if( ch->pcdata->learned[sn] < 99 )
act_comm.c:         if( ch->speaking & lang_array[lang] || ( IS_NPC( ch ) && !ch->speaking ) )
act_info.c:   struct WeatherCell *cell = getWeatherCell( ch->in_room->area );
act_info.c:   if( ( IS_AFFECTED( ch, AFF_DETECT_EVIL ) || ch->Class == CLASS_PALADIN ) && IS_OBJ_STAT( obj, ITEM_EVIL ) )
act_info.c:   if( ch->Class == CLASS_PALADIN
act_info.c:   if( ch->Class == CLASS_PALADIN
act_info.c:   if( ch->Class == CLASS_PALADIN
act_info.c:   if( ch->Class == CLASS_PALADIN
act_info.c:   if( ch->Class == CLASS_PALADIN
act_info.c:   if( ch->Class == CLASS_PALADIN
act_info.c:   if( ( IS_AFFECTED( ch, AFF_DETECT_MAGIC ) || xIS_SET( ch->act, PLR_HOLYLIGHT ) ) && IS_OBJ_STAT( obj, ITEM_MAGIC ) )
act_info.c:   if( ( IS_AFFECTED( ch, AFF_DETECTTRAPS ) || xIS_SET( ch->act, PLR_HOLYLIGHT ) ) && is_trapped( obj ) )
act_info.c:      if( glowsee && ( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_HOLYLIGHT ) ) )
act_info.c:      if( glowsee && ( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_HOLYLIGHT ) ) )
act_info.c:   if( !ch->desc )
act_info.c:         if( IS_NPC( ch ) || xIS_SET( ch->act, PLR_COMBINE ) )
act_info.c:   ms = ( ch->mental_state ? ch->mental_state : 1 )
act_info.c:      * ( IS_NPC( ch ) ? 1 : ( ch->pcdata->condition[COND_DRUNK] ? ( ch->pcdata->condition[COND_DRUNK] / 12 ) : 1 ) );
act_info.c:         if( IS_NPC( ch ) || xIS_SET( ch->act, PLR_COMBINE ) )
act_info.c:         if( IS_NPC( ch ) || xIS_SET( ch->act, PLR_COMBINE ) )
act_info.c:/*	if ( IS_NPC(ch) || xIS_SET(ch->act, PLR_COMBINE) ) */
act_info.c:      if( IS_NPC( ch ) || xIS_SET( ch->act, PLR_COMBINE ) )
act_info.c:   if( IS_EVIL( victim ) && ( IS_AFFECTED( ch, AFF_DETECT_EVIL ) || ch->Class == CLASS_PALADIN ) )
act_info.c:   if( IS_NEUTRAL( victim ) && ch->Class == CLASS_PALADIN )
act_info.c:   if( IS_GOOD( victim ) && ch->Class == CLASS_PALADIN )
act_info.c:   if( IS_NPC( victim ) && ch->mount && ch->mount == victim && ch->in_room == ch->mount->in_room )
act_info.c:            if( !IS_NPC( victim ) && !xIS_SET( ch->act, PLR_BRIEF ) )
act_info.c:   if( !IS_NPC( victim ) && !xIS_SET( ch->act, PLR_BRIEF ) )
act_info.c:   if( can_see( victim, ch ) && !IS_NPC( ch ) && !xIS_SET( ch->act, PLR_WIZINVIS ) )
act_info.c:   else if( ch->pcdata->learned[gsn_peek] > 0 )
act_info.c:   for( rch = list; rch; rch = rch->next_in_room )
act_info.c:      else if( room_is_dark( ch->in_room ) && IS_AFFECTED( ch, AFF_INFRARED ) && !( !IS_NPC( rch ) && IS_IMMORTAL( rch ) ) )
act_info.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
act_info.c:   for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c:                    ch->in_room->name,
act_info.c:   if( IS_IMMORTAL( ch ) && xIS_SET( ch->act, PLR_ROOMVNUM ) )
act_info.c:      ch_printf_color( ch, "&w-<---- &YVnum: %6d &w----------------------------->-        ", ch->in_room->vnum );
act_info.c:   if( !xIS_SET( ch->act, PLR_BRIEF ) )
act_info.c:      if( ch->in_room->description && ch->in_room->description[0] != '\0' )
act_info.c:         mudstrlcat( rdesc, ch->in_room->description, MAX_STRING_LENGTH );
act_info.c:   if( !ch->desc )
act_info.c:   if( ch->position < POS_SLEEPING )
act_info.c:   if( ch->position == POS_SLEEPING )
act_info.c:       && !xIS_SET( ch->act, PLR_HOLYLIGHT ) && !IS_AFFECTED( ch, AFF_TRUESIGHT ) && room_is_dark( ch->in_room ) )
act_info.c:         show_char_to_char( ch->in_room->first_person, ch );
act_info.c:      if( xIS_SET( ch->act, PLR_COMPASS ) )
act_info.c:         send_to_char( ch->in_room->name, ch );
act_info.c:      if( arg1[0] == '\0' || ( !IS_NPC( ch ) && !xIS_SET( ch->act, PLR_BRIEF ) ) )
act_info.c:         if( xIS_SET( ch->act, PLR_AUTOMAP ) )
act_info.c:      if( !IS_NPC( ch ) && ( xIS_SET( ch->act, PLR_AUTOEXIT ) && !xIS_SET( ch->act, PLR_AUTOMAP ) ) )
act_info.c:      show_list_to_char( ch->in_room->first_content, ch, FALSE, FALSE );
act_info.c:      show_char_to_char( ch->in_room->first_person, ch );
act_info.c:      if( !IS_OUTSIDE( ch ) || NO_WEATHER_SECT( ch->in_room->sector_type ) )
act_info.c:      if( !CAN_WEAR( obj, ITEM_TAKE ) && ch->level < sysdata.level_getobjnotake )
act_info.c:      if( ch->carry_weight + obj->weight > can_carry_w( ch ) )
act_info.c:            for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c:                  original = ch->in_room;
act_info.c:   if( ( pdesc = get_extra_descr( arg1, ch->in_room->first_extradesc ) ) != NULL )
act_info.c:               || ch->Class == CLASS_THIEF || IS_SET( pexit->exit_info, EX_xLOOK ) || get_trust( ch ) >= LEVEL_IMMORTAL ) )
act_info.c:                  if( ch->Class == CLASS_THIEF )
act_info.c:         original = ch->in_room;
act_info.c:   for( cnt = 0, obj = ch->last_carrying; obj; obj = obj->prev_content )
act_info.c:   for( obj = ch->in_room->last_content; obj; obj = obj->prev_content )
act_info.c:   if( !ch->desc )
act_info.c:   if( ch->position < POS_SLEEPING )
act_info.c:   if( ch->position == POS_SLEEPING )
act_info.c:      if( xIS_SET( ch->act, PLR_BRIEF ) )
act_info.c:      xSET_BIT( ch->act, PLR_BRIEF );
act_info.c:         xREMOVE_BIT( ch->act, PLR_BRIEF );
act_info.c:       && !xIS_SET( ch->act, PLR_HOLYLIGHT )
act_info.c:       && !IS_AFFECTED( ch, AFF_TRUESIGHT ) && !IS_AFFECTED( ch, AFF_INFRARED ) && room_is_dark( ch->in_room ) )
act_info.c:   for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c:      SET_BIT( ch->pcdata->flags, PCFLAG_HELPSTART );
act_info.c:   if( !ch->desc )
act_info.c:   switch ( ch->substate )
act_info.c:         if( ( pHelp = ( HELP_DATA * ) ch->dest_buf ) == NULL )
act_info.c:            bug( "%s", "hedit: sub_help_edit: NULL ch->dest_buf" );
act_info.c:   ch->substate = SUB_HELP_EDIT;
act_info.c:   ch->dest_buf = pHelp;
act_info.c:      if( !wch->leader || wch->leader == wch || !wch->leader->desc ||
act_info.c:          IS_NPC( wch->leader ) || IS_IMMORTAL( wch ) || IS_IMMORTAL( wch->leader ) )
act_info.c:         if( wch->leader && wch->leader != wch && wch->leader->desc &&
act_info.c:             !IS_NPC( wch->leader ) && !IS_IMMORTAL( wch ) &&
act_info.c:             !IS_IMMORTAL( wch->leader ) && ( whogr_t = find_whogr( wch->leader->desc, first_whogr ) ) )
act_info.c:      if( wch->level < iLevelLower || wch->level > iLevelUpper || ( fPkill && !CAN_PKILL( wch ) ) || ( fImmortalOnly && wch->level < LEVEL_IMMORTAL ) || ( fClassRestrict && !rgfClass[wch->Class] ) || ( fRaceRestrict && !rgfRace[wch->race] ) || ( fClanMatch && ( pClan != wch->pcdata->clan ) )  /* SB */
act_info.c:          || ( fCouncilMatch && ( pCouncil != wch->pcdata->council ) )  /* SB */
act_info.c:          || ( fDeityMatch && ( pDeity != wch->pcdata->deity ) ) )
act_info.c:      if( fLeader && !( wch->pcdata->council &&
act_info.c:                        ( ( wch->pcdata->council->head2 &&
act_info.c:                            !str_cmp( wch->pcdata->council->head2, wch->name ) ) ||
act_info.c:                          ( wch->pcdata->council->head &&
act_info.c:                            !str_cmp( wch->pcdata->council->head, wch->name ) ) ) ) &&
act_info.c:          !( wch->pcdata->clan && ( ( wch->pcdata->clan->deity &&
act_info.c:                                      !str_cmp( wch->pcdata->clan->deity, wch->name ) )
act_info.c:                                    || ( wch->pcdata->clan->leader
act_info.c:                                         && !str_cmp( wch->pcdata->clan->leader, wch->name ) )
act_info.c:                                    || ( wch->pcdata->clan->number1
act_info.c:                                         && !str_cmp( wch->pcdata->clan->number1, wch->name ) )
act_info.c:                                    || ( wch->pcdata->clan->number2
act_info.c:                                         && !str_cmp( wch->pcdata->clan->number2, wch->name ) ) ) ) )
act_info.c:      if( fGroup && !wch->leader && !IS_SET( wch->pcdata->flags, PCFLAG_GROUPWHO ) && ( !whogr_p || !whogr_p->indent ) )
act_info.c:      if( fShowHomepage && wch->pcdata->homepage && wch->pcdata->homepage[0] != '\0' )
act_info.c:         snprintf( char_name, MAX_INPUT_LENGTH, "<A HREF=\"%s\">%s</A>", show_tilde( wch->pcdata->homepage ), wch->name );
act_info.c:         mudstrlcpy( char_name, wch->name, MAX_INPUT_LENGTH );
act_info.c:      snprintf( class_text, MAX_INPUT_LENGTH, "%s%2d %s", NOT_AUTHED( wch ) ? "N" : " ", wch->level,
act_info.c:                class_table[wch->Class]->who_name );
act_info.c:      switch ( wch->level )
act_info.c:      if( !str_cmp( wch->name, sysdata.guild_overseer ) )
act_info.c:      else if( !str_cmp( wch->name, sysdata.guild_advisor ) )
act_info.c:      else if( wch->pcdata->clan
act_info.c:               && !str_cmp( wch->name, wch->pcdata->clan->leader ) && wch->pcdata->clan->leadrank[0] != '\0' )
act_info.c:         Class = wch->pcdata->clan->leadrank;
act_info.c:      else if( wch->pcdata->clan
act_info.c:               && !str_cmp( wch->name, wch->pcdata->clan->number1 ) && wch->pcdata->clan->onerank[0] != '\0' )
act_info.c:         Class = wch->pcdata->clan->onerank;
act_info.c:      else if( wch->pcdata->clan
act_info.c:               && !str_cmp( wch->name, wch->pcdata->clan->number2 ) && wch->pcdata->clan->tworank[0] != '\0' )
act_info.c:         Class = wch->pcdata->clan->tworank;
act_info.c:      else if( wch->pcdata->rank && wch->pcdata->rank[0] != '\0' )
act_info.c:         Class = wch->pcdata->rank;
act_info.c:      if( wch->pcdata->clan )
act_info.c:         CLAN_DATA *pclan = wch->pcdata->clan;
act_info.c:            if( !str_cmp( wch->name, pclan->deity ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->leader ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->number1 ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->number2 ) )
act_info.c:            if( !str_cmp( wch->name, pclan->leader ) )
act_info.c:            if( !str_cmp( wch->name, pclan->number1 ) )
act_info.c:            if( !str_cmp( wch->name, pclan->number2 ) )
act_info.c:            if( !str_cmp( wch->name, pclan->deity ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->leader ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->number1 ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->number2 ) )
act_info.c:      if( wch->pcdata->council )
act_info.c:         if( wch->pcdata->council->head2 == NULL )
act_info.c:            if( !str_cmp( wch->name, wch->pcdata->council->head ) )
act_info.c:            if( !str_cmp( wch->name, wch->pcdata->council->head ) || !str_cmp( wch->name, wch->pcdata->council->head2 ) )
act_info.c:         mudstrlcat( council_name, wch->pcdata->council_name, MAX_INPUT_LENGTH );
act_info.c:      if( xIS_SET( wch->act, PLR_WIZINVIS ) )
act_info.c:         snprintf( invis_str, MAX_INPUT_LENGTH, "(%d) ", wch->pcdata->wizinvis );
act_info.c:                wch->pcdata->customclass,
act_info.c:                ( wch->desc && wch->desc->connected ) ? "[WRITING] " : "",
act_info.c:                xIS_SET( wch->act, PLR_AFK ) ? "[AFK] " : "",
act_info.c:                xIS_SET( wch->act, PLR_ATTACKER ) ? "(ATTACKER) " : "",
act_info.c:                xIS_SET( wch->act, PLR_KILLER ) ? "(KILLER) " : "",
act_info.c:                xIS_SET( wch->act, PLR_THIEF ) ? "(THIEF) " : "",
act_info.c:                char_name, wch->pcdata->title, extra_title, clan_name, council_name );
act_info.c:      if( wch->level > LEVEL_AVATAR && IS_IMMORTAL( wch ) )
act_info.c:         if( wch->leader || ( whogr_p && whogr_p->indent ) )
act_info.c:      for( obj2 = ch->first_carrying; obj2; obj2 = obj2->next_content )
act_info.c:      pager_printf( ch, "\r\nPlayers near you in %s:\r\n", ch->in_room->area->name );
act_info.c:             && ( ( victim->in_room->area == ch->in_room->area )
act_info.c:             && ( victim->in_room == ch->in_room
act_info.c:                  || ( !IS_SET( ch->in_room->area->flags, AFLAG_NOWHERE )
act_info.c:             && victim->in_room->area == ch->in_room->area
act_info.c:   diff = victim->level - ch->level;
act_info.c:   diff = ( int )( victim->max_hit - ch->max_hit ) / 6;
act_info.c:   for( mob = ch->in_room->first_person; mob; mob = mob->next_in_room )
act_info.c:   if( argument[0] == '\0' && ch->level > LEVEL_AVATAR)   
act_info.c:             && ( skill->guild != CLASS_NONE && ( !IS_GUILDED( ch ) || ( ch->pcdata->clan->Class != skill->guild ) ) ) )
act_info.c:            if( ch->level >= skill->skill_level[ch->Class] )
act_info.c:            if( ch->level >= skill->race_level[ch->race] )
act_info.c:         if( ch->pcdata->learned[sn] <= 0 && SPELL_FLAG( skill, SF_SECRETSKILL ) )
act_info.c:         if( ch->pcdata->learned[normalSn] > 0 )
act_info.c:         pager_printf( ch, " %3d%% ", ch->pcdata->learned[normalSn] );
act_info.c:      pager_printf( ch, "You have %d practice sessions left.\r\n", ch->practice );
act_info.c:      if( ch->practice <= 0 )
act_info.c:      if( can_prac && ( ( sn == -1 ) || ( !IS_NPC( ch ) && ch->level < skill_table[sn]->skill_level[ch->Class]
act_info.c:                                          && ch->level < skill_table[sn]->race_level[ch->race] ) ) )
act_info.c:	     && ch->pcdata->clan->class != skill_table[sn]->guild )
act_info.c:       if ( mob->level < skill_table[sn]->skill_level[ch->class]
act_info.c:      adept = ( int )( class_table[ch->Class]->skill_adept * 0.2 );
act_info.c:      if( ch->pcdata->learned[sn] >= adept )
act_info.c:         ch->practice--;
act_info.c:         ch->pcdata->learned[sn] += int_app[get_curr_int( ch )].learn;
act_info.c:         if( ch->pcdata->learned[sn] >= adept )
act_info.c:            ch->pcdata->learned[sn] = adept;
act_info.c:         wimpy = ( int )( ch->max_hit / 2.25 );
act_info.c:         wimpy = ( int )( ch->max_hit / 1.2 );
act_info.c:      wimpy = ( int )ch->max_hit / 5;
act_info.c:   if( IS_PKILL( ch ) && wimpy > ( int )ch->max_hit / 2.25 )
act_info.c:   else if( wimpy > ( int )ch->max_hit / 1.2 )
act_info.c:   ch->wimpy = wimpy;
act_info.c:   DISPOSE( ch->pcdata->pwd );
act_info.c:   ch->pcdata->pwd = str_dup( pwdnew );
act_info.c:   if( ch->desc && ch->desc->host[0] != '\0' )
act_info.c:      log_printf( "%s changing password from site %s\n", ch->name, ch->desc->host );
act_info.c:      log_printf( "%s changing thier password with no descriptor!", ch->name );
act_info.c:      if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_SILENCE ) )
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_RACETALK ) ? " &G+RACETALK" : " &g-racetalk" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_CHAT ) ? " &G+CHAT" : " &g-chat" );
act_info.c:         ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_AUCTION ) ? " &G+AUCTION" : " &g-auction" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_TRAFFIC ) ? " &G+TRAFFIC" : " &g-traffic" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_QUEST ) ? " &G+QUEST" : " &g-quest" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_WARTALK ) ? " &G+WARTALK" : " &g-wartalk" );
act_info.c:         ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_AVTALK ) ? " &G+AVATAR" : " &g-avatar" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_MUSIC ) ? " &G+MUSIC" : " &g-music" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_ASK ) ? " &G+ASK" : " &g-ask" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_SHOUT ) ? " &G+SHOUT" : " &g-shout" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_YELL ) ? " &G+YELL" : " &g-yell" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_TELLS ) ? " &G+TELLS" : " &g-tells" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_WHISPER ) ? " &G+WHISPER" : " &g-whisper" );
act_info.c:      if( !IS_NPC( ch ) && ch->pcdata->clan )
act_info.c:         if( ch->pcdata->clan->clan_type == CLAN_ORDER )
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_ORDER ) ? " &G+ORDER" : " &g-order", ch );
act_info.c:         else if( ch->pcdata->clan->clan_type == CLAN_GUILD )
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_GUILD ) ? " &G+GUILD" : " &g-guild", ch );
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_CLAN ) ? " &G+CLAN" : " &g-clan", ch );
act_info.c:      if( IS_IMMORTAL( ch ) || ( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, "Newbie Council" ) ) )
act_info.c:         ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_NEWBIE ) ? " &G+NEWBIE" : " &g-newbie" );
act_info.c:      if( !IS_NPC( ch ) && ch->pcdata->council )
act_info.c:         ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_COUNCIL ) ? " &G+COUNCIL" : " &g-council" );
act_info.c:      if( !IS_NPC( ch ) && IS_SET( ch->pcdata->flags, PCFLAG_RETIRED ) )
act_info.c:         ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_RETIRED ) ? " &G+RETIRED" : " &g-retired" );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_IMMTALK ) ? " &G+IMMTALK" : " &g-immtalk", ch );
act_info.c:/*          send_to_char_color( !IS_SET( ch->deaf, CHANNEL_PRAY )       ?
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_HIGHGOD ) ? " &G+MUSE" : " &g-muse", ch );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_MONITOR ) ? " &G+MONITOR" : " &g-monitor", ch );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_DEATH ) ? " &G+DEATH" : " &g-death", ch );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_AUTH ) ? " &G+AUTH" : " &g-auth", ch );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_LOG ) ? " &G+LOG" : " &g-log", ch );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_BUILD ) ? " &G+BUILD" : " &g-build", ch );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_COMM ) ? " &G+COMM" : " &g-comm", ch );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_WARN ) ? " &G+WARN" : " &g-warn", ch );
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_HIGH ) ? " &G+HIGH" : " &g-high", ch );
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_BUG ) ? " &G+BUG" : " &g-bug", ch );
act_info.c:      else if( !str_cmp( arg + 1, "clan" ) && !IS_NPC( ch ) && ch->pcdata->clan
act_info.c:               && ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD )
act_info.c:      else if( !str_cmp( arg + 1, "council" ) && !IS_NPC( ch ) && ch->pcdata->council )
act_info.c:      else if( !str_cmp( arg + 1, "guild" ) && !IS_NPC( ch ) && ch->pcdata->clan
act_info.c:               && ch->pcdata->clan->clan_type == CLAN_GUILD )
act_info.c:                                                  || ( ch->pcdata->council
act_info.c:                                                       && !str_cmp( ch->pcdata->council->name, "Newbie Council" ) ) ) )
act_info.c:      else if( !str_cmp( arg + 1, "order" ) && !IS_NPC( ch ) && ch->pcdata->clan
act_info.c:               && ch->pcdata->clan->clan_type == CLAN_ORDER )
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_RACETALK );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_AUCTION );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_CHAT );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_QUEST );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_WARTALK );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_PRAY );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_TRAFFIC );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_MUSIC );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_ASK );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_SHOUT );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_YELL );
act_info.c:          * if (ch->pcdata->clan)
act_info.c:          * REMOVE_BIT (ch->deaf, CHANNEL_CLAN);
act_info.c:          * if (ch->pcdata->council)
act_info.c:          * REMOVE_BIT (ch->deaf, CHANNEL_COUNCIL);
act_info.c:          * if (ch->pcdata->guild)
act_info.c:          * REMOVE_BIT (ch->deaf, CHANNEL_GUILD);
act_info.c:         if( ch->level >= LEVEL_IMMORTAL )
act_info.c:            REMOVE_BIT( ch->deaf, CHANNEL_AVTALK );
act_info.c:          * if (ch->level >= sysdata.log_level )
act_info.c:          * REMOVE_BIT (ch->deaf, CHANNEL_COMM);
act_info.c:         SET_BIT( ch->deaf, CHANNEL_RACETALK );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_AUCTION );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_TRAFFIC );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_CHAT );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_QUEST );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_PRAY );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_MUSIC );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_ASK );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_SHOUT );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_WARTALK );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_YELL );
act_info.c:          * if (ch->pcdata->clan)
act_info.c:          * SET_BIT (ch->deaf, CHANNEL_CLAN);
act_info.c:          * if (ch->pcdata->council)
act_info.c:          * SET_BIT (ch->deaf, CHANNEL_COUNCIL);
act_info.c:          * SET_BIT (ch->deaf, CHANNEL_GUILD);
act_info.c:         if( ch->level >= LEVEL_IMMORTAL )
act_info.c:            SET_BIT( ch->deaf, CHANNEL_AVTALK );
act_info.c:          * if (ch->level >= sysdata.log_level)
act_info.c:          * SET_BIT (ch->deaf, CHANNEL_COMM);
act_info.c:         REMOVE_BIT( ch->deaf, bit );
act_info.c:         SET_BIT( ch->deaf, bit );
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) ? "[+] PAGER"
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_GAG ) ? "[+] GAG"
act_info.c:                 xIS_SET( ch->act, PLR_BRIEF ) ? "[+] BRIEF"
act_info.c:                 xIS_SET( ch->act, PLR_COMBINE ) ? "[+] COMBINE"
act_info.c:                 xIS_SET( ch->act, PLR_BLANK ) ? "[+] BLANK"
act_info.c:                 xIS_SET( ch->act, PLR_PROMPT ) ? "[+] PROMPT"
act_info.c:                 xIS_SET( ch->act, PLR_ANSI ) ? "[+] ANSI"
act_info.c:                 xIS_SET( ch->act, PLR_RIP ) ? "[+] RIP"
act_info.c:                 xIS_SET( ch->act, PLR_COMPASS ) ? "[+] COMPASS"
act_info.c:                 : "[-] compass", xIS_SET( ch->act, PLR_AUTOMAP ) ? "[+] AUTOMAP" : "[-] automap" );
act_info.c:                 xIS_SET( ch->act, PLR_AUTOSAC ) ? "[+] AUTOSAC"
act_info.c:                 xIS_SET( ch->act, PLR_AUTOGOLD ) ? "[+] AUTOGOLD"
act_info.c:                 xIS_SET( ch->act, PLR_AUTOLOOT ) ? "[+] AUTOLOOT"
act_info.c:                 : "[-] autoloot", xIS_SET( ch->act, PLR_AUTOEXIT ) ? "[+] AUTOEXIT" : "[-] autoexit" );
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_NORECALL ) ? "[+] NORECALL"
act_info.c:                 : "[-] norecall", IS_SET( ch->pcdata->flags, PCFLAG_NOSUMMON ) ? "[+] NOSUMMON" : "[-] nosummon" );
act_info.c:      if( !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
act_info.c:                    xIS_SET( ch->act, PLR_SHOVEDRAG ) ? "[+] DRAG"
act_info.c:                    : "[-] drag", xIS_SET( ch->act, PLR_NICE ) ? "[+] NICE" : "[-] nice" );
act_info.c:                 xIS_SET( ch->act, PLR_TELNET_GA ) ? "[+] TELNETGA" : "[-] telnetga",
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_GROUPWHO ) ? "[+] GROUPWHO" : "[-] groupwho",
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO ) ? "[+] NOINTRO" : "[-] nointro",
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_BECKON ) ? "[+] BECKON" : "[-] beckon" );
act_info.c:      ch_printf_color( ch, "Pager Length (%d)    Wimpy (&W%d&w)", ch->pcdata->pagerlen, ch->wimpy );
act_info.c:         ch_printf( ch, "Roomvnum [%s]", xIS_SET( ch->act, PLR_ROOMVNUM ) ? "+" : " " );
act_info.c:                 xIS_SET( ch->act, PLR_SILENCE ) ?
act_info.c:                 xIS_SET( ch->act, PLR_NO_EMOTE ) ?
act_info.c:                 xIS_SET( ch->act, PLR_NO_TELL ) ?
act_info.c:                 xIS_SET( ch->act, PLR_LITTERBUG ) ?
act_info.c:                 xIS_SET( ch->act, PLR_THIEF ) ?
act_info.c:                 xIS_SET( ch->act, PLR_KILLER ) ?
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_NODESC ) ? " You are not permitted to set your description.\r\n" : "" );
act_info.c:         if( ( bit == PLR_FLEE || bit == PLR_NICE || bit == PLR_SHOVEDRAG ) && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
act_info.c:            xSET_BIT( ch->act, bit );
act_info.c:            xREMOVE_BIT( ch->act, bit );
act_info.c:            SET_BIT( ch->pcdata->flags, bit );
act_info.c:            REMOVE_BIT( ch->pcdata->flags, bit );
act_info.c:   if( xIS_SET( ch->act, PLR_AFK ) )
act_info.c:      xREMOVE_BIT( ch->act, PLR_AFK );
act_info.c:      xSET_BIT( ch->act, PLR_AFK );
act_info.c:         if( ch->pcdata->learned[normalSn] <= 0 && SPELL_FLAG( skill, SF_SECRETSKILL ) )
act_info.c:         if( i == skill->skill_level[ch->Class] || i == skill->race_level[ch->race] )
act_info.c:                          skn, skill->name, ch->pcdata->learned[normalSn], skill->skill_adept[ch->Class], buf );
act_info.c:      if( IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) )
act_info.c:         ch_printf( ch, "Pager is now enabled at %d lines.\r\n", ch->pcdata->pagerlen );
act_info.c:   ch->pcdata->pagerlen = atoi( arg );
act_info.c:   if( ch->pcdata->pagerlen < 5 )
act_info.c:      ch->pcdata->pagerlen = 5;
act_info.c:   ch_printf( ch, "Page pausing set to %d lines.\r\n", ch->pcdata->pagerlen );
act_info.c:      if( !ch->pcdata->first_ignored )
act_info.c:      for( temp = ch->pcdata->first_ignored; temp; temp = temp->next )
act_info.c:      for( temp = ch->pcdata->first_ignored; temp; temp = next )
act_info.c:         UNLINK( temp, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
act_info.c:   else if( !strcmp( arg, "self" ) || nifty_is_name( arg, ch->name ) )
act_info.c:         if( !ch->reply )
act_info.c:            mudstrlcpy( arg, ch->reply->name, MAX_INPUT_LENGTH );
act_info.c:      for( temp = ch->pcdata->first_ignored, i = 0; temp; temp = temp->next, i++ )
act_info.c:            UNLINK( temp, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
act_info.c:         LINK( inew, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
act_info.c:   for( temp = ch->pcdata->first_ignored; temp; temp = temp->next )
act_info.c:      if( nifty_is_name( temp->name, ign_ch->name ) )
act_move.c:   cur = ch->carry_weight;
act_move.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_NOFLOOR )
act_move.c:       && ( !IS_AFFECTED( ch, AFF_FLYING ) || ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLYING ) ) ) )
act_move.c:         bug( "Falling (in a loop?) more than 80 rooms: vnum %d", ch->in_room->vnum );
act_move.c:      move_char( ch, get_exit( ch->in_room, DIR_DOWN ), ++fall );
act_move.c: if( ch->pcdata->cpose )
act_move.c:      ch->pcdata->cpose = str_dup( " is here." );
act_move.c:      if( IS_DRUNK( ch, 2 ) && ( ch->position != POS_SHOVE ) && ( ch->position != POS_DRAG ) )
act_move.c:      if( ch->pcdata->nuisance && ch->pcdata->nuisance->flags > 8 &&
act_move.c:          ( ch->position != POS_SHOVE ) && ( ch->position != POS_DRAG ) &&
act_move.c:          number_percent(  ) > ( ch->pcdata->nuisance->flags * ch->pcdata->nuisance->power ) )
act_move.c:      pexit = get_exit( ch->in_room, door );
act_move.c:      log_printf( "move_char: %s to door %d", ch->name, pexit->vdir );
act_move.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_MOUNTED ) )
act_move.c:   in_room = ch->in_room;
act_move.c:      if( drunk && ch->position != POS_MOUNTED
act_move.c:          && ch->in_room->sector_type != SECT_WATER_SWIM
act_move.c:          && ch->in_room->sector_type != SECT_WATER_NOSWIM
act_move.c:          && ch->in_room->sector_type != SECT_UNDERWATER && ch->in_room->sector_type != SECT_OCEANFLOOR )
act_move.c:               ch->position = POS_RESTING;
act_move.c:               ch->position = POS_INCAP;
act_move.c:   if( IS_SET( pexit->exit_info, EX_NOMOB ) && IS_NPC( ch ) && !xIS_SET( ch->act, ACT_PET ) )
act_move.c:   if( !fall && IS_AFFECTED( ch, AFF_CHARM ) && ch->master && in_room == ch->master->in_room )
act_move.c:   if( IS_NPC(ch) && xIS_SET( to_room->room_flags, ROOM_NO_MOB ) && !xIS_SET( ch->act, ACT_PET ) )
act_move.c:   if( !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && ch->in_room->area != to_room->area )
act_move.c:      if( ch->level < to_room->area->low_hard_range )
act_move.c:         switch ( to_room->area->low_hard_range - ch->level )
act_move.c:      else if( ch->level > to_room->area->hi_hard_range )
act_move.c:          && !IS_SET( ch->in_room->area->flags, AFLAG_NOPKILL ) && ( IS_PKILL( ch ) && !IS_IMMORTAL( ch ) ) )
act_move.c:         if( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:         if( !ch->mount && !IS_AFFECTED( ch, AFF_FLYING ) )
act_move.c:         if( ( ch->mount && !IS_FLOATING( ch->mount ) ) || !IS_FLOATING( ch ) )
act_move.c:               if( ch->mount )
act_move.c:         if( ch->mount && IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:         if( !found && !ch->mount )
act_move.c:            if( ( !IS_NPC( ch ) && number_percent(  ) > LEARNED( ch, gsn_climb ) ) || drunk || ch->mental_state < -90 )
act_move.c:      if( ch->mount )
act_move.c:         switch ( ch->mount->position )
act_move.c:         if( !IS_FLOATING( ch->mount ) )
act_move.c:         if( ch->mount->move < move )
act_move.c:         if( ch->move < move )
act_move.c:      if( ch->mount )
act_move.c:         ch->mount->move -= move;
act_move.c:         ch->move -= move;
act_move.c:      int count = ch->mount ? 1 : 0;
act_move.c:            if( ch->mount && count == to_room->tunnel )
act_move.c:   if( !IS_AFFECTED( ch, AFF_SNEAK ) && ( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_WIZINVIS ) ) )
act_move.c:         if( ch->mount )
act_move.c:            if( IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:            else if( IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:            else if( ch->position == POS_SHOVE )
act_move.c:            else if( ch->position == POS_DRAG )
act_move.c:      if( ch->mount )
act_move.c:         act( AT_ACTION, buf, ch, NULL, ch->mount, TO_NOTVICT );
act_move.c:   if( ch->mount )
act_move.c:      rprog_leave_trigger( ch->mount );
act_move.c:      if( char_died( ch->mount ) )
act_move.c:      if( ch->mount )
act_move.c:         char_from_room( ch->mount );
act_move.c:         char_to_room( ch->mount, to_room );
act_move.c:   if( !IS_AFFECTED( ch, AFF_SNEAK ) && ( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_WIZINVIS ) ) )
act_move.c:      else if( ch->mount )
act_move.c:         if( IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:         else if( IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:         else if( ch->position == POS_SHOVE )
act_move.c:         else if( ch->position == POS_DRAG )
act_move.c:      if( ch->mount )
act_move.c:         act( AT_ACTION, buf, ch, NULL, ch->mount, TO_ROOM );
act_move.c:   if( !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && ch->in_room->area != to_room->area )
act_move.c:      if( ch->level < to_room->area->low_soft_range )
act_move.c:      else if( ch->level > to_room->area->hi_soft_range )
act_move.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_DEATH ) && !IS_IMMORTAL( ch ) )
act_move.c:      if( xIS_SET( ch->act, PLR_BRIEF ) )
act_move.c:      xREMOVE_BIT( ch->act, PLR_BRIEF );
act_move.c:      xSET_BIT( ch->act, PLR_BRIEF );
act_move.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_DEATH ) && !IS_IMMORTAL( ch ) )
act_move.c:      snprintf( buf, MAX_STRING_LENGTH, "%s hit a DEATH TRAP in room %d!", ch->name, ch->in_room->vnum );
act_move.c:      for( fch = from_room->first_person; fch; fch = fch->next_in_room )
act_move.c:         nextinroom = fch->next_in_room;
act_move.c:             && fch->master == ch && fch->position == POS_STANDING )
act_move.c:   if( ch->in_room->first_content )
act_move.c:      if( !IS_AFFECTED( ch, AFF_FLOATING ) || ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLOATING ) ) )
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_NORTH ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_EAST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_SOUTH ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_WEST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_UP ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_DOWN ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_NORTHEAST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_NORTHWEST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_SOUTHEAST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_SOUTHWEST ), 0 );
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:   if( ( pexit = get_exit( ch->in_room, door ) ) == NULL )
act_move.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c:            for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:      if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c:         for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
act_move.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_bashdoor]->skill_level[ch->Class] )
act_move.c:   if( ch->fighting )
act_move.c:          && ch->move >= 15 && number_percent(  ) < ( schance + 4 * ( get_curr_str( ch ) - 19 ) ) )
act_move.c:             && ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c:            for( rch = to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:         damage( ch, ch, ( ch->max_hit / 20 ), gsn_bashdoor );
act_move.c:         damage( ch, ch, ( ch->max_hit / 20 ) + 10, gsn_bashdoor );
act_move.c:      damage( ch, ch, ( ch->max_hit / 20 ) + 10, gsn_bashdoor );
act_move.c:   switch ( ch->position )
act_move.c:         ch->position = POS_STANDING;
act_move.c:         ch->position = POS_STANDING;
act_move.c:         ch->position = POS_STANDING;
act_move.c:   switch ( ch->position )
act_move.c:         ch->position = POS_SITTING;
act_move.c:         ch->position = POS_SITTING;
act_move.c:         ch->position = POS_SITTING;
act_move.c:   switch ( ch->position )
act_move.c:         ch->position = POS_RESTING;
act_move.c:         ch->position = POS_RESTING;
act_move.c:         ch->position = POS_RESTING;
act_move.c:   switch ( ch->position )
act_move.c:         if( ch->mental_state > 30 && ( number_percent(  ) + 10 ) < ch->mental_state )
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:         if( ch->mental_state > 30 && ( number_percent(  ) + 5 ) < ch->mental_state )
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:         if( ch->mental_state > 30 && number_percent(  ) < ch->mental_state )
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_DEATH ) && !IS_IMMORTAL( ch ) )
act_move.c:      snprintf( buf, MAX_STRING_LENGTH, "%s hit a DEATH TRAP in room %d!", ch->name, ch->in_room->vnum );
act_move.c:   ROOM_INDEX_DATA *start = ch->in_room, *dest;
act_move.c:      nch_next = nch->next_in_room;
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:      if( ch->in_room->sector_type != SECT_INSIDE && IS_OUTSIDE( ch ) )
act_move.c:         for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:      if( ch->in_room->sector_type == SECT_INSIDE || !IS_OUTSIDE( ch ) )
act_move.c:         for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:   if( ( room = ch->in_room ) == NULL )
act_move.c:      bug( "%s: %s not in a room?!?", __func__, ch->name );
act_move.c:      int count = ch->mount ? 1 : 0;
act_move.c:               if( ( ch->mount && !IS_FLOATING( ch->mount ) ) || ( !ch->mount && !IS_FLOATING( ch ) ) )
act_move.c:         if( ( ch->mount && !IS_FLOATING( ch->mount ) ) || ( !ch->mount && !IS_FLOATING( ch ) ) )
act_move.c:      if( ch->mount )
act_move.c:         char_from_room( ch->mount );
act_move.c:         char_to_room( ch->mount, xit->to_room );
act_move.c:            do_look( ch->mount, "auto" );
act_obj.c:   if( !CAN_WEAR( obj, ITEM_TAKE ) && ( ch->level < sysdata.level_getobjnotake ) )
act_obj.c:         if( !is_name( ch->name, obj->action_desc ) && !IS_IMMORTAL( ch ) )
act_obj.c:   if( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:            if( ( ch->carry_weight + weight ) > can_carry_w( ch ) )
act_obj.c:      else if( ( ch->carry_weight + weight ) > can_carry_w( ch ) )
act_obj.c:      if( IS_OBJ_STAT( container, ITEM_CLANCORPSE ) && !IS_NPC( ch ) && str_cmp( container->name + 7, ch->name ) )
act_obj.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_obj.c:      save_house_by_vnum( ch->in_room->vnum ); /* House Object Saving */
act_obj.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) && ( !container || container->carried_by == NULL ) )
act_obj.c:         if( vault->vnum == ch->in_room->vnum )
act_obj.c:      ch->gold += amt;
act_obj.c:      new_ob = create_object( get_obj_index( first_ob->value[2] ), ch->level );
act_obj.c:   if( ch->carry_number < 0 || ch->carry_weight < 0 )
act_obj.c:      log_printf( "%s has negative carry_number or carry_weight!", ch->name );
act_obj.c:      if( ( ch->carry_number + number ) > can_carry_n( ch ) )
act_obj.c:         obj = get_obj_list( ch, arg1, ch->in_room->first_content );
act_obj.c:         if( xIS_SET( ch->in_room->room_flags, ROOM_DONATION ) )
act_obj.c:         for( obj = ch->in_room->last_content; obj; obj = obj_next )
act_obj.c:                   || ch->carry_number >= can_carry_n( ch )
act_obj.c:                   || ch->carry_weight >= can_carry_w( ch ) || ( number && cnt >= number ) )
act_obj.c:            if( ch->carry_weight + container->weight > can_carry_w( ch ) )
act_obj.c:                && !IS_NPC( ch ) && ( get_timer( ch, TIMER_PKILLED ) > 0 ) && str_cmp( name, ch->name ) )
act_obj.c:                && str_cmp( name, ch->name ) && str_cmp( container->action_desc, ch->name ) )
act_obj.c:                && !IS_NPC( ch ) && str_cmp( name, ch->name ) && container->value[5] >= 3 )
act_obj.c:                && !IS_NPC( ch ) && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY )
act_obj.c:                && container->value[4] - ch->level < 6 && container->value[4] - ch->level > -6 )
act_obj.c:            if( !str_cmp( name, ch->name ) && !IS_IMMORTAL( ch ) )
act_obj.c:               for( gch = first_char; gch; gch = gch->next )
act_obj.c:                  if( !IS_NPC( gch ) && is_same_group( ch, gch ) && !str_cmp( name, gch->name ) )
act_obj.c:             && !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && str_cmp( ch->name, container->name + 7 ) )
act_obj.c:                   || ch->carry_number >= can_carry_n( ch )
act_obj.c:                   || ch->carry_weight >= can_carry_w( ch ) || ( number && cnt >= number ) )
act_obj.c:      if( ch->carry_weight + container->weight > can_carry_w( ch ) )
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_obj.c:         save_house_by_vnum( ch->in_room->vnum ); /* House Object Saving */
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) && container->carried_by == NULL )
act_obj.c:            if( vault->vnum == ch->in_room->vnum )
act_obj.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_obj.c:         save_house_by_vnum( ch->in_room->vnum ); /* House Object Saving */
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) && container->carried_by == NULL )
act_obj.c:            if( vault->vnum == ch->in_room->vnum )
act_obj.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_LITTERBUG ) )
act_obj.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_NODROP ) && ch != supermob )
act_obj.c:         if( ch->gold < number )
act_obj.c:         ch->gold -= number;
act_obj.c:         for( obj = ch->in_room->first_content; obj; obj = obj_next )
act_obj.c:         obj_to_room( create_money( number ), ch->in_room );
act_obj.c:      if( ch->in_room->max_weight > 0
act_obj.c:         && ch->in_room->max_weight < get_real_obj_weight( obj ) / obj->count + ch->in_room->weight )
act_obj.c:      obj = obj_to_room( obj, ch->in_room );
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_obj.c:         save_house_by_vnum( ch->in_room->vnum ); /* House Object Saving */
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:            if( vault->vnum == ch->in_room->vnum )
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_NODROPALL ) || xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:            && ( !ch->in_room->max_weight || ch->in_room->max_weight > get_real_obj_weight( obj ) / obj->count + ch->in_room->weight ) )
act_obj.c:                  obj_next = ch->first_carrying;
act_obj.c:            obj = obj_to_room( obj, ch->in_room );
act_obj.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_obj.c:      save_house_by_vnum( ch->in_room->vnum ); /* House Object Saving */
act_obj.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:         if( vault->vnum == ch->in_room->vnum )
act_obj.c:      if( ch->gold < amount )
act_obj.c:      ch->gold -= amount;
act_obj.c:   if( !IS_NPC( ch ) && ( !IS_PKILL( ch ) || ( IS_PKILL( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) ) ) )
act_obj.c:            ch->armor += apply_ac( obj, obj->wear_loc );
act_obj.c:               ch->armor -= apply_ac( obj, obj->wear_loc );
act_obj.c:            ch->armor -= apply_ac( obj, obj->wear_loc );
act_obj.c:    	log_printf( "%s scrapped %s (vnum: %d)", ch->name, obj->short_descr, obj->pIndexData->vnum );
act_obj.c:   if( !fReplace && ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:   if( IS_NPC( ch ) || ch->pcdata->learned[gsn_dual_wield] )
act_obj.c:   for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
act_obj.c:       && ( ( IS_OBJ_STAT( obj, ITEM_ANTI_WARRIOR ) && ch->Class == CLASS_WARRIOR )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_WARRIOR ) && ch->Class == CLASS_SAVAGE )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_WARRIOR ) && ch->Class == CLASS_PALADIN )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_MAGE ) && ch->Class == CLASS_MAGE )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_MAGE ) && ch->Class == CLASS_NEPHANDI )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_THIEF ) && ch->Class == CLASS_THIEF )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_VAMPIRE ) && ch->Class == CLASS_VAMPIRE )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_DRUID ) && ch->Class == CLASS_DRUID )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_WARRIOR ) && ch->Class == CLASS_RANGER )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_MAGE ) && ch->Class == CLASS_AUGURER )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_CLERIC ) && ch->Class == CLASS_CLERIC )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_GOOD ) && ch->alignment > 350 )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_NEUTRAL ) && ch->alignment >= -350 && ch->alignment <= 350 )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_EVIL ) && ch->alignment < -350 ) ) )
act_obj.c:   if( IS_OBJ_STAT( obj, ITEM_PERSONAL ) && str_cmp( ch->name, obj->owner ) )
act_obj.c:      obj_to_room( obj, ch->in_room );
act_obj.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:      for( obj = ch->first_carrying; obj != NULL; obj = obj_next )
act_obj.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
act_obj.c:   obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
act_obj.c:   switch( ch->in_room->sector_type )
act_obj.c:   if( move > ch->move )
act_obj.c:   ch->move -= move;
act_obj.c:   if( arg[0] == '\0' || !str_cmp( arg, ch->name ) )
act_obj.c:   obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
act_obj.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:         if( ch->level - obj->value[5] > 5 || obj->value[5] - ch->level > 5 )
act_obj.c:   if( !IS_NPC( ch ) && ch->pcdata->deity && ch->pcdata->deity->name[0] != '\0' )
act_obj.c:      mudstrlcpy( name, ch->pcdata->deity->name, 50 );
act_obj.c:   else if( !IS_NPC( ch ) && ch->pcdata->clan && ch->pcdata->clan->deity[0] != '\0' )
act_obj.c:      mudstrlcpy( name, ch->pcdata->clan->deity, 50 );
act_obj.c:   ch->gold += 1;
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_obj.c:         save_house_by_vnum( ch->in_room->vnum ); /* Prevent House Object Duplication */
act_obj.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_obj.c:      save_house_by_vnum( ch->in_room->vnum ); /* Prevent House Object Duplication */
act_obj.c:      for( vch = ch->in_room->first_person; vch; vch = vch_next )
act_obj.c:         vch_next = vch->next_in_room;
act_obj.c:         if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
act_obj.c:   if( arg[0] == '\0' && !ch->fighting )
act_obj.c:      if( ch->fighting )
act_obj.c:   if( ch->level < 3 )
act_obj.c:         if( ch->level < auction->item->level )
act_obj.c:         if( newbet > ch->gold )
act_obj.c:         ch->gold -= newbet;  /* substract the gold - important :) */
act_obj.c:            for( rch = obj->in_room->first_person; rch; rch = rch->next_in_room, chcnt++ )
act_obj.c:            if( IS_NPC( vch ) && xIS_SET( vch->act, ACT_HARDHAT ) )
act_obj.c:               damage( vch, vch, dam * vch->level, TYPE_UNDEFINED );
act_obj.c:   obj = recursive_note_find( ch->first_carrying, argument );
act_wiz.c:   if( !IS_NPC( ch ) && ch->pcdata )
act_wiz.c:      if( IS_SET( ch->pcdata->flags, PCFLAG_DND ) )
act_wiz.c:         REMOVE_BIT( ch->pcdata->flags, PCFLAG_DND );
act_wiz.c:         SET_BIT( ch->pcdata->flags, PCFLAG_DND );
act_wiz.c:      if( ch->level >= LEVEL_IMPLEMENTOR )
act_wiz.c:      snprintf( fname, 256, "%s%s", WATCH_DIR, strlower( ch->name ) );
act_wiz.c:      snprintf( fname, 256, "%s%s", WATCH_DIR, strlower( ch->name ) );
act_wiz.c:      snprintf( fname, 256, "%s%s", WATCH_DIR, strlower( ch->name ) );
act_wiz.c:   if( ch->level >= LEVEL_IMPLEMENTOR && !str_cmp( arg, "show" ) && !str_cmp( arg2, "all" ) )
act_wiz.c:            if( !str_cmp( ch->name, pw->imm_name ) )
act_wiz.c:            if( !str_cmp( ch->name, pw->imm_name ) )
act_wiz.c:            if( !str_cmp( ch->name, pw->imm_name ) && pw->target_name && !str_cmp( arg2, pw->target_name ) )
act_wiz.c:      pinsert->imm_name = str_dup( strlower( ch->name ) );
act_wiz.c:            if( !str_cmp( ch->name, pw->imm_name ) && pw->player_site && !str_cmp( arg2, pw->player_site ) )
act_wiz.c:      pinsert->imm_name = str_dup( strlower( ch->name ) );
act_wiz.c:         if( !str_cmp( ch->name, pw->imm_name ) && pw->target_name && !str_cmp( arg2, pw->target_name ) )
act_wiz.c:      pinsert->imm_name = str_dup( strlower( ch->name ) );
act_wiz.c:      log_printf( "%s restricting %s to level %d", ch->name, cmd->name, level );
act_wiz.c:      victim->pcdata->authed_by = QUICKLINK( ch->name );
act_wiz.c:      DISPOSE( ch->pcdata->bamfin );
act_wiz.c:      ch->pcdata->bamfin = newbamf;
act_wiz.c:      DISPOSE( ch->pcdata->bamfout );
act_wiz.c:      ch->pcdata->bamfout = newbamf;
act_wiz.c:   DISPOSE( ch->pcdata->rank );
act_wiz.c:      ch->pcdata->rank = str_dup( "" );
act_wiz.c:      ch->pcdata->rank = newrank;
act_wiz.c:      ch_printf( victim, "%s brings you back from retirement.\r\n", ch->name );
act_wiz.c:      ch_printf( victim, "Courtesy of %s, you are now a retired immortal.\r\n", ch->name );
act_wiz.c:      vch_next = vch->next;
act_wiz.c:      if( vch->in_room->area == ch->in_room->area )
act_wiz.c:   if( xIS_SET( ch->act, PLR_NO_EMOTE ) )
act_wiz.c:   if( xIS_SET( ch->act, PLR_NO_EMOTE ) )
act_wiz.c:      echo_to_room( color, ch->in_room, argument );
act_wiz.c:      echo_to_room( AT_IMMORT, ch->in_room, argument );
act_wiz.c:      location = ch->in_room;
act_wiz.c:      ch_printf( victim, "Your DND flag just foiled %s's transfer command.\r\n", ch->name );
act_wiz.c:   snprintf( buf, MAX_STRING_LENGTH, "%d", ch->regoto );
act_wiz.c:   else if( ( wch = get_char_world( ch, arg ) ) == NULL || wch->in_room == NULL )
act_wiz.c:      location = wch->in_room;
act_wiz.c:   if( wch && !IS_NPC( wch ) && IS_SET( wch->pcdata->flags, PCFLAG_DND ) && get_trust( ch ) < get_trust( wch ) )
act_wiz.c:      ch_printf( ch, "Sorry. %s does not wish to be disturbed.\r\n", wch->name );
act_wiz.c:      ch_printf( wch, "Your DND flag just foiled %s's at command.\r\n", ch->name );
act_wiz.c:      ch_printf( victim, "Your DND flag just foiled %s's atmob command\r\n", ch->name );
act_wiz.c:   original = ch->in_room;
act_wiz.c:      ch_printf( victim, "Your DND flag just foiled %s's atobj command\r\n", ch->name );
act_wiz.c:   original = ch->in_room;
act_wiz.c:   original = ch->in_room;
act_wiz.c:      location = ch->in_room;
act_wiz.c:   location = ( arg[0] == '\0' ) ? ch->in_room : find_location( ch, arg );
act_wiz.c:   if( ch->in_room != location && room_is_private( location ) )
act_wiz.c:   switch ( ch->in_room->sector_type )
act_wiz.c:   if( !ch->in_room->first_permaffect )
act_wiz.c:   for( rch = location->first_person; rch; rch = rch->next_in_room )
act_wiz.c:         one_argument( rch->name, buf );
act_wiz.c:   snprintf( buf, MAX_STRING_LENGTH, "Reboot by %s.", ch->name );
act_wiz.c:      for( vch = first_char; vch; vch = vch->next )
act_wiz.c:   snprintf( buf, MAX_STRING_LENGTH, "Shutdown by %s.", ch->name );
act_wiz.c:      for( vch = first_char; vch; vch = vch->next )
act_wiz.c:         if( d->snoop_by == ch->desc )
act_wiz.c:   if( ch->desc )
act_wiz.c:      for( d = ch->desc->snoop_by; d; d = d->snoop_by )
act_wiz.c:   victim->desc->snoop_by = ch->desc;
act_wiz.c:   if( !ch->desc )
act_wiz.c:   if( ch->desc->original )
act_wiz.c:   if( !IS_NPC( victim ) && ch->level < LEVEL_GREATER )
act_wiz.c:   ch->desc->character = victim;
act_wiz.c:   ch->desc->original = ch;
act_wiz.c:   victim->desc = ch->desc;
act_wiz.c:   ch->desc = NULL;
act_wiz.c:   ch->switched = victim;
act_wiz.c:   if( !ch->desc )
act_wiz.c:   if( !ch->desc->original )
act_wiz.c:      xREMOVE_BIT( ch->affected_by, AFF_POSSESS );
act_wiz.c:   ch->desc->character = ch->desc->original;
act_wiz.c:   ch->desc->original = NULL;
act_wiz.c:   ch->desc->character->desc = ch->desc;
act_wiz.c:   ch->desc->character->switched = NULL;
act_wiz.c:   ch->desc = NULL;
act_wiz.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
act_wiz.c:   char_to_room( victim, ch->in_room );
act_wiz.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
act_wiz.c:         level = ch->level;
act_wiz.c:      obj = obj_to_room( obj, ch->in_room );
act_wiz.c:      for( victim = ch->in_room->first_person; victim; victim = vnext )
act_wiz.c:      for( obj = ch->in_room->first_content; obj; obj = obj_next )
act_wiz.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_wiz.c:         save_house_by_vnum( ch->in_room->vnum ); /* Prevent House Object Duplication */
act_wiz.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_wiz.c:            if( vault->vnum == ch->in_room->vnum )
act_wiz.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_wiz.c:         save_house_by_vnum( ch->in_room->vnum ); /* Prevent House Object Duplication */
act_wiz.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_wiz.c:            if( vault->vnum == ch->in_room->vnum )
act_wiz.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_wiz.c:         save_house_by_vnum( ch->in_room->vnum ); /* Prevent House Object Duplication */
act_wiz.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_wiz.c:            if( vault->vnum == ch->in_room->vnum )
act_wiz.c:      snprintf( buf2, MAX_STRING_LENGTH, "%s balzhuring %s", ch->name, buf );
act_wiz.c:            snprintf( buf2, MAX_STRING_LENGTH, "%s destroying %s", ch->name, buf );
act_wiz.c:      if( !ch->pcdata )
act_wiz.c:      ch->pcdata->restore_time = current_time;
act_wiz.c:         vch_next = vch->next;
act_wiz.c:            if( deity && vch->pcdata->deity != deity )
act_wiz.c:               vch->hit = ( short )( vch->max_hit * 1.5 );
act_wiz.c:               vch->hit = vch->max_hit;
act_wiz.c:            vch->mana = vch->max_mana;
act_wiz.c:            vch->move = vch->max_move;
act_wiz.c:            vch->pcdata->condition[COND_BLOODTHIRST] = ( 10 + vch->level );
act_wiz.c:   if( !ch->pcdata )
act_wiz.c:   if( !ch->pcdata->restore_time )
act_wiz.c:   time_passed = current_time - ch->pcdata->restore_time;
act_wiz.c:      ch_printf( victim, "%s is attempting to freeze you.\r\n", ch->name );
act_wiz.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
act_wiz.c:      if( rch->fighting )
act_wiz.c:   for( pwatch = first_watch; pwatch; pwatch = pwatch->next )
act_wiz.c:      fprintf( fp, "%d %s~%s~%s~\n", pwatch->imm_level, pwatch->imm_name,
act_wiz.c:               pwatch->target_name ? pwatch->target_name : " ", pwatch->player_site ? pwatch->player_site : " " );
act_wiz.c:         vch_next = vch->next;
act_wiz.c:         ch->pcdata->wizinvis = level;
act_wiz.c:         ch->mobinvis = level;
act_wiz.c:      if( ch->mobinvis < 2 )
act_wiz.c:         ch->mobinvis = ch->level;
act_wiz.c:   if( ch->pcdata->wizinvis < 2 )
act_wiz.c:      ch->pcdata->wizinvis = ch->level;
act_wiz.c:   if( xIS_SET( ch->act, PLR_WIZINVIS ) )
act_wiz.c:      xREMOVE_BIT( ch->act, PLR_WIZINVIS );
act_wiz.c:      xSET_BIT( ch->act, PLR_WIZINVIS );
act_wiz.c:   if( xIS_SET( ch->act, PLR_HOLYLIGHT ) )
act_wiz.c:      xREMOVE_BIT( ch->act, PLR_HOLYLIGHT );
act_wiz.c:      xSET_BIT( ch->act, PLR_HOLYLIGHT );
act_wiz.c:         char_to_room( d->character, ch->in_room );
act_wiz.c:         snprintf( buf2, MAX_STRING_LENGTH, "%s mortalizing %s", ch->name, buf );
act_wiz.c:               snprintf( buf2, MAX_STRING_LENGTH, "%s mortalizing %s", ch->name, buf );
act_wiz.c:      char_to_room( d->character, ch->in_room );
act_wiz.c:   ch_printf( victim, "%s has bestowed on you the area: %s\r\n", ch->name, argument );
act_wiz.c:      ch_printf( victim, "%s has removed your bestowed commands.\r\n", ch->name );
act_wiz.c:   ch_printf( victim, "%s has bestowed on you the command(s): %s\r\n", ch->name, arg_buf );
act_wiz.c:      ech_next = ech->next;
act_wiz.c:      if( ech->fighting )
act_wiz.c:         if( URANGE( pArea->low_m_vnum, ech->pIndexData->vnum, pArea->hi_m_vnum ) == ech->pIndexData->vnum
act_wiz.c:             || ( ech->in_room && ech->in_room->area == pArea ) )
act_wiz.c:      if( ech->in_room && ech->in_room->area == pArea )
act_wiz.c:         snprintf( buf2, MAX_STRING_LENGTH, "%s destroying %s", ch->name, buf );
act_wiz.c:         snprintf( buf2, MAX_STRING_LENGTH, "%s destroying %s", ch->name, buf );
act_wiz.c:               snprintf( buf2, MAX_STRING_LENGTH, "%s destroying %s", ch->name, buf );
act_wiz.c:      snprintf( buf, MAX_STRING_LENGTH, "%s destroying %s", ch->name, arg );
act_wiz.c:      return ch->name;
act_wiz.c:   one_argument( ch->name, name );  /* copy the first word into name */
act_wiz.c:   for( rch = ch->in_room->first_person; rch && ( rch != ch ); rch = rch->next_in_room )
act_wiz.c:      if( is_name( name, rch->name ) )
act_wiz.c:            old_room = ch->in_room;
act_wiz.c:               old_room = ch->in_room;
act_wiz.c:   victim->pcdata->helled_by = STRALLOC( ch->name );
act_wiz.c:   location = ch->in_room;
act_wiz.c:/*ch->in_room = get_room_index(ROOM_VNUM_HELL);*/
act_wiz.c:/*ch->in_room = location;          The case of unhell self, etc.*/
act_wiz.c:      location = ch->in_room;
act_wiz.c:      if( str_cmp( ch->name, victim->pcdata->helled_by ) )
act_wiz.c:      if( str_cmp( ch->pcdata->council_name, "Quest Council" ) && ( get_trust( ch ) < LEVEL_DEMI ) )
act_wiz.c:                t->tm_mon + 1, t->tm_mday, ch->in_room ? ch->in_room->vnum : 0,
act_wiz.c:                IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
act_wiz.c:   ch_printf( ch, "Kill history for %s:\r\n", vch->name );
act_wiz.c:   for( track = 0; track < MAX_KILLTRACK && vch->pcdata->killed[track].vnum; track++ )
act_wiz.c:      tmob = get_mob_index( vch->pcdata->killed[track].vnum );
act_wiz.c:      ch_printf( ch, "    - killed %d times.\r\n", vch->pcdata->killed[track].count );
act_wiz.c:   if( !ch->desc )
act_wiz.c:   switch ( ch->substate )
act_wiz.c:         if( !ch->pnote )
act_wiz.c:         if( ch->dest_buf != ch->pnote )
act_wiz.c:            bug( "%s", "do_project: sub_writing_note: ch->dest_buf != ch->pnote" );
act_wiz.c:         STRFREE( ch->pnote->text );
act_wiz.c:         ch->pnote->text = copy_buffer( ch );
act_wiz.c:         if( !ch->dest_buf )
act_wiz.c:            bug( "%s", "do_project: sub_project_desc: NULL ch->dest_buf" );
act_wiz.c:            ch->substate = SUB_NONE;
act_wiz.c:         pproject = ( PROJECT_DATA * ) ch->dest_buf;
act_wiz.c:         ch->substate = ch->tempnum;
act_wiz.c:         if( MINE && ( !pproject->owner || str_cmp( ch->name, pproject->owner ) )
act_wiz.c:             && ( !pproject->coder || str_cmp( ch->name, pproject->coder ) ) )
act_wiz.c:      if( str_cmp( ch->pcdata->council_name, "Code Council" )
act_wiz.c:      if( get_trust( ch ) < LEVEL_GOD && str_cmp( ch->pcdata->council_name, "Code Council" ) )
act_wiz.c:      if( get_trust( ch ) < LEVEL_GOD && str_cmp( ch->pcdata->council_name, "Code Council" ) )
act_wiz.c:      ch->tempnum = SUB_NONE;
act_wiz.c:      ch->substate = SUB_PROJ_DESC;
act_wiz.c:      ch->dest_buf = pproject;
act_wiz.c:      if( str_cmp( ch->pcdata->council_name, "Code Council" ) && get_trust( ch ) < LEVEL_ASCENDANT )
act_wiz.c:      pproject->owner = STRALLOC( vch->name );
act_wiz.c:      ch_printf( ch, "Project assigned to %s.\n\r", vch->name );
act_wiz.c:      if( pproject->taken && pproject->owner && !str_cmp( pproject->owner, ch->name ) )
act_wiz.c:      pproject->owner = STRALLOC( ch->name );
act_wiz.c:      if( pproject->coder && !str_cmp( ch->name, pproject->coder ) )
act_wiz.c:      pproject->coder = str_dup( ch->name );
act_wiz.c:      if( pproject->owner && str_cmp( pproject->owner, ch->name ) &&
act_wiz.c:          && pproject->coder && str_cmp( pproject->coder, ch->name ) && str_cmp( ch->pcdata->council_name, "Code Council" ) )
act_wiz.c:         ch->substate = SUB_WRITING_NOTE;
act_wiz.c:         ch->dest_buf = ch->pnote;
act_wiz.c:         start_editing( ch, ch->pnote->text );
act_wiz.c:         STRFREE( ch->pnote->subject );
act_wiz.c:         ch->pnote->subject = STRALLOC( argument );
act_wiz.c:         if( pproject->owner && str_cmp( ch->name, pproject->owner ) &&
act_wiz.c:             pproject->coder && str_cmp( ch->name, pproject->coder ) &&
act_wiz.c:             get_trust( ch ) < LEVEL_GREATER && str_cmp( ch->pcdata->council_name, "Code Council" ) )
act_wiz.c:         if( !ch->pnote )
act_wiz.c:         if( !ch->pnote->subject )
act_wiz.c:         ch->pnote->date = STRALLOC( strtime );
act_wiz.c:         ch->pnote->sender = ch->name;
act_wiz.c:         plog = ch->pnote;
act_wiz.c:         ch->pnote = NULL;
act_wiz.c:             str_cmp( ch->name, pproject->owner ) && get_trust( ch ) < LEVEL_SAVIOR
act_wiz.c:             && str_cmp( ch->name, pproject->coder ) && str_cmp( ch->pcdata->council_name, "Code Council" ) )
act_wiz.c:         if( pproject->owner && str_cmp( ch->name, pproject->owner ) &&
act_wiz.c:             pproject->coder && str_cmp( ch->name, pproject->coder ) && str_cmp( ch->pcdata->council_name, "Code Council" ) )
act_wiz.c:             str_cmp( ch->name, pproject->owner ) && get_trust( ch ) < LEVEL_SAVIOR
act_wiz.c:             && str_cmp( ch->name, pproject->coder ) && str_cmp( ch->pcdata->council_name, "Code Council" ) )
act_wiz.c:      if( inroom && ch->in_room != d->character->in_room )
act_wiz.c:      if( inarea && ch->in_room->area != d->character->in_room->area )
act_wiz.c:      ch_printf( victim, "%s has removed your vnum range.\r\n", ch->name );
act_wiz.c:   ch_printf( victim, "%s has assigned you the vnum range %d - %d.\r\n", ch->name, lo, hi );
agecommand.c:         if( corpse->action_desc && is_name( ch->name, corpse->action_desc ) );
agecommand.c:             && ( skill->guild != CLASS_NONE && ( !IS_GUILDED( ch ) || ( ch->pcdata->clan->Class != skill->guild ) ) ) )
agecommand.c:            if( ch->level >= skill->skill_level[ch->Class] )
agecommand.c:            if( ch->level >= skill->race_level[ch->race] )
agecommand.c:         if( ch->pcdata->learned[sn] <= 0 && SPELL_FLAG( skill, SF_SECRETSKILL ) )
agecommand.c:if ( ch->pcdata->learned[normalSn] <= 99 )
agecommand.c:         if( ch->pcdata->learned[normalSn] > 99 )
agecommand.c:         if( ch->pcdata->learned[normalSn] < 99 )
agecommand.c:pager_printf( ch, "You have a balance of %d\r\n", ch->pcdata->balance);
agecommand.c:      amount = ch->pcdata->balance;
agecommand.c:   if( amount > ch->pcdata->balance )
agecommand.c:   ch->pcdata->balance -= amount;
agecommand.c:   ch->gold += amount;
agecommand.c:pager_printf( ch, "How much gold would you like to deposit, %s?", ch->name );
agecommand.c:pager_printf( ch, "How much gold would you like to deposit, %s?", ch->name );
agecommand.c:      amount = ch->gold;
agecommand.c:   if( amount > ch->gold )
agecommand.c:pager_printf( ch, "Sorrym %s, you do not have that much gold", ch->name );
agecommand.c:pager_printf( ch, "How much gold would you like to deposit, %s?", ch->name );
agecommand.c:   ch->gold -= amount;
agecommand.c:   ch->pcdata->balance += amount;
agecommand.c:        if ( ch->pcdata->souls <= 1999)
agecommand.c:        ch->pcdata->souls -= 2000;
agecommand.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOCPOSE ) )
agecommand.c:      ch->pcdata->cpose = str_dup( " is here." );
agecommand.c:   ch->pcdata->cpose = STRALLOC( buf );
agecommand.c:      ch->pcdata->customclass = str_dup( "Adventurer" );
agecommand.c:   ch->pcdata->customclass = STRALLOC( buf );
agecommand.c:pager_printf( ch, "&CYou are a level %d %s %s from %s.\r\n", ch->level, capitalize( get_race( ch ) ),  ch->pcdata->customclass, ch->pcdata->hometown  );
agecommand.c:pager_printf( ch, "Your TIER rank is %d.\r\n\r\n", ch->pcdata->tier);
agecommand.c:                    (ch->pcdata->str + ch->pcdata->strplus), (ch->pcdata->str + ch->pcdata->att + ch->damroll),  ch->pcdata->attlevel );
agecommand.c:                    (ch->pcdata->dex + ch->pcdata->strplus), (ch->pcdata->def + ch->pcdata->defplus) , ch->pcdata->deflevel );
agecommand.c:                    (ch->pcdata->intel + ch->pcdata->intplus) , (ch->pcdata->mdef + ch->pcdata->mdefplus), ch->pcdata->mlevel );
agecommand.c:                    (ch->pcdata->lck + ch->pcdata->lckplus ) );
agecommand.c:                    ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move );
agecommand.c:                    ch->gold, ch->pcdata->ap, ch->practice );
agecommand.c:   switch ( ch->position )
agecommand.c:   switch ( ch->style )
agecommand.c:      switch ( ch->mental_state / 10 )
agecommand.c:pager_printf( ch, "Your Cpose is set at '%s'\r\n", ch->pcdata->cpose );
agecommand.c:                    ch->pcdata->pkills, ch->pcdata->illegal_pk, ch->pcdata->pdeaths );
agecommand.c:   if( ch->pcdata->clan && ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD )
agecommand.c:                    ch->pcdata->clan->name, ch->pcdata->clan->pkills[6],
agecommand.c:                    ( ch->pcdata->clan->pkills[1] + ch->pcdata->clan->pkills[2] +
agecommand.c:                      ch->pcdata->clan->pkills[3] + ch->pcdata->clan->pkills[4] + ch->pcdata->clan->pkills[5] ) );
agecommand.c:                    ch->pcdata->clan->pdeaths[6],
agecommand.c:                    ( ch->pcdata->clan->pdeaths[1] + ch->pcdata->clan->pdeaths[2] +
agecommand.c:                      ch->pcdata->clan->pdeaths[3] + ch->pcdata->clan->pdeaths[4] + ch->pcdata->clan->pdeaths[5] ) );
agecommand.c:                    xIS_SET( ch->act, PLR_WIZINVIS ) ? "X" : " ", ch->pcdata->wizinvis );
agecommand.c:      pager_printf( ch, "Bamfin:  %s\r\n", ( ch->pcdata->bamfin[0] != '\0' )
agecommand.c:                    ? ch->pcdata->bamfin : "An immortal appears." );
agecommand.c:      pager_printf( ch, "Bamfout: %s\r\n", ( ch->pcdata->bamfout[0] != '\0' )
agecommand.c:                    ? ch->pcdata->bamfout : "The immortal disappears." );
agecommand.c:      if( ch->pcdata->area )
agecommand.c:                       ch->pcdata->area->low_r_vnum, ch->pcdata->area->hi_r_vnum,
agecommand.c:                       ch->pcdata->area->low_o_vnum, ch->pcdata->area->hi_o_vnum,
agecommand.c:                       ch->pcdata->area->low_m_vnum, ch->pcdata->area->hi_m_vnum );
agecommand.c:         pager_printf( ch, "Area Loaded [%s]\r\n", ( IS_SET( ch->pcdata->area->status, AREA_LOADED ) ) ? "yes" : "no" );
agemobcomm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
agemobcomm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
ban.c:   if( !ch->desc )   /* No desc means no go :) */
ban.c:   switch ( ch->substate )
ban.c:         ch->tempnum = SUB_NONE;
ban.c:   if( !ch->desc )   /* No desc is a bad thing */
ban.c:   if( !ch->desc )
ban.c:   switch ( ch->substate )
ban.c:                        temp->ban_by = str_dup( ch->name );
ban.c:               pban->ban_by = str_dup( ch->name );
ban.c:                        temp->ban_by = str_dup( ch->name );
ban.c:               pban->ban_by = str_dup( ch->name );
ban.c:                        temp->ban_by = str_dup( ch->name );
ban.c:               pban->ban_by = str_dup( ch->name );
ban.c:         ch->substate = SUB_BAN_DESC;
ban.c:         ch->dest_buf = pban;
ban.c:         pban = ( BAN_DATA * ) ch->dest_buf;
ban.c:            bug( "%s", "do_ban: sub_ban_desc: NULL ch->dest_buf" );
ban.c:            ch->substate = SUB_NONE;
ban.c:         ch->substate = ch->tempnum;
ban.c:         for( i = 0; i < ( int )( strlen( ch->desc->host ) ); i++ )
ban.c:            new_host[i] = LOWER( ch->desc->host[i] );
ban.c:      if( type == BAN_CLASS && pban->flag == ch->Class )
ban.c:         if( ch->level > pban->level )
ban.c:               log_printf_plus( LOG_WARN, sysdata.log_level, "%s class logging in from %s.", pban->name, ch->desc->host );
ban.c:      if( type == BAN_RACE && pban->flag == ch->race )
ban.c:         if( ch->level > pban->level )
ban.c:               log_printf_plus( LOG_WARN, sysdata.log_level, "%s race logging in from %s.", pban->name, ch->desc->host );
ban.c:            if( ch->level > pban->level )
ban.c:                  log_printf_plus( LOG_WARN, sysdata.log_level, "%s logging in from site %s.", ch->name, ch->desc->host );
bank.c:   for( banker = ch->in_room->first_person; banker; banker = banker->next_in_room )
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "Sorry, %s, we don't do business with mobs.", ch->short_descr );
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s How much gold do you wish to deposit?", ch->name );
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s How much gold do you wish to deposit?", ch->name );
bank.c:      amount = ch->gold;
bank.c:   if( amount > ch->gold )
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s Sorry, but you don't have that much gold to deposit.", ch->name );
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s Oh, I see.. your a comedian.", ch->name );
bank.c:   ch->gold -= amount;
bank.c:   ch->pcdata->balance += amount;
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "Sorry, %s, we don't do business with mobs.", ch->short_descr );
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s How much gold do you wish to withdraw?", ch->name );
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s How much gold do you wish to withdraw?", ch->name );
bank.c:      amount = ch->pcdata->balance;
bank.c:   if( amount > ch->pcdata->balance )
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s But you do not have that much gold in your account!", ch->name );
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s Oh I see.. your a comedian.", ch->name );
bank.c:   ch->pcdata->balance -= amount;
bank.c:   ch->gold += amount;
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "Sorry, %s, we don't do business with mobs.", ch->short_descr );
bank.c:   ch_printf( ch, "You have %d gold in the bank.\r\n", ch->pcdata->balance );
boards.c:      if( is_name( ch->name, board->extra_removers ) )
boards.c:      if( ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, board->read_group ) )
boards.c:      if( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, board->read_group ) )
boards.c:      if( is_name( ch->name, board->extra_readers ) )
boards.c:      if( ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, board->post_group ) )
boards.c:      if( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, board->post_group ) )
boards.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
boards.c:   if( !str_cmp( ch->name, pnote->sender ) )
boards.c:   if( is_name( ch->name, pnote->to_list ) )
boards.c:   if( ch->pnote )
boards.c:   pnote->sender = QUICKLINK( ch->name );
boards.c:   ch->pnote = pnote;
boards.c:   for( quill = ch->last_carrying; quill; quill = quill->prev_content )
boards.c:   switch ( ch->substate )
boards.c:   switch ( ch->substate )
boards.c:   if( !ch->desc )
boards.c:   switch ( ch->substate )
boards.c:         ed = ( EXTRA_DESCR_DATA * ) ch->dest_buf;
boards.c:                      ( board->extra_ballots[0] != '\0' && is_name( ch->name, board->extra_ballots ) ) )
boards.c:                  if( ch->gold < 10 && get_trust( ch ) < sysdata.read_mail_free )
boards.c:                     ch->gold -= 10;
boards.c:      if( pnote->no_remove != 0 && pnote->no_remove > ch->level )
boards.c:      pnote->no_remove = ch->level;
boards.c:         if( str_cmp( ch->name, pnote->sender ) && get_trust( ch ) < LEVEL_GREATER )
boards.c:         if( str_cmp( ch->name, pnote->sender ) && get_trust( ch ) < LEVEL_GREATER )
boards.c:         if( str_cmp( ch->name, pnote->sender ) )
boards.c:      if( is_name( ch->name, buf ) )
boards.c:         snprintf( buf, MAX_STRING_LENGTH, "%s %s", pnote->yesvotes, ch->name );
boards.c:         snprintf( buf, MAX_STRING_LENGTH, "%s %s", pnote->novotes, ch->name );
boards.c:         snprintf( buf, MAX_STRING_LENGTH, "%s %s", pnote->abstentions, ch->name );
boards.c:      if( ch->substate == SUB_RESTRICTED )
boards.c:         ch->substate = SUB_WRITING_NOTE;
boards.c:         ch->dest_buf = ed;
boards.c:      ch_printf( ch, "%s: %s\r\nTo: %s\r\n", ch->name, subject, to_list );
boards.c:      pnote->sender = QUICKLINK( ch->name );
boards.c:      if( ch->substate == SUB_RESTRICTED )
boards.c:         ch->substate = SUB_WRITING_NOTE;
boards.c:         ch->dest_buf = ed;
boards.c:                && ( get_trust( ch ) < sysdata.take_others_mail ) && ( take == 1 ) && str_cmp( ch->name, pnote->sender ) )
boards.c:            if( pnote->no_remove != 0 && ( take == 1 || take == 0 ) && ch->level < pnote->no_remove )
boards.c:               if( ch->gold < 50 && get_trust( ch ) < sysdata.read_mail_free )
boards.c:                  ch->gold -= 50;
boards.c:            if( is_name( ch->name, note->to_list ) )
boards.c:            else if( !str_cmp( ch->name, note->sender ) )
boards.c:   if( !ch->desc )
boards.c:   switch ( ch->substate )
boards.c:            bug( "%s: Player not holding journal. (Player: %s)", __func__, ch->name );
boards.c:         ed = ( EXTRA_DESCR_DATA * )ch->dest_buf;
boards.c:         bug( "%s: Journal size greater than 50 pages! Resetting to 50 pages. (Player: %s)", __func__, ch->name );
boards.c:      ch->substate = SUB_JOURNAL_WRITE;
boards.c:      ch->dest_buf = ed;
boards.c:            bug( "%s: Journal size greater than 50 pages! Resetting to 50 pages. (Player: %s)", __func__, ch->name );
boards.c:         bug( "%s: Journal size greater than 50 pages! Resetting to 50 pages. (Player: %s)", __func__, ch->name );
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->desc )
build.c:   if( ch->substate == SUB_RESTRICTED )
build.c:      bug( "%s", "NOT GOOD: start_editing: ch->substate == SUB_RESTRICTED" );
build.c:   if( ch->editor )
build.c:   ch->editor = edit;
build.c:   ch->desc->connected = CON_EDITING;
build.c:   if( !ch->editor )
build.c:   for( x = 0; x < ch->editor->numlines; x++ )
build.c:      mudstrlcpy( tmp, ch->editor->line[x], 100 );
build.c:   if( !ch->editor )
build.c:   for( x = 0; x < ch->editor->numlines; x++ )
build.c:      mudstrlcpy( tmp, ch->editor->line[x], 100 );
build.c:   DISPOSE( ch->editor );
build.c:   ch->editor = NULL;
build.c:   ch->dest_buf = NULL;
build.c:   ch->spare_ptr = NULL;
build.c:   ch->substate = SUB_NONE;
build.c:   if( !ch->desc )
build.c:   ch->desc->connected = CON_PLAYING;
build.c:      if( !IS_NPC( fch ) && get_trust( ch ) < get_trust( fch ) && IS_SET( fch->pcdata->flags, PCFLAG_DND ) )
build.c:         ch_printf( ch, "Sorry. %s does not wish to be disturbed.\r\n", fch->name );
build.c:         ch_printf( fch, "Your DND flag just foiled %s's goto command.\r\n", ch->name );
build.c:      if( get_trust( ch ) < LEVEL_CREATOR || vnum < 1 || IS_NPC( ch ) || !ch->pcdata->area )
build.c:         if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:      location = make_room( vnum, ch->pcdata->area );
build.c:      ch_printf( victim, "Your DND flag just foiled %s's goto command.\r\n", ch->name );
build.c:   in_room = ch->in_room;
build.c:   if( ch->fighting )
build.c:   if( !xIS_SET( ch->act, PLR_WIZINVIS ) )
build.c:           ( ch->pcdata
build.c:             && ch->pcdata->bamfout[0] != '\0' ) ? ch->pcdata->bamfout : ( char * )"The immortal disappears.", TO_ROOM );
build.c:   ch->regoto = ch->in_room->vnum;
build.c:   if( ch->mount )
build.c:      char_from_room( ch->mount );
build.c:      char_to_room( ch->mount, location );
build.c:   if( !xIS_SET( ch->act, PLR_WIZINVIS ) )
build.c:           ( ch->pcdata
build.c:             && ch->pcdata->bamfin[0] != '\0' ) ? ch->pcdata->bamfin : ( char * )"An immortal appears.", TO_ROOM );
build.c:   if( ch->in_room == in_room )
build.c:      fch_next = fch->next_in_room;
build.c:      if( fch->master == ch && IS_IMMORTAL( fch ) )
build.c:      else if( IS_NPC( fch ) && fch->master == ch )
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "%s", "do_mset: sub_mob_desc: NULL ch->dest_buf" );
build.c:            ch->substate = SUB_NONE;
build.c:         victim = ( CHAR_DATA * ) ch->dest_buf;
build.c:         ch->substate = ch->tempnum;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      victim = ( CHAR_DATA * ) ch->dest_buf;
build.c:         if( ch->dest_buf )
build.c:            RelDestroy( relMSET_ON, ch, ch->dest_buf );
build.c:         ch->substate = SUB_NONE;
build.c:         ch->dest_buf = NULL;
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:            ch->pcdata->subprompt = NULL;
build.c:   if( arg1[0] == '\0' || ( arg2[0] == '\0' && ch->substate != SUB_REPEATCMD ) || !str_cmp( arg1, "?" ) )
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      ch->dest_buf = NULL;
build.c:      ch->dest_buf = NULL;
build.c:      ch->dest_buf = victim;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->dest_buf = victim;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->pcdata->subprompt = STRALLOC( buf );
build.c:      ch_printf( victim, "Your password has been changed by %s.\r\n", ch->name );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_MOB_DESC;
build.c:      ch->dest_buf = victim;
build.c:            else if( value == ACT_PROTOTYPE && ch->level < sysdata.level_modify_proto )
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_mset;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "%s: sub_obj_extra: NULL ch->dest_buf", __func__ );
build.c:            ch->substate = SUB_NONE;
build.c:         ed = ( EXTRA_DESCR_DATA * ) ch->dest_buf;
build.c:         tmpobj = ( OBJ_DATA * ) ch->spare_ptr;
build.c:         ch->dest_buf = tmpobj;
build.c:         ch->substate = ch->tempnum;
build.c:         if( !ch->dest_buf )
build.c:            bug( "%s: sub_obj_long: NULL ch->dest_buf", __func__ );
build.c:            ch->substate = SUB_NONE;
build.c:         obj = ( OBJ_DATA * ) ch->dest_buf;
build.c:         tmpobj = ( OBJ_DATA * ) ch->spare_ptr;
build.c:         ch->substate = ch->tempnum;
build.c:         ch->dest_buf = tmpobj;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      obj = ( OBJ_DATA * ) ch->dest_buf;
build.c:         if( ch->dest_buf )
build.c:            RelDestroy( relOSET_ON, ch, ch->dest_buf );
build.c:         ch->substate = SUB_NONE;
build.c:         ch->dest_buf = NULL;
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:            ch->pcdata->subprompt = NULL;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      ch->dest_buf = obj;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->dest_buf = obj;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->pcdata->subprompt = STRALLOC( buf );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:         ch->spare_ptr = obj;
build.c:         ch->spare_ptr = NULL;
build.c:      ch->substate = SUB_OBJ_LONG;
build.c:      ch->dest_buf = obj;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:         ch->spare_ptr = obj;
build.c:         ch->spare_ptr = NULL;
build.c:      ch->substate = SUB_OBJ_EXTRA;
build.c:      ch->dest_buf = ed;
build.c:                && get_trust( ch ) < LEVEL_GREATER && !is_name( "protoflag", ch->pcdata->bestowments ) )
build.c:            for( vch = first_char; vch; vch = vch->next )
build.c:               for( eq = vch->first_carrying; eq; eq = eq->next_content )
build.c:                  for( vch = first_char; vch; vch = vch->next )
build.c:                     for( eq = vch->first_carrying; eq; eq = eq->next_content )
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_oset;
build.c:   if( !ch->pcdata->area )
build.c:   ch_location = ch->in_room;
build.c:      pArea = ch->pcdata->area;
build.c:      location->area = ch->pcdata->area;
build.c:   ch_location = ch->in_room;
build.c:   pArea = ch->pcdata->area;
build.c:         location->area = ch->pcdata->area;
build.c:      for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
build.c:               for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
build.c:               for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   original = ch->in_room;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         location = ( ROOM_INDEX_DATA * ) ch->dest_buf;
build.c:            bug( "%s", "redit: sub_room_desc: NULL ch->dest_buf" );
build.c:            location = ch->in_room;
build.c:         ch->substate = ch->tempnum;
build.c:         ed = ( EXTRA_DESCR_DATA * ) ch->dest_buf;
build.c:            bug( "%s", "redit: sub_room_extra: NULL ch->dest_buf" );
build.c:         ch->substate = ch->tempnum;
build.c:   location = ch->in_room;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:            ch->pcdata->subprompt = NULL;
build.c:         ch->substate = SUB_NONE;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->pcdata->subprompt = STRALLOC( "<&CRedit &W#%r&w> %i" );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_ROOM_DESC;
build.c:      ch->dest_buf = location;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_ROOM_EXTRA;
build.c:      ch->dest_buf = ed;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_redit;
build.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   char_to_room( mob, ch->in_room );
build.c:   if( ( d = ch->desc ) == NULL )
build.c:   if( ch->substate <= SUB_PAUSE )
build.c:      bug( "%s: illegal ch->substate (%d)", __func__, ch->substate );
build.c:   if( !ch->editor )
build.c:   edit = ch->editor;
build.c:         int substate = ch->substate;
build.c:         last_cmd = ch->last_cmd;
build.c:         ch->substate = SUB_RESTRICTED;
build.c:         ch->substate = substate;
build.c:         ch->last_cmd = last_cmd;
build.c:         if( !ch->last_cmd )
build.c:         ( *ch->last_cmd ) ( ch, "" );
build.c:      if( !ch->last_cmd )
build.c:      ( *ch->last_cmd ) ( ch, "" );
build.c:   if( get_trust( ch ) > LEVEL_IMMORTAL && ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
build.c:      tarea = ch->pcdata->area;
build.c:      snprintf( taf, 1024, "%s.are", capitalize( ch->name ) );
build.c:         log_printf_plus( LOG_NORMAL, ch->level, "Creating area entry for %s", ch->name );
build.c:         snprintf( buf, MAX_STRING_LENGTH, "{PROTO} %s's area in progress", ch->name );
build.c:         snprintf( buf2, MAX_STRING_LENGTH, "%s", ch->name );
build.c:         log_printf_plus( LOG_NORMAL, ch->level, "Updating area entry for %s", ch->name );
build.c:      tarea->low_r_vnum = ch->pcdata->r_range_lo;
build.c:      tarea->low_o_vnum = ch->pcdata->o_range_lo;
build.c:      tarea->low_m_vnum = ch->pcdata->m_range_lo;
build.c:      tarea->hi_r_vnum = ch->pcdata->r_range_hi;
build.c:      tarea->hi_o_vnum = ch->pcdata->o_range_hi;
build.c:      tarea->hi_m_vnum = ch->pcdata->m_range_hi;
build.c:      ch->pcdata->area = tarea;
build.c:      ch->pcdata->area = NULL;
build.c:      if( !ch->pcdata->area )
build.c:       || ( is_name( buf, ch->pcdata->bestowments )
build.c:       || ( ch->pcdata->council && is_name( buf, ch->pcdata->council->powers ) ) )
build.c:                || is_name( tmp->filename, ch->pcdata->bestowments )
build.c:                || ( ch->pcdata->council
build.c:                     && ( is_name( buf, ch->pcdata->council->powers )
build.c:                          || is_name( "aassign", ch->pcdata->council->powers ) ) ) )
build.c:   ch->pcdata->area = tarea;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata || ( argument[0] == '\0' && !ch->pcdata->area ) )
build.c:      tarea = ch->pcdata->area;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata || ( argument[0] == '\0' && !ch->pcdata->area ) )
build.c:      tarea = ch->pcdata->area;
build.c:         tarea = ch->in_room->area;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:   tarea = ch->pcdata->area;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:   tarea = ch->pcdata->area;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:   tarea = ch->pcdata->area;
build.c:   ch->substate = SUB_MPROG_EDIT;
build.c:   ch->dest_buf = mprg;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "%s", "do_mpedit: sub_mprog_edit: NULL ch->dest_buf" );
build.c:            ch->substate = SUB_NONE;
build.c:         mprog = ( MPROG_DATA * ) ch->dest_buf;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "%s", "do_opedit: sub_oprog_edit: NULL ch->dest_buf" );
build.c:            ch->substate = SUB_NONE;
build.c:         mprog = ( MPROG_DATA * ) ch->dest_buf;
build.c:   ch->substate = SUB_MPROG_EDIT;
build.c:   ch->dest_buf = mprg;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "%s", "do_opedit: sub_oprog_edit: NULL ch->dest_buf" );
build.c:            ch->substate = SUB_NONE;
build.c:         mprog = ( MPROG_DATA * ) ch->dest_buf;
build.c:   if( !can_rmodify( ch, ch->in_room ) )
build.c:   mprog = ch->in_room->mudprogs;
build.c:            xCLEAR_BITS( ch->in_room->progtypes );
build.c:               xSET_BIT( ch->in_room->progtypes, mprg->type );
build.c:         mprg_next = ch->in_room->mudprogs;
build.c:         ch->in_room->mudprogs = mprg_next->next;
build.c:            xREMOVE_BIT( ch->in_room->progtypes, mptype );
build.c:         xSET_BIT( ch->in_room->progtypes, mptype );
build.c:         ch->in_room->mudprogs = mprg;
build.c:            xSET_BIT( ch->in_room->progtypes, mptype );
build.c:         ch->in_room->mudprogs = mprg;
build.c:      xSET_BIT( ch->in_room->progtypes, mptype );
build.c:   if( ch->substate == SUB_RESTRICTED )
build.c:   if( ch->substate == SUB_RESTRICTED )
build.c:       && ( obj->vnum < ch->pcdata->area->low_o_vnum || obj->vnum > ch->pcdata->area->hi_o_vnum ) )
build.c:   if( ch->substate == SUB_RESTRICTED )
build.c:       && ( mob->vnum < ch->pcdata->area->low_m_vnum || mob->vnum > ch->pcdata->area->hi_m_vnum ) )
build.c:   if( !ch->desc )
build.c:   if( !ch->desc )
build.c:   if( !ch->desc )
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:   tarea = ch->pcdata->area;
calendar.c:   ch->pcdata->timezone = i;
calendar.c:   ch_printf( ch, "&wYour local time        :  &W %s&D\r\n", c_time( current_time, ch->pcdata->timezone ) );
calendar.c:      if( day == ch->pcdata->day + 1 && time_info.month == ch->pcdata->month )
chess.c:   if( IS_WHITE( board->board[x][y] ) && !str_cmp( board->player1, ch->name ) )
chess.c:   if( IS_BLACK( board->board[x][y] ) && ( !str_cmp( board->player2, ch->name ) || !ch ) )
chess.c:         ch->pcdata->game_board = NULL;
chess.c:         ch->pcdata->game_board = NULL;
chess.c:      if( ch->pcdata->game_board )
chess.c:      ch->pcdata->game_board = board;
chess.c:      ch->pcdata->game_board->player1 = QUICKLINK( ch->name );
chess.c:      if( ch->pcdata->game_board )
chess.c:         board->player1 = QUICKLINK( ch->name );
chess.c:         ch->pcdata->game_board = board;
chess.c:         imc_send_chess( ch->name, arg2, "start" );
chess.c:      board = vch->pcdata->game_board;
chess.c:      board->player2 = QUICKLINK( ch->name );
chess.c:      ch->pcdata->game_board = board;
chess.c:      ch_printf( vch, "%s has joined your game.\r\n", ch->name );
chess.c:   if( !ch->pcdata->game_board )
chess.c:      free_game( ch->pcdata->game_board );
chess.c:      GAME_BOARD_DATA *board = ch->pcdata->game_board;
chess.c:      else if( !str_cmp( board->player1, ch->name ) )
chess.c:      else if( !str_cmp( board->player2, ch->name ) )
chess.c:      if( board->turn % 2 == 1 && !str_cmp( board->player1, ch->name ) )
chess.c:      else if( board->turn % 2 == 0 && !str_cmp( board->player2, ch->name ) )
chess.c:      send_to_char( print_big_board( ch, ch->pcdata->game_board ), ch );
chess.c:      if( !ch->pcdata->game_board->player1 || !ch->pcdata->game_board->player2 )
chess.c:      if( ch->pcdata->game_board->turn < 0 )
chess.c:      if( king_in_checkmate( ch->pcdata->game_board, BLACK_KING ) )
chess.c:      if( king_in_checkmate( ch->pcdata->game_board, WHITE_KING ) )
chess.c:      if( ch->pcdata->game_board->turn % 2 == 1 && !str_cmp( ch->pcdata->game_board->player1, ch->name ) )
chess.c:      if( ch->pcdata->game_board->turn % 2 == 0 && !str_cmp( ch->pcdata->game_board->player2, ch->name ) )
chess.c:      ret = is_valid_move( ch, ch->pcdata->game_board, x, y, dx, dy );
chess.c:         board = ch->pcdata->game_board;
chess.c:            if( ch->pcdata->game_board->type == TYPE_IMC )
chess.c:               imc_send_chess( ch->pcdata->game_board->player1, ch->pcdata->game_board->player2, arg );
chess.c:      if( !str_cmp( ch->name, ch->pcdata->game_board->player1 ) )
chess.c:         opp = get_char_world( ch, ch->pcdata->game_board->player2 );
chess.c:            mudstrlcpy( opp_name, ch->pcdata->game_board->player2, MAX_INPUT_LENGTH );
chess.c:         opp = get_char_world( ch, ch->pcdata->game_board->player1 );
chess.c:            mudstrlcpy( opp_name, ch->pcdata->game_board->player1, MAX_INPUT_LENGTH );
chess.c:         if( ch->pcdata->game_board->type == TYPE_LOCAL ) \
chess.c:         if( ch->pcdata->game_board->type == TYPE_IMC ) \
chess.c:            imc_send_tell( ch->name, opp_name, (arg), 1 ); \
chess.c:         if( ch->pcdata->game_board->type == TYPE_LOCAL ) \
chess.c:            snprintf( arg, MAX_INPUT_LENGTH, "%s has moved.\r\n", ch->name );
chess.c:            snprintf( arg, MAX_INPUT_LENGTH, "%s has taken one of your pieces!", ch->name );
chess.c:            snprintf( arg, MAX_INPUT_LENGTH, "%s has attempted a move that would result in checkmate.", ch->name );
chess.c:            snprintf( arg, MAX_INPUT_LENGTH, "%s has made a move that would result in a check.", ch->name );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   for( roster = ch->pcdata->clan->first_member; roster; roster = roster->next )
clans.c:      if( !str_cmp( ch->name, roster->name ) )
clans.c:         roster->level = ch->level;
clans.c:         roster->kills = ch->pcdata->mkills;
clans.c:         roster->deaths = ch->pcdata->mdeaths;
clans.c:         save_clan( ch->pcdata->clan );
clans.c:   add_roster( ch->pcdata->clan, ch->name, ch->Class, ch->level, ch->pcdata->mkills, ch->pcdata->mdeaths );
clans.c:   save_clan( ch->pcdata->clan );
clans.c:      templvl = ch->level;
clans.c:      ch->level = LEVEL_HERO;  /* make sure EQ doesn't get lost */
clans.c:      contents = ch->in_room->last_content;
clans.c:      ch->level = templvl;
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( str_cmp( ch->name, clan->leader )
clans.c:       && str_cmp( ch->name, clan->deity ) && ( clan->clan_type != CLAN_GUILD || str_cmp( ch->name, clan->number1 ) ) )
clans.c:      obj = obj_to_room( obj, ch->in_room );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( ( ch->pcdata && ch->pcdata->bestowments
clans.c:         && is_name( "caninduct", ch->pcdata->bestowments ) )
clans.c:       || !str_cmp( ch->name, clan->deity )
clans.c:       || !str_cmp( ch->name, clan->leader ) || !str_cmp( ch->name, clan->number1 ) || !str_cmp( ch->name, clan->number2 ) )
clans.c:      if( victim->level > ch->level )
clans.c:            ch_printf( victim, "%s instructs you in the ways of %s.\r\n", ch->name, skill_table[sn]->name );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->council )
clans.c:   council = ch->pcdata->council;
clans.c:   if( ( council->head == NULL || str_cmp( ch->name, council->head ) )
clans.c:       && ( council->head2 == NULL || str_cmp( ch->name, council->head2 ) ) && str_cmp( council->name, "mortal council" ) )
clans.c:   if( !str_cmp( ch->name, clan->deity ) )
clans.c:   if( !str_cmp( ch->name, clan->leader ) )
clans.c:   if( !str_cmp( ch->name, clan->number1 ) )
clans.c:   if( !str_cmp( ch->name, clan->number2 ) )
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( ( ch->pcdata && ch->pcdata->bestowments
clans.c:         && is_name( "canoutcast", ch->pcdata->bestowments ) )
clans.c:       || !str_cmp( ch->name, clan->deity )
clans.c:       || !str_cmp( ch->name, clan->leader ) || !str_cmp( ch->name, clan->number1 ) || !str_cmp( ch->name, clan->number2 ) )
clans.c:      if( ch->pcdata->clan->clan_type == CLAN_ORDER )
clans.c:      else if( ch->pcdata->clan->clan_type == CLAN_GUILD )
clans.c:   if( victim->pcdata->clan != ch->pcdata->clan )
clans.c:      if( ch->pcdata->clan->clan_type == CLAN_ORDER )
clans.c:      else if( ch->pcdata->clan->clan_type == CLAN_GUILD )
clans.c:   if( !str_cmp( victim->name, ch->pcdata->clan->number1 ) )
clans.c:      STRFREE( ch->pcdata->clan->number1 );
clans.c:      ch->pcdata->clan->number1 = STRALLOC( "" );
clans.c:   if( !str_cmp( victim->name, ch->pcdata->clan->number2 ) )
clans.c:      STRFREE( ch->pcdata->clan->number2 );
clans.c:      ch->pcdata->clan->number2 = STRALLOC( "" );
clans.c:   if( !str_cmp( victim->name, ch->pcdata->clan->deity ) )
clans.c:      STRFREE( ch->pcdata->clan->deity );
clans.c:      ch->pcdata->clan->deity = STRALLOC( "" );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->council )
clans.c:   council = ch->pcdata->council;
clans.c:   if( ( council->head == NULL || str_cmp( ch->name, council->head ) )
clans.c:       && ( council->head2 == NULL || str_cmp( ch->name, council->head2 ) ) && str_cmp( council->name, "mortal council" ) )
clans.c:   if( victim->pcdata->council != ch->pcdata->council )
clans.c:   if( council->head2 && !str_cmp( victim->name, ch->pcdata->council->head2 ) )
clans.c:      STRFREE( ch->pcdata->council->head2 );
clans.c:      ch->pcdata->council->head2 = NULL;
clans.c:   if( !str_cmp( ch->name, clan->deity )
clans.c:       || !str_cmp( ch->name, clan->leader )
clans.c:       || !str_cmp( ch->name, clan->number1 ) || !str_cmp( ch->name, clan->number2 ) || get_trust( ch ) >= LEVEL_GREATER )
clans.c:   if( !str_cmp( ch->name, order->deity )
clans.c:       || !str_cmp( ch->name, order->leader )
clans.c:       || !str_cmp( ch->name, order->number1 ) || !str_cmp( ch->name, order->number2 ) || get_trust( ch ) >= LEVEL_GREATER )
clans.c:   if( !str_cmp( ch->name, guild->deity )
clans.c:       || !str_cmp( ch->name, guild->leader )
clans.c:       || !str_cmp( ch->name, guild->number1 ) || !str_cmp( ch->name, guild->number2 ) || get_trust( ch ) >= LEVEL_GREATER )
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   if( ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD )
clans.c:      snprintf( filename, 256, "%s%s.defeats", CLAN_DIR, ch->pcdata->clan->name );
clans.c:      if( !str_cmp( ch->name, ch->pcdata->clan->leader ) && !str_cmp( argument, "clean" ) )
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   if( ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD )
clans.c:      snprintf( filename, 256, "%s%s.record", CLAN_DIR, ch->pcdata->clan->name );
clans.c:      if( !str_cmp( ch->name, ch->pcdata->clan->leader ) && !str_cmp( argument, "clean" ) )
clans.c:   if( IS_NPC( ch ) || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
clans.c:   if( ch->level - victim->level > 5 || victim->level - ch->level > 5 )
clans.c:   if( ( pexit = get_exit( ch->in_room, exit_dir ) ) == NULL )
clans.c:   if( ch->in_room->area != to_room->area && !in_hard_range( victim, to_room->area ) )
clans.c:   if( ch->Class == CLASS_WARRIOR )
clans.c:   if( ch->Class == CLASS_VAMPIRE )
clans.c:   if( ch->Class == CLASS_RANGER )
clans.c:   if( ch->Class == CLASS_DRUID )
clans.c:   if( ch->Class == CLASS_CLERIC )
clans.c:   if( ch->Class == CLASS_THIEF )
clans.c:   if( ch->Class == CLASS_MAGE )
clans.c:   if( ch->Class == CLASS_AUGURER )
clans.c:   if( ch->Class == CLASS_PALADIN )
clans.c:   if( ch->Class == CLASS_NEPHANDI )
clans.c:   if( ch->Class == CLASS_SAVAGE )
clans.c:   schance += ( ch->level - victim->level );
clans.c:   if( ch->race == RACE_ELF )
clans.c:   if( ch->race == RACE_DWARF )
clans.c:   if( ch->race == RACE_HALFLING )
clans.c:   if( ch->race == RACE_PIXIE )
clans.c:   if( ch->race == RACE_HALF_OGRE )
clans.c:   if( ch->race == RACE_HALF_ORC )
clans.c:   if( ch->race == RACE_HALF_TROLL )
clans.c:   if( ch->race == RACE_HALF_ELF )
clans.c:   if( ch->race == RACE_GITH )
clans.c:   if( ch->race == RACE_PIXIE )
clans.c:   if( ch->race == RACE_DROW )
clans.c:   if( ch->race == RACE_SEA_ELF )
clans.c:   if( ch->race == RACE_LIZARDMAN )
clans.c:   if( ch->race == RACE_GNOME )
clans.c:   move_char( victim, get_exit( ch->in_room, exit_dir ), 0 );
clans.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) && get_timer( ch, TIMER_SHOVEDRAG ) <= 0 )
clans.c:   if( !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) && IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) )
clans.c:   if( ch->level - victim->level > 5 || victim->level - ch->level > 5 )
clans.c:      if( IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
clans.c:   if( ( pexit = get_exit( ch->in_room, exit_dir ) ) == NULL )
clans.c:   if( ch->in_room->area != to_room->area && !in_hard_range( victim, to_room->area ) )
clans.c:   if( ch->Class == CLASS_WARRIOR )
clans.c:   if( ch->Class == CLASS_VAMPIRE )
clans.c:   if( ch->Class == CLASS_RANGER )
clans.c:   if( ch->Class == CLASS_DRUID )
clans.c:   if( ch->Class == CLASS_CLERIC )
clans.c:   if( ch->Class == CLASS_THIEF )
clans.c:   if( ch->Class == CLASS_MAGE )
clans.c:   schance += ( ch->level - victim->level );
clans.c:   if( ch->race == 1 )
clans.c:   if( ch->race == 2 )
clans.c:   if( ch->race == 3 )
clans.c:   if( ch->race == 4 )
clans.c:   if( ch->race == 6 )
clans.c:   if( ch->race == 7 )
clans.c:   if( ch->race == 8 )
clans.c:   if( ch->race == 9 )
clans.c:      move_char( victim, get_exit( ch->in_room, exit_dir ), 0 );
clans.c:      move_char( ch, get_exit( ch->in_room, exit_dir ), 0 );
color.c:         memcpy( &ch->colors, &default_set, sizeof( default_set ) );
color.c:               ch->colors[x] = fread_number( fp );
color.c:      log_printf( "%s: Attempting to reset NPC colors: %s", __func__, ch->short_descr );
color.c:         fprintf( fp, " %d", ch->colors[x] );
color.c:               ch->colors[x] = fread_number( fp );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, ANSI_RESET, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, ANSI_RESET, 0 );
color.c:         ch->colors[count] = default_set[count];
color.c:         ch->colors[ccount] = y;
color.c:      ch->colors[count] = y;
color.c:   if( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_ANSI ) )
color.c:   switch ( ch->colors[AType] )
color.c:         ansi = ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_ANSI ) );
color.c:                  if( ch && ch->desc )
color.c:                     mudstrlcat( dst, color_str( ch->desc->pagecolor, ch ), dstlen );
color.c:   if( !ch || !ch->desc )
color.c:   write_to_buffer( ch->desc, color_str( AType, ch ), 0 );
color.c:   if( !ch->desc )
color.c:      bug( "%s: NULL descriptor after WTB! CH: %s", __func__, ch->name ? ch->name : "Unknown?!?" );
color.c:   ch->desc->pagecolor = ch->colors[AType];
color.c:   if( !ch || !ch->desc )
color.c:   write_to_pager( ch->desc, color_str( AType, ch ), 0 );
color.c:   if( !ch->desc )
color.c:      bug( "%s: NULL descriptor after WTP! CH: %s", __func__, ch->name ? ch->name : "Unknown?!?" );
color.c:   ch->desc->pagecolor = ch->colors[AType];
color.c:   if( txt && ch->desc )
color.c:      send_to_desc_color( txt, ch->desc );
color.c:   if( txt && ch->desc )
color.c:      DESCRIPTOR_DATA *d = ch->desc;
color.c:      if( IS_NPC( ch ) || !IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) )
color.c:         if( ch->desc )
color.c:            send_to_desc_color( txt, ch->desc );
color.c:         if( ch->desc )
color.c:            write_to_pager( ch->desc, colorize( txt, ch->desc ), 0 );
comm.c:  for ( ch = first_char; ch; ch = ch->next )
comm.c:    log_printf( "%cPC: %-20s room: %d", IS_NPC(ch) ? 'N' : ' ', ch->name, ch->in_room->vnum );
comm.c:           ch ? ch->name : d->host, ( void * )dclose, ( void * )first_descriptor );
comm.c:            bug( "%s: %s desc:%p found, prev should be:%p, fixing.", __func__, ch ? ch->name : d->host, ( void * )dclose,
comm.c:         bug( "%s: %s desc:%p could not be found!.", __func__, ch ? ch->name : dclose->host, ( void * )dclose );
comm.c:           ch ? ch->name : d->host, ( void * )dclose, ( void * )last_descriptor );
comm.c:            bug( "%s: %s desc:%p found, next should be:%p, fixing.", __func__, ch ? ch->name : d->host, ( void * )dclose,
comm.c:         bug( "%s: %s desc:%p could not be found!.", __func__, ch ? ch->name : dclose->host, ( void * )dclose );
comm.c:      log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "Closing link to %s. (INRoom %d)", ch->pcdata->filename, ( ch->in_room ? ch->in_room->vnum : -1 ) );
comm.c:         if( ch->last_cmd )
comm.c:            ch->last_cmd( ch, "" );
comm.c:         ch->desc = NULL;
comm.c:      if( xIS_SET( ch->act, PLR_BLANK ) )
comm.c:      if( xIS_SET( ch->act, PLR_PROMPT ) )
comm.c:      if( ch && !IS_NPC( ch ) && xIS_SET( ch->act, PLR_ANSI ) )
comm.c:      if( xIS_SET( ch->act, PLR_TELNET_GA ) )
comm.c:   if( !IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO ) )
comm.c:      if( xIS_SET( ch->act, PLR_RIP ) )
comm.c:      else if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c:   if( xIS_SET( ch->act, PLR_DENY ) )
comm.c:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c:   if( check_playing( d, ch->pcdata->filename, TRUE ) )
comm.c:chk = check_reconnect( d, ch->pcdata->filename, TRUE );
comm.c:   mudstrlcpy( buf, ch->pcdata->filename, MAX_STRING_LENGTH );
comm.c:   if( ch->position == POS_FIGHTING
comm.c:       || ch->position == POS_EVASIVE
comm.c:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
comm.c:      ch->position = POS_STANDING;
comm.c:   log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s (%s) has connected.", ch->name, d->host );
comm.c:                   "\r\nPick a good password for %s: %s", ch->name, echo_off_str );
comm.c:   DISPOSE( ch->pcdata->pwd );
comm.c:   ch->pcdata->pwd = str_dup( pwdnew );
comm.c:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c:         ch->sex = SEX_MALE;
comm.c:         ch->sex = SEX_FEMALE;
comm.c:            ch->Class = iClass;
comm.c:   ch->pcdata->cpose = str_dup( " is here." );
comm.c:   ch->Class = 6;
comm.c:   ch->pcdata->customclass = str_dup( "Adventurer" );
comm.c:   ch->pcdata->str = 4;
comm.c:   ch->pcdata->intel = 3;
comm.c:   ch->pcdata->dex = 4;
comm.c:   ch->pcdata->lck = 2;
comm.c:   ch->pcdata->att = 10;
comm.c:   ch->pcdata->def = 15;
comm.c:   ch->pcdata->mdef = 5;
comm.c:   ch->pcdata->matt = 5;
comm.c:   ch->pcdata->strplus = 0;
comm.c:   ch->pcdata->intplus = 0;
comm.c:   ch->pcdata->dexplus = 0;
comm.c:   ch->pcdata->lckplus = 0;
comm.c:   ch->pcdata->attplus = 0;
comm.c:   ch->pcdata->defplus = 0;
comm.c:   ch->pcdata->mattplus = 0;
comm.c:   ch->pcdata->mdefplus = 0;
comm.c:   ch->pcdata->mlevel = 1;
comm.c:   ch->pcdata->deflevel = 1;
comm.c:   ch->pcdata->attlevel = 1;
comm.c:  ch->perm_con = 18;
comm.c:  ch->perm_cha = 18;
comm.c:  ch->perm_wis = 18;
comm.c:  ch->perm_str = 18;
comm.c:  ch->perm_int = 18;
comm.c:  ch->perm_lck = 18;
comm.c:  ch->perm_dex = 18;
comm.c:          && !IS_SET( race_table[iRace]->class_restriction, 1 << ch->Class )
comm.c:         ch->race = iRace;
comm.c:       || IS_SET( race_table[iRace]->class_restriction, 1 << ch->Class )
comm.c:	if (ch->race == 0)
comm.c:   ch->pcdata->hometown = str_dup( "Kroridge" );
comm.c:	if (ch->race == 1)
comm.c:   ch->pcdata->hometown = str_dup( "O'ran Thalore" );
comm.c:	if (ch->race == 2)
comm.c:   ch->pcdata->hometown = str_dup( "Kimlodar" );
comm.c:	if (ch->race == 3)
comm.c:   ch->pcdata->hometown = str_dup( "Shireton" );
comm.c:	if (ch->race == 9)
comm.c:   ch->pcdata->hometown = str_dup( "BeachCastle" );
comm.c:	if (ch->race == 10)
comm.c:   ch->pcdata->hometown = str_dup( "Calmarnock" );
comm.c:	if (ch->race == 11)
comm.c:   ch->pcdata->hometown = str_dup( "Tarnstead" );
comm.c:	if (ch->race == 15)
comm.c:   ch->pcdata->hometown = str_dup( "Dhubrokh" );
comm.c:         xSET_BIT( ch->act, PLR_RIP );
comm.c:         xSET_BIT( ch->act, PLR_ANSI );
comm.c:         xSET_BIT( ch->act, PLR_ANSI );
comm.c:   snprintf( log_buf, MAX_STRING_LENGTH, "%s@%s new %s %s.", ch->name, d->host,
comm.c:             race_table[ch->race]->race_name, class_table[ch->Class]->who_name );
comm.c:   ch->level = 0;
comm.c:   ch->position = POS_STANDING;
comm.c:   if( chk_watch( get_trust( ch ), ch->name, d->host ) ) /*  --Gorog */
comm.c:      SET_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c:      REMOVE_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c:   if( xIS_SET( ch->act, PLR_RIP ) )
comm.c:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c:   if( ch->level == LEVEL_AVATAR )
comm.c:   if( ch->level < LEVEL_AVATAR && ch->level > 0 )
comm.c:   if( ch->level == 0 )
comm.c:   if( ch->level == 0 )
comm.c:      ch->pcdata->clan = NULL;
comm.c:      switch ( class_table[ch->Class]->attr_prime )
comm.c:            ch->perm_str = 16;
comm.c:            ch->perm_int = 16;
comm.c:            ch->perm_wis = 16;
comm.c:            ch->perm_dex = 16;
comm.c:            ch->perm_con = 16;
comm.c:            ch->perm_cha = 16;
comm.c:            ch->perm_lck = 16;
comm.c:      ch->perm_str += race_table[ch->race]->str_plus;
comm.c:      ch->perm_int += race_table[ch->race]->int_plus;
comm.c:      ch->perm_wis += race_table[ch->race]->wis_plus;
comm.c:      ch->perm_dex += race_table[ch->race]->dex_plus;
comm.c:      ch->perm_con += race_table[ch->race]->con_plus;
comm.c:      ch->perm_cha += race_table[ch->race]->cha_plus;
comm.c:      ch->affected_by = race_table[ch->race]->affected;
comm.c:      ch->perm_lck += race_table[ch->race]->lck_plus;
comm.c:      ch->armor += race_table[ch->race]->ac_plus;
comm.c:      ch->alignment += race_table[ch->race]->alignment;
comm.c:      ch->attacks = race_table[ch->race]->attacks;
comm.c:      ch->defenses = race_table[ch->race]->defenses;
comm.c:      ch->saving_poison_death = race_table[ch->race]->saving_poison_death;
comm.c:      ch->saving_wand = race_table[ch->race]->saving_wand;
comm.c:      ch->saving_para_petri = race_table[ch->race]->saving_para_petri;
comm.c:      ch->saving_breath = race_table[ch->race]->saving_breath;
comm.c:      ch->saving_spell_staff = race_table[ch->race]->saving_spell_staff;
comm.c:      ch->height =
comm.c:         number_range( ( int )( race_table[ch->race]->height * .9 ), ( int )( race_table[ch->race]->height * 1.1 ) );
comm.c:      ch->weight =
comm.c:         number_range( ( int )( race_table[ch->race]->weight * .9 ), ( int )( race_table[ch->race]->weight * 1.1 ) );
comm.c:      if( ch->Class == CLASS_PALADIN )
comm.c:         ch->alignment = 1000;
comm.c:         ch->pcdata->learned[iLang] = 100;
comm.c:      if( race_table[ch->race] )
comm.c:            if( IS_SET( race_table[ch->race]->language, 1 << iLang ) )
comm.c:                  ch->pcdata->learned[uLang] = 100;
comm.c:       * ch->resist           += race_table[ch->race]->resist;    drats
comm.c:       * ch->susceptible     += race_table[ch->race]->suscept;    drats
comm.c:      ch->level = 1;
comm.c:      ch->exp = 0;
comm.c:      ch->max_hit += race_table[ch->race]->hit;
comm.c:      ch->max_mana += race_table[ch->race]->mana;
comm.c:      ch->hit = UMAX( 1, ch->max_hit );
comm.c:      ch->mana = UMAX( 1, ch->max_mana );
comm.c:      ch->move = ch->max_move;
comm.c:      ch->gold = 0;
comm.c:      ch->pcdata->day = time_info.day;
comm.c:      ch->pcdata->month = time_info.month;
comm.c:      ch->pcdata->year = time_info.year - 17;
comm.c:      ch->pcdata->age = 17;
comm.c:      ch->pcdata->age_bonus = 0;
comm.c:      snprintf( buf, MAX_STRING_LENGTH, "the %s", title_table[ch->Class][ch->level][ch->sex == SEX_FEMALE ? 1 : 0] );
comm.c:      xSET_BIT( ch->act, PLR_AUTOGOLD );
comm.c:      xSET_BIT( ch->act, PLR_AUTOEXIT );
comm.c:         ch->pcdata->auth_state = 0;
comm.c:         SET_BIT( ch->pcdata->flags, PCFLAG_UNAUTHED );
comm.c:   else if( !IS_IMMORTAL( ch ) && ch->pcdata->release_date > 0 && ch->pcdata->release_date > current_time )
comm.c:      if( ch->in_room->vnum == 6 || ch->in_room->vnum == 8 || ch->in_room->vnum == 1206 )
comm.c:         char_to_room( ch, ch->in_room );
comm.c:   else if( ch->in_room && ( IS_IMMORTAL( ch ) || !xIS_SET( ch->in_room->room_flags, ROOM_PROTOTYPE ) ) )
comm.c:      char_to_room( ch, ch->in_room );
comm.c:   if( ch->pcdata->pet )
comm.c:      act( AT_ACTION, "$n returns to $s master from the Void.", ch->pcdata->pet, NULL, ch, TO_NOTVICT );
comm.c:      act( AT_ACTION, "$N returns with you to the realms.", ch, NULL, ch->pcdata->pet, TO_CHAR );
comm.c:   if( !ch->was_in_room && ch->in_room == get_room_index( ROOM_VNUM_TEMPLE ) )
comm.c:      ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c:   else if( ch->was_in_room == get_room_index( ROOM_VNUM_TEMPLE ) )
comm.c:      ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c:   else if( !ch->was_in_room )
comm.c:      ch->was_in_room = ch->in_room;
comm.c:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c:      log_printf( "Player: %s has deleted.", capitalize( ch->name ) );
comm.c:      do_destroy( ch, ch->name );
comm.c:   for( ch = first_char; ch; ch = ch->next )
comm.c:      if( !IS_NPC( ch ) && ( !fConn || !ch->desc ) && ch->pcdata->filename && !str_cmp( name, ch->pcdata->filename ) )
comm.c:         if( fConn && ch->switched )
comm.c:            d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c:            ch->desc = d;
comm.c:            ch->timer = 0;
comm.c:               ch->pcdata->recent_site = STRALLOC( d->host );
comm.c:            log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s (%s) reconnected.", ch->name, d->host );
comm.c:         if( !ch->name || ( cstate != CON_PLAYING && cstate != CON_EDITING && cstate != CON_DELETE ) )
comm.c:            log_printf_plus( LOG_COMM, sysdata.log_level, "%s already connected.", ch->pcdata->filename );
comm.c:         ch->desc = d;
comm.c:         ch->timer = 0;
comm.c:         if( ch->switched )
comm.c:            do_return( ch->switched, "" );
comm.c:         ch->switched = NULL;
comm.c:            ch->pcdata->recent_site = STRALLOC( d->host );
comm.c:         log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s@%s reconnected, kicking off old link.",
comm.c:                          ch->pcdata->filename, d->host );
comm.c:   if( !ch || !ch->desc || ch->desc->connected != CON_PLAYING || !IS_IDLE( ch ) )
comm.c:   ch->timer = 0;
comm.c:   was_in_room = ch->was_in_room;
comm.c:   ch->was_in_room = ch->in_room;
comm.c:    * ch->was_in_room  = NULL;
comm.c:   REMOVE_BIT( ch->pcdata->flags, PCFLAG_IDLE );
comm.c:#define NAME(ch)        ( IS_NPC(ch) ? ch->short_descr : ch->name )
comm.c:   if( ch->morph && ch->morph->morph && ch->morph->morph->short_desc != NULL )
comm.c:      return ch->morph->morph->short_desc;
comm.c:               if( ch->sex > 2 || ch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c:                   !can_see( to, ch ) ? "It" : capitalize( he_she[URANGE( 0, ch->sex, 2 )] ) :
comm.c:                   !can_see( to, ch ) ? "it" : he_she[URANGE( 0, ch->sex, 2 )];
comm.c:               if( vch->sex > 2 || vch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c:                   !can_see( to, vch ) ? "It" : capitalize( he_she[URANGE( 0, vch->sex, 2 )] ) :
comm.c:                   !can_see( to, vch ) ? "it" : he_she[URANGE( 0, vch->sex, 2 )];
comm.c:               if( ch->sex > 2 || ch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c:                   !can_see( to, ch ) ? "It" : capitalize( him_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c:                   !can_see( to, ch ) ? "it" : him_her[URANGE( 0, ch->sex, 2 )];
comm.c:               if( vch->sex > 2 || vch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c:                   !can_see( to, vch ) ? "It" : capitalize( him_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c:                   !can_see( to, vch ) ? "it" : him_her[URANGE( 0, vch->sex, 2 )];
comm.c:               i = ( to == ch ) ? "your" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c:               if( ch->sex > 2 || ch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c:                   !can_see( to, ch ) ? "It" : capitalize( his_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c:                   !can_see( to, ch ) ? "it" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c:               if( vch->sex > 2 || vch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c:                   !can_see( to, vch ) ? "It" : capitalize( his_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c:                   !can_see( to, vch ) ? "it" : his_her[URANGE( 0, vch->sex, 2 )];
comm.c:   if( !ch->in_room )
comm.c:      to = ch->in_room->first_person;
comm.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_SECRETIVE ) && type != TO_CHAR )
comm.c:         bug( "%s (%s)", ch->name, format );
comm.c:      if( !vch->in_room )
comm.c:         bug( "%s -> %s (%s)", ch->name, vch->name, format );
comm.c:         || ( !IS_NPC(ch) && (xIS_SET(ch->act, PLR_WIZINVIS)
comm.c:         && ( get_trust(to) < ( ch->pcdata ? ch->pcdata->wizinvis : 0 ) ) ) ) ) )
comm.c:   if( !NOT_AUTHED( ch ) || ch->pcdata->auth_state != 2 )
comm.c:   if( check_playing( ch->desc, argument, FALSE ) == BERR )
comm.c:   if( !str_cmp( ch->name, ucase_argument ) )
comm.c:   STRFREE( ch->name );
comm.c:   ch->name = STRALLOC( ucase_argument );
comm.c:   STRFREE( ch->pcdata->filename );
comm.c:   ch->pcdata->filename = STRALLOC( ucase_argument );
comm.c:   ch->pcdata->auth_state = 0;
comm.c:   if( ch->fighting != NULL )
comm.c:      ch_printf( ch, "Consider this carefuly %s, if you delete, you will not\r\nbe reinstated as an immortal!\r\n", ch->name );
comm.c:   write_to_buffer( ch->desc, (const char *)echo_off_str, 0 );
comm.c:   ch->desc->connected = CON_DELETE;
comm.c:   bool ansi = ( !IS_NPC( och ) && xIS_SET( och->act, PLR_ANSI ) );
comm.c:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_HELPSTART ) )
comm.c:   else if( !IS_NPC( ch ) && ch->substate != SUB_NONE && ch->pcdata->subprompt && ch->pcdata->subprompt[0] != '\0' )
comm.c:      prompt = ch->pcdata->subprompt;
comm.c:   else if( IS_NPC( ch ) || ( !ch->fighting && ( !ch->pcdata->prompt || !*ch->pcdata->prompt ) ) )
comm.c:   else if( ch->fighting )
comm.c:      if( !ch->pcdata->fprompt || !*ch->pcdata->fprompt )
comm.c:         prompt = ch->pcdata->fprompt;
comm.c:      prompt = ch->pcdata->prompt;
comm.c:                  if( ch->level >= 10 )
comm.c:                     pstat = ch->alignment;
comm.c:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c:                  pstat = ch->hit;
comm.c:                  pstat = ch->max_hit;
comm.c:                     pstat = ch->mana;
comm.c:                     pstat = ch->max_mana;
comm.c:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c:                     pstat = ch->pcdata->condition[COND_BLOODTHIRST];
comm.c:                     pstat = ch->level + 10;
comm.c:                  pstat = ch->move;
comm.c:                  pstat = ch->max_move;
comm.c:                  pstat = ch->gold;
comm.c:                     pstat = ch->in_room->vnum;
comm.c:                     snprintf( pbuf, MAX_STRING_LENGTH, "%s", ext_flag_string( &ch->in_room->room_flags, r_flags ) );
comm.c:                  if( xIS_SET( och->act, PLR_ROOMVNUM ) )
comm.c:                     snprintf( pbuf, MAX_STRING_LENGTH, "<#%d> ", ch->in_room->vnum );
comm.c:                     if( IS_SET( ch->pcdata->flags, PCFLAG_DND ) )
comm.c:                  pstat = ch->exp;
comm.c:                  pstat = exp_level( ch, ch->level + 1 ) - ch->exp;
comm.c:                  pstat = ch->carry_weight;
comm.c:                  if( ch->style == STYLE_BERSERK )
comm.c:                  else if( ch->style == STYLE_AGGRESSIVE )
comm.c:                  else if( ch->style == STYLE_DEFENSIVE )
comm.c:                  else if( ch->style == STYLE_EVASIVE )
comm.c:                  if( ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_WIZINVIS ) ) ||
comm.c:                      ( IS_NPC( ch ) && xIS_SET( ch->act, ACT_MOBINVIS ) ) )
comm.c:                               ( IS_NPC( ch ) ? ch->mobinvis : ch->pcdata->wizinvis ) );
comm.c:                  pstat = ( IS_NPC( ch ) ? ( xIS_SET( ch->act, ACT_MOBINVIS ) ? ch->mobinvis : 0 )
comm.c:                            : ( xIS_SET( ch->act, PLR_WIZINVIS ) ? ch->pcdata->wizinvis : 0 ) );
comm.c:   pclines = UMAX( ch->pcdata->pagerlen, 5 ) - 1;
comm.c:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.backup:  for ( ch = first_char; ch; ch = ch->next )
comm.c.backup:    log_printf( "%cPC: %-20s room: %d", IS_NPC(ch) ? 'N' : ' ', ch->name, ch->in_room->vnum );
comm.c.backup:           ch ? ch->name : d->host, ( void * )dclose, ( void * )first_descriptor );
comm.c.backup:            bug( "%s: %s desc:%p found, prev should be:%p, fixing.", __func__, ch ? ch->name : d->host, ( void * )dclose,
comm.c.backup:         bug( "%s: %s desc:%p could not be found!.", __func__, ch ? ch->name : dclose->host, ( void * )dclose );
comm.c.backup:           ch ? ch->name : d->host, ( void * )dclose, ( void * )last_descriptor );
comm.c.backup:            bug( "%s: %s desc:%p found, next should be:%p, fixing.", __func__, ch ? ch->name : d->host, ( void * )dclose,
comm.c.backup:         bug( "%s: %s desc:%p could not be found!.", __func__, ch ? ch->name : dclose->host, ( void * )dclose );
comm.c.backup:      log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "Closing link to %s. (INRoom %d)", ch->pcdata->filename, ( ch->in_room ? ch->in_room->vnum : -1 ) );
comm.c.backup:         if( ch->last_cmd )
comm.c.backup:            ch->last_cmd( ch, "" );
comm.c.backup:         ch->desc = NULL;
comm.c.backup:      if( xIS_SET( ch->act, PLR_BLANK ) )
comm.c.backup:      if( xIS_SET( ch->act, PLR_PROMPT ) )
comm.c.backup:      if( ch && !IS_NPC( ch ) && xIS_SET( ch->act, PLR_ANSI ) )
comm.c.backup:      if( xIS_SET( ch->act, PLR_TELNET_GA ) )
comm.c.backup:   if( !IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO ) )
comm.c.backup:      if( xIS_SET( ch->act, PLR_RIP ) )
comm.c.backup:      else if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.backup:   if( xIS_SET( ch->act, PLR_DENY ) )
comm.c.backup:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c.backup:   if( check_playing( d, ch->pcdata->filename, TRUE ) )
comm.c.backup:chk = check_reconnect( d, ch->pcdata->filename, TRUE );
comm.c.backup:   mudstrlcpy( buf, ch->pcdata->filename, MAX_STRING_LENGTH );
comm.c.backup:   if( ch->position == POS_FIGHTING
comm.c.backup:       || ch->position == POS_EVASIVE
comm.c.backup:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
comm.c.backup:      ch->position = POS_STANDING;
comm.c.backup:   log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s (%s) has connected.", ch->name, d->host );
comm.c.backup:                   "\r\nPick a good password for %s: %s", ch->name, echo_off_str );
comm.c.backup:   DISPOSE( ch->pcdata->pwd );
comm.c.backup:   ch->pcdata->pwd = str_dup( pwdnew );
comm.c.backup:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c.backup:         ch->sex = SEX_MALE;
comm.c.backup:         ch->sex = SEX_FEMALE;
comm.c.backup:            ch->Class = iClass;
comm.c.backup:   ch->Class = 6;
comm.c.backup:   ch->pcdata->customclass = str_dup( "Adventurer" );
comm.c.backup:          && !IS_SET( race_table[iRace]->class_restriction, 1 << ch->Class )
comm.c.backup:         ch->race = iRace;
comm.c.backup:       || IS_SET( race_table[iRace]->class_restriction, 1 << ch->Class )
comm.c.backup:         xSET_BIT( ch->act, PLR_RIP );
comm.c.backup:         xSET_BIT( ch->act, PLR_ANSI );
comm.c.backup:         xSET_BIT( ch->act, PLR_ANSI );
comm.c.backup:   snprintf( log_buf, MAX_STRING_LENGTH, "%s@%s new %s %s.", ch->name, d->host,
comm.c.backup:             race_table[ch->race]->race_name, class_table[ch->Class]->who_name );
comm.c.backup:   ch->level = 0;
comm.c.backup:   ch->position = POS_STANDING;
comm.c.backup:   if( chk_watch( get_trust( ch ), ch->name, d->host ) ) /*  --Gorog */
comm.c.backup:      SET_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c.backup:      REMOVE_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c.backup:   if( xIS_SET( ch->act, PLR_RIP ) )
comm.c.backup:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.backup:   if( ch->level == LEVEL_AVATAR )
comm.c.backup:   if( ch->level < LEVEL_AVATAR && ch->level > 0 )
comm.c.backup:   if( ch->level == 0 )
comm.c.backup:   if( ch->level == 0 )
comm.c.backup:      ch->pcdata->clan = NULL;
comm.c.backup:      switch ( class_table[ch->Class]->attr_prime )
comm.c.backup:            ch->perm_str = 16;
comm.c.backup:            ch->perm_int = 16;
comm.c.backup:            ch->perm_wis = 16;
comm.c.backup:            ch->perm_dex = 16;
comm.c.backup:            ch->perm_con = 16;
comm.c.backup:            ch->perm_cha = 16;
comm.c.backup:            ch->perm_lck = 16;
comm.c.backup:      ch->perm_str += race_table[ch->race]->str_plus;
comm.c.backup:      ch->perm_int += race_table[ch->race]->int_plus;
comm.c.backup:      ch->perm_wis += race_table[ch->race]->wis_plus;
comm.c.backup:      ch->perm_dex += race_table[ch->race]->dex_plus;
comm.c.backup:      ch->perm_con += race_table[ch->race]->con_plus;
comm.c.backup:      ch->perm_cha += race_table[ch->race]->cha_plus;
comm.c.backup:      ch->affected_by = race_table[ch->race]->affected;
comm.c.backup:      ch->perm_lck += race_table[ch->race]->lck_plus;
comm.c.backup:      ch->armor += race_table[ch->race]->ac_plus;
comm.c.backup:      ch->alignment += race_table[ch->race]->alignment;
comm.c.backup:      ch->attacks = race_table[ch->race]->attacks;
comm.c.backup:      ch->defenses = race_table[ch->race]->defenses;
comm.c.backup:      ch->saving_poison_death = race_table[ch->race]->saving_poison_death;
comm.c.backup:      ch->saving_wand = race_table[ch->race]->saving_wand;
comm.c.backup:      ch->saving_para_petri = race_table[ch->race]->saving_para_petri;
comm.c.backup:      ch->saving_breath = race_table[ch->race]->saving_breath;
comm.c.backup:      ch->saving_spell_staff = race_table[ch->race]->saving_spell_staff;
comm.c.backup:      ch->height =
comm.c.backup:         number_range( ( int )( race_table[ch->race]->height * .9 ), ( int )( race_table[ch->race]->height * 1.1 ) );
comm.c.backup:      ch->weight =
comm.c.backup:         number_range( ( int )( race_table[ch->race]->weight * .9 ), ( int )( race_table[ch->race]->weight * 1.1 ) );
comm.c.backup:      if( ch->Class == CLASS_PALADIN )
comm.c.backup:         ch->alignment = 1000;
comm.c.backup:         ch->pcdata->learned[iLang] = 100;
comm.c.backup:      if( race_table[ch->race] )
comm.c.backup:            if( IS_SET( race_table[ch->race]->language, 1 << iLang ) )
comm.c.backup:                  ch->pcdata->learned[uLang] = 100;
comm.c.backup:       * ch->resist           += race_table[ch->race]->resist;    drats
comm.c.backup:       * ch->susceptible     += race_table[ch->race]->suscept;    drats
comm.c.backup:      ch->level = 1;
comm.c.backup:      ch->exp = 0;
comm.c.backup:      ch->max_hit += race_table[ch->race]->hit;
comm.c.backup:      ch->max_mana += race_table[ch->race]->mana;
comm.c.backup:      ch->hit = UMAX( 1, ch->max_hit );
comm.c.backup:      ch->mana = UMAX( 1, ch->max_mana );
comm.c.backup:      ch->move = ch->max_move;
comm.c.backup:      ch->gold = 0;
comm.c.backup:      ch->pcdata->day = time_info.day;
comm.c.backup:      ch->pcdata->month = time_info.month;
comm.c.backup:      ch->pcdata->year = time_info.year - 17;
comm.c.backup:      ch->pcdata->age = 17;
comm.c.backup:      ch->pcdata->age_bonus = 0;
comm.c.backup:      snprintf( buf, MAX_STRING_LENGTH, "the %s", title_table[ch->Class][ch->level][ch->sex == SEX_FEMALE ? 1 : 0] );
comm.c.backup:      xSET_BIT( ch->act, PLR_AUTOGOLD );
comm.c.backup:      xSET_BIT( ch->act, PLR_AUTOEXIT );
comm.c.backup:         ch->pcdata->auth_state = 0;
comm.c.backup:         SET_BIT( ch->pcdata->flags, PCFLAG_UNAUTHED );
comm.c.backup:   else if( !IS_IMMORTAL( ch ) && ch->pcdata->release_date > 0 && ch->pcdata->release_date > current_time )
comm.c.backup:      if( ch->in_room->vnum == 6 || ch->in_room->vnum == 8 || ch->in_room->vnum == 1206 )
comm.c.backup:         char_to_room( ch, ch->in_room );
comm.c.backup:   else if( ch->in_room && ( IS_IMMORTAL( ch ) || !xIS_SET( ch->in_room->room_flags, ROOM_PROTOTYPE ) ) )
comm.c.backup:      char_to_room( ch, ch->in_room );
comm.c.backup:   if( ch->pcdata->pet )
comm.c.backup:      act( AT_ACTION, "$n returns to $s master from the Void.", ch->pcdata->pet, NULL, ch, TO_NOTVICT );
comm.c.backup:      act( AT_ACTION, "$N returns with you to the realms.", ch, NULL, ch->pcdata->pet, TO_CHAR );
comm.c.backup:   if( !ch->was_in_room && ch->in_room == get_room_index( ROOM_VNUM_TEMPLE ) )
comm.c.backup:      ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c.backup:   else if( ch->was_in_room == get_room_index( ROOM_VNUM_TEMPLE ) )
comm.c.backup:      ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c.backup:   else if( !ch->was_in_room )
comm.c.backup:      ch->was_in_room = ch->in_room;
comm.c.backup:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c.backup:      log_printf( "Player: %s has deleted.", capitalize( ch->name ) );
comm.c.backup:      do_destroy( ch, ch->name );
comm.c.backup:   for( ch = first_char; ch; ch = ch->next )
comm.c.backup:      if( !IS_NPC( ch ) && ( !fConn || !ch->desc ) && ch->pcdata->filename && !str_cmp( name, ch->pcdata->filename ) )
comm.c.backup:         if( fConn && ch->switched )
comm.c.backup:            d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c.backup:            ch->desc = d;
comm.c.backup:            ch->timer = 0;
comm.c.backup:               ch->pcdata->recent_site = STRALLOC( d->host );
comm.c.backup:            log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s (%s) reconnected.", ch->name, d->host );
comm.c.backup:         if( !ch->name || ( cstate != CON_PLAYING && cstate != CON_EDITING && cstate != CON_DELETE ) )
comm.c.backup:            log_printf_plus( LOG_COMM, sysdata.log_level, "%s already connected.", ch->pcdata->filename );
comm.c.backup:         ch->desc = d;
comm.c.backup:         ch->timer = 0;
comm.c.backup:         if( ch->switched )
comm.c.backup:            do_return( ch->switched, "" );
comm.c.backup:         ch->switched = NULL;
comm.c.backup:            ch->pcdata->recent_site = STRALLOC( d->host );
comm.c.backup:         log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s@%s reconnected, kicking off old link.",
comm.c.backup:                          ch->pcdata->filename, d->host );
comm.c.backup:   if( !ch || !ch->desc || ch->desc->connected != CON_PLAYING || !IS_IDLE( ch ) )
comm.c.backup:   ch->timer = 0;
comm.c.backup:   was_in_room = ch->was_in_room;
comm.c.backup:   ch->was_in_room = ch->in_room;
comm.c.backup:    * ch->was_in_room  = NULL;
comm.c.backup:   REMOVE_BIT( ch->pcdata->flags, PCFLAG_IDLE );
comm.c.backup:#define NAME(ch)        ( IS_NPC(ch) ? ch->short_descr : ch->name )
comm.c.backup:   if( ch->morph && ch->morph->morph && ch->morph->morph->short_desc != NULL )
comm.c.backup:      return ch->morph->morph->short_desc;
comm.c.backup:               if( ch->sex > 2 || ch->sex < 0 )
comm.c.backup:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c.backup:                   !can_see( to, ch ) ? "It" : capitalize( he_she[URANGE( 0, ch->sex, 2 )] ) :
comm.c.backup:                   !can_see( to, ch ) ? "it" : he_she[URANGE( 0, ch->sex, 2 )];
comm.c.backup:               if( vch->sex > 2 || vch->sex < 0 )
comm.c.backup:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c.backup:                   !can_see( to, vch ) ? "It" : capitalize( he_she[URANGE( 0, vch->sex, 2 )] ) :
comm.c.backup:                   !can_see( to, vch ) ? "it" : he_she[URANGE( 0, vch->sex, 2 )];
comm.c.backup:               if( ch->sex > 2 || ch->sex < 0 )
comm.c.backup:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c.backup:                   !can_see( to, ch ) ? "It" : capitalize( him_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c.backup:                   !can_see( to, ch ) ? "it" : him_her[URANGE( 0, ch->sex, 2 )];
comm.c.backup:               if( vch->sex > 2 || vch->sex < 0 )
comm.c.backup:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c.backup:                   !can_see( to, vch ) ? "It" : capitalize( him_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c.backup:                   !can_see( to, vch ) ? "it" : him_her[URANGE( 0, vch->sex, 2 )];
comm.c.backup:               i = ( to == ch ) ? "your" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c.backup:               if( ch->sex > 2 || ch->sex < 0 )
comm.c.backup:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c.backup:                   !can_see( to, ch ) ? "It" : capitalize( his_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c.backup:                   !can_see( to, ch ) ? "it" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c.backup:               if( vch->sex > 2 || vch->sex < 0 )
comm.c.backup:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c.backup:                   !can_see( to, vch ) ? "It" : capitalize( his_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c.backup:                   !can_see( to, vch ) ? "it" : his_her[URANGE( 0, vch->sex, 2 )];
comm.c.backup:   if( !ch->in_room )
comm.c.backup:      to = ch->in_room->first_person;
comm.c.backup:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_SECRETIVE ) && type != TO_CHAR )
comm.c.backup:         bug( "%s (%s)", ch->name, format );
comm.c.backup:      if( !vch->in_room )
comm.c.backup:         bug( "%s -> %s (%s)", ch->name, vch->name, format );
comm.c.backup:         || ( !IS_NPC(ch) && (xIS_SET(ch->act, PLR_WIZINVIS)
comm.c.backup:         && ( get_trust(to) < ( ch->pcdata ? ch->pcdata->wizinvis : 0 ) ) ) ) ) )
comm.c.backup:   if( !NOT_AUTHED( ch ) || ch->pcdata->auth_state != 2 )
comm.c.backup:   if( check_playing( ch->desc, argument, FALSE ) == BERR )
comm.c.backup:   if( !str_cmp( ch->name, ucase_argument ) )
comm.c.backup:   STRFREE( ch->name );
comm.c.backup:   ch->name = STRALLOC( ucase_argument );
comm.c.backup:   STRFREE( ch->pcdata->filename );
comm.c.backup:   ch->pcdata->filename = STRALLOC( ucase_argument );
comm.c.backup:   ch->pcdata->auth_state = 0;
comm.c.backup:   if( ch->fighting != NULL )
comm.c.backup:      ch_printf( ch, "Consider this carefuly %s, if you delete, you will not\r\nbe reinstated as an immortal!\r\n", ch->name );
comm.c.backup:   write_to_buffer( ch->desc, (const char *)echo_off_str, 0 );
comm.c.backup:   ch->desc->connected = CON_DELETE;
comm.c.backup:   bool ansi = ( !IS_NPC( och ) && xIS_SET( och->act, PLR_ANSI ) );
comm.c.backup:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_HELPSTART ) )
comm.c.backup:   else if( !IS_NPC( ch ) && ch->substate != SUB_NONE && ch->pcdata->subprompt && ch->pcdata->subprompt[0] != '\0' )
comm.c.backup:      prompt = ch->pcdata->subprompt;
comm.c.backup:   else if( IS_NPC( ch ) || ( !ch->fighting && ( !ch->pcdata->prompt || !*ch->pcdata->prompt ) ) )
comm.c.backup:   else if( ch->fighting )
comm.c.backup:      if( !ch->pcdata->fprompt || !*ch->pcdata->fprompt )
comm.c.backup:         prompt = ch->pcdata->fprompt;
comm.c.backup:      prompt = ch->pcdata->prompt;
comm.c.backup:                  if( ch->level >= 10 )
comm.c.backup:                     pstat = ch->alignment;
comm.c.backup:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.backup:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.backup:                  pstat = ch->hit;
comm.c.backup:                  pstat = ch->max_hit;
comm.c.backup:                     pstat = ch->mana;
comm.c.backup:                     pstat = ch->max_mana;
comm.c.backup:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.backup:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.backup:                     pstat = ch->pcdata->condition[COND_BLOODTHIRST];
comm.c.backup:                     pstat = ch->level + 10;
comm.c.backup:                  pstat = ch->move;
comm.c.backup:                  pstat = ch->max_move;
comm.c.backup:                  pstat = ch->gold;
comm.c.backup:                     pstat = ch->in_room->vnum;
comm.c.backup:                     snprintf( pbuf, MAX_STRING_LENGTH, "%s", ext_flag_string( &ch->in_room->room_flags, r_flags ) );
comm.c.backup:                  if( xIS_SET( och->act, PLR_ROOMVNUM ) )
comm.c.backup:                     snprintf( pbuf, MAX_STRING_LENGTH, "<#%d> ", ch->in_room->vnum );
comm.c.backup:                     if( IS_SET( ch->pcdata->flags, PCFLAG_DND ) )
comm.c.backup:                  pstat = ch->exp;
comm.c.backup:                  pstat = exp_level( ch, ch->level + 1 ) - ch->exp;
comm.c.backup:                  pstat = ch->carry_weight;
comm.c.backup:                  if( ch->style == STYLE_BERSERK )
comm.c.backup:                  else if( ch->style == STYLE_AGGRESSIVE )
comm.c.backup:                  else if( ch->style == STYLE_DEFENSIVE )
comm.c.backup:                  else if( ch->style == STYLE_EVASIVE )
comm.c.backup:                  if( ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_WIZINVIS ) ) ||
comm.c.backup:                      ( IS_NPC( ch ) && xIS_SET( ch->act, ACT_MOBINVIS ) ) )
comm.c.backup:                               ( IS_NPC( ch ) ? ch->mobinvis : ch->pcdata->wizinvis ) );
comm.c.backup:                  pstat = ( IS_NPC( ch ) ? ( xIS_SET( ch->act, ACT_MOBINVIS ) ? ch->mobinvis : 0 )
comm.c.backup:                            : ( xIS_SET( ch->act, PLR_WIZINVIS ) ? ch->pcdata->wizinvis : 0 ) );
comm.c.backup:   pclines = UMAX( ch->pcdata->pagerlen, 5 ) - 1;
comm.c.backup:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.backup:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.bak:  for ( ch = first_char; ch; ch = ch->next )
comm.c.bak:    log_printf( "%cPC: %-20s room: %d", IS_NPC(ch) ? 'N' : ' ', ch->name, ch->in_room->vnum );
comm.c.bak:           ch ? ch->name : d->host, ( void * )dclose, ( void * )first_descriptor );
comm.c.bak:            bug( "%s: %s desc:%p found, prev should be:%p, fixing.", __func__, ch ? ch->name : d->host, ( void * )dclose,
comm.c.bak:         bug( "%s: %s desc:%p could not be found!.", __func__, ch ? ch->name : dclose->host, ( void * )dclose );
comm.c.bak:           ch ? ch->name : d->host, ( void * )dclose, ( void * )last_descriptor );
comm.c.bak:            bug( "%s: %s desc:%p found, next should be:%p, fixing.", __func__, ch ? ch->name : d->host, ( void * )dclose,
comm.c.bak:         bug( "%s: %s desc:%p could not be found!.", __func__, ch ? ch->name : dclose->host, ( void * )dclose );
comm.c.bak:      log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "Closing link to %s. (INRoom %d)", ch->pcdata->filename, ( ch->in_room ? ch->in_room->vnum : -1 ) );
comm.c.bak:         if( ch->last_cmd )
comm.c.bak:            ch->last_cmd( ch, "" );
comm.c.bak:         ch->desc = NULL;
comm.c.bak:      if( xIS_SET( ch->act, PLR_BLANK ) )
comm.c.bak:      if( xIS_SET( ch->act, PLR_PROMPT ) )
comm.c.bak:      if( ch && !IS_NPC( ch ) && xIS_SET( ch->act, PLR_ANSI ) )
comm.c.bak:      if( xIS_SET( ch->act, PLR_TELNET_GA ) )
comm.c.bak:   if( !IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO ) )
comm.c.bak:      if( xIS_SET( ch->act, PLR_RIP ) )
comm.c.bak:      else if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.bak:   if( xIS_SET( ch->act, PLR_DENY ) )
comm.c.bak:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c.bak:   if( check_playing( d, ch->pcdata->filename, TRUE ) )
comm.c.bak:chk = check_reconnect( d, ch->pcdata->filename, TRUE );
comm.c.bak:   mudstrlcpy( buf, ch->pcdata->filename, MAX_STRING_LENGTH );
comm.c.bak:   if( ch->position == POS_FIGHTING
comm.c.bak:       || ch->position == POS_EVASIVE
comm.c.bak:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
comm.c.bak:      ch->position = POS_STANDING;
comm.c.bak:   log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s (%s) has connected.", ch->name, d->host );
comm.c.bak:                   "\r\nPick a good password for %s: %s", ch->name, echo_off_str );
comm.c.bak:   DISPOSE( ch->pcdata->pwd );
comm.c.bak:   ch->pcdata->pwd = str_dup( pwdnew );
comm.c.bak:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c.bak:         ch->sex = SEX_MALE;
comm.c.bak:         ch->sex = SEX_FEMALE;
comm.c.bak:            ch->Class = iClass;
comm.c.bak:   ch->Class = 6;
comm.c.bak:   ch->pcdata->customclass = str_dup( "Adventurer" );
comm.c.bak:          && !IS_SET( race_table[iRace]->class_restriction, 1 << ch->Class )
comm.c.bak:         ch->race = iRace;
comm.c.bak:       || IS_SET( race_table[iRace]->class_restriction, 1 << ch->Class )
comm.c.bak:        ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex, ch->perm_con, 
comm.c.bak:	  ch->perm_cha, ch->perm_lck );
comm.c.bak:         xSET_BIT( ch->act, PLR_RIP );
comm.c.bak:         xSET_BIT( ch->act, PLR_ANSI );
comm.c.bak:         xSET_BIT( ch->act, PLR_ANSI );
comm.c.bak:   snprintf( log_buf, MAX_STRING_LENGTH, "%s@%s new %s %s.", ch->name, d->host,
comm.c.bak:             race_table[ch->race]->race_name, class_table[ch->Class]->who_name );
comm.c.bak:   ch->level = 0;
comm.c.bak:   ch->position = POS_STANDING;
comm.c.bak:   if( chk_watch( get_trust( ch ), ch->name, d->host ) ) /*  --Gorog */
comm.c.bak:      SET_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c.bak:      REMOVE_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c.bak:   if( xIS_SET( ch->act, PLR_RIP ) )
comm.c.bak:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.bak:   if( ch->level == LEVEL_AVATAR )
comm.c.bak:   if( ch->level < LEVEL_AVATAR && ch->level > 0 )
comm.c.bak:   if( ch->level == 0 )
comm.c.bak:   if( ch->level == 0 )
comm.c.bak:      ch->pcdata->clan = NULL;
comm.c.bak:      switch ( class_table[ch->Class]->attr_prime )
comm.c.bak:            ch->perm_str = 16;
comm.c.bak:            ch->perm_int = 16;
comm.c.bak:            ch->perm_wis = 16;
comm.c.bak:            ch->perm_dex = 16;
comm.c.bak:            ch->perm_con = 16;
comm.c.bak:            ch->perm_cha = 16;
comm.c.bak:            ch->perm_lck = 16;
comm.c.bak:      ch->perm_str += race_table[ch->race]->str_plus;
comm.c.bak:      ch->perm_int += race_table[ch->race]->int_plus;
comm.c.bak:      ch->perm_wis += race_table[ch->race]->wis_plus;
comm.c.bak:      ch->perm_dex += race_table[ch->race]->dex_plus;
comm.c.bak:      ch->perm_con += race_table[ch->race]->con_plus;
comm.c.bak:      ch->perm_cha += race_table[ch->race]->cha_plus;
comm.c.bak:      ch->affected_by = race_table[ch->race]->affected;
comm.c.bak:      ch->perm_lck += race_table[ch->race]->lck_plus;
comm.c.bak:      ch->armor += race_table[ch->race]->ac_plus;
comm.c.bak:      ch->alignment += race_table[ch->race]->alignment;
comm.c.bak:      ch->attacks = race_table[ch->race]->attacks;
comm.c.bak:      ch->defenses = race_table[ch->race]->defenses;
comm.c.bak:      ch->saving_poison_death = race_table[ch->race]->saving_poison_death;
comm.c.bak:      ch->saving_wand = race_table[ch->race]->saving_wand;
comm.c.bak:      ch->saving_para_petri = race_table[ch->race]->saving_para_petri;
comm.c.bak:      ch->saving_breath = race_table[ch->race]->saving_breath;
comm.c.bak:      ch->saving_spell_staff = race_table[ch->race]->saving_spell_staff;
comm.c.bak:      ch->height =
comm.c.bak:         number_range( ( int )( race_table[ch->race]->height * .9 ), ( int )( race_table[ch->race]->height * 1.1 ) );
comm.c.bak:      ch->weight =
comm.c.bak:         number_range( ( int )( race_table[ch->race]->weight * .9 ), ( int )( race_table[ch->race]->weight * 1.1 ) );
comm.c.bak:      if( ch->Class == CLASS_PALADIN )
comm.c.bak:         ch->alignment = 1000;
comm.c.bak:         ch->pcdata->learned[iLang] = 100;
comm.c.bak:      if( race_table[ch->race] )
comm.c.bak:            if( IS_SET( race_table[ch->race]->language, 1 << iLang ) )
comm.c.bak:                  ch->pcdata->learned[uLang] = 100;
comm.c.bak:       * ch->resist           += race_table[ch->race]->resist;    drats
comm.c.bak:       * ch->susceptible     += race_table[ch->race]->suscept;    drats
comm.c.bak:      ch->level = 1;
comm.c.bak:      ch->exp = 0;
comm.c.bak:      ch->max_hit += race_table[ch->race]->hit;
comm.c.bak:      ch->max_mana += race_table[ch->race]->mana;
comm.c.bak:      ch->hit = UMAX( 1, ch->max_hit );
comm.c.bak:      ch->mana = UMAX( 1, ch->max_mana );
comm.c.bak:      ch->move = ch->max_move;
comm.c.bak:      ch->gold = 0;
comm.c.bak:      ch->pcdata->day = time_info.day;
comm.c.bak:      ch->pcdata->month = time_info.month;
comm.c.bak:      ch->pcdata->year = time_info.year - 17;
comm.c.bak:      ch->pcdata->age = 17;
comm.c.bak:      ch->pcdata->age_bonus = 0;
comm.c.bak:      snprintf( buf, MAX_STRING_LENGTH, "the %s", title_table[ch->Class][ch->level][ch->sex == SEX_FEMALE ? 1 : 0] );
comm.c.bak:      xSET_BIT( ch->act, PLR_AUTOGOLD );
comm.c.bak:      xSET_BIT( ch->act, PLR_AUTOEXIT );
comm.c.bak:         ch->pcdata->auth_state = 0;
comm.c.bak:         SET_BIT( ch->pcdata->flags, PCFLAG_UNAUTHED );
comm.c.bak:   else if( !IS_IMMORTAL( ch ) && ch->pcdata->release_date > 0 && ch->pcdata->release_date > current_time )
comm.c.bak:      if( ch->in_room->vnum == 6 || ch->in_room->vnum == 8 || ch->in_room->vnum == 1206 )
comm.c.bak:         char_to_room( ch, ch->in_room );
comm.c.bak:   else if( ch->in_room && ( IS_IMMORTAL( ch ) || !xIS_SET( ch->in_room->room_flags, ROOM_PROTOTYPE ) ) )
comm.c.bak:      char_to_room( ch, ch->in_room );
comm.c.bak:   if( ch->pcdata->pet )
comm.c.bak:      act( AT_ACTION, "$n returns to $s master from the Void.", ch->pcdata->pet, NULL, ch, TO_NOTVICT );
comm.c.bak:      act( AT_ACTION, "$N returns with you to the realms.", ch, NULL, ch->pcdata->pet, TO_CHAR );
comm.c.bak:   if( !ch->was_in_room && ch->in_room == get_room_index( ROOM_VNUM_TEMPLE ) )
comm.c.bak:      ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c.bak:   else if( ch->was_in_room == get_room_index( ROOM_VNUM_TEMPLE ) )
comm.c.bak:      ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c.bak:   else if( !ch->was_in_room )
comm.c.bak:      ch->was_in_room = ch->in_room;
comm.c.bak:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c.bak:      log_printf( "Player: %s has deleted.", capitalize( ch->name ) );
comm.c.bak:      do_destroy( ch, ch->name );
comm.c.bak:         ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex, ch->perm_con, 
comm.c.bak:	   ch->perm_cha, ch->perm_lck );
comm.c.bak:   for( ch = first_char; ch; ch = ch->next )
comm.c.bak:      if( !IS_NPC( ch ) && ( !fConn || !ch->desc ) && ch->pcdata->filename && !str_cmp( name, ch->pcdata->filename ) )
comm.c.bak:         if( fConn && ch->switched )
comm.c.bak:            d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c.bak:            ch->desc = d;
comm.c.bak:            ch->timer = 0;
comm.c.bak:               ch->pcdata->recent_site = STRALLOC( d->host );
comm.c.bak:            log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s (%s) reconnected.", ch->name, d->host );
comm.c.bak:         if( !ch->name || ( cstate != CON_PLAYING && cstate != CON_EDITING && cstate != CON_ROLL_STATS && cstate != CON_DELETE ) )
comm.c.bak:            log_printf_plus( LOG_COMM, sysdata.log_level, "%s already connected.", ch->pcdata->filename );
comm.c.bak:         ch->desc = d;
comm.c.bak:         ch->timer = 0;
comm.c.bak:         if( ch->switched )
comm.c.bak:            do_return( ch->switched, "" );
comm.c.bak:         ch->switched = NULL;
comm.c.bak:            ch->pcdata->recent_site = STRALLOC( d->host );
comm.c.bak:         log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s@%s reconnected, kicking off old link.",
comm.c.bak:                          ch->pcdata->filename, d->host );
comm.c.bak:   if( !ch || !ch->desc || ch->desc->connected != CON_PLAYING || !IS_IDLE( ch ) )
comm.c.bak:   ch->timer = 0;
comm.c.bak:   was_in_room = ch->was_in_room;
comm.c.bak:   ch->was_in_room = ch->in_room;
comm.c.bak:    * ch->was_in_room  = NULL;
comm.c.bak:   REMOVE_BIT( ch->pcdata->flags, PCFLAG_IDLE );
comm.c.bak:#define NAME(ch)        ( IS_NPC(ch) ? ch->short_descr : ch->name )
comm.c.bak:   if( ch->morph && ch->morph->morph && ch->morph->morph->short_desc != NULL )
comm.c.bak:      return ch->morph->morph->short_desc;
comm.c.bak:               if( ch->sex > 2 || ch->sex < 0 )
comm.c.bak:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c.bak:                   !can_see( to, ch ) ? "It" : capitalize( he_she[URANGE( 0, ch->sex, 2 )] ) :
comm.c.bak:                   !can_see( to, ch ) ? "it" : he_she[URANGE( 0, ch->sex, 2 )];
comm.c.bak:               if( vch->sex > 2 || vch->sex < 0 )
comm.c.bak:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c.bak:                   !can_see( to, vch ) ? "It" : capitalize( he_she[URANGE( 0, vch->sex, 2 )] ) :
comm.c.bak:                   !can_see( to, vch ) ? "it" : he_she[URANGE( 0, vch->sex, 2 )];
comm.c.bak:               if( ch->sex > 2 || ch->sex < 0 )
comm.c.bak:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c.bak:                   !can_see( to, ch ) ? "It" : capitalize( him_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c.bak:                   !can_see( to, ch ) ? "it" : him_her[URANGE( 0, ch->sex, 2 )];
comm.c.bak:               if( vch->sex > 2 || vch->sex < 0 )
comm.c.bak:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c.bak:                   !can_see( to, vch ) ? "It" : capitalize( him_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c.bak:                   !can_see( to, vch ) ? "it" : him_her[URANGE( 0, vch->sex, 2 )];
comm.c.bak:               i = ( to == ch ) ? "your" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c.bak:               if( ch->sex > 2 || ch->sex < 0 )
comm.c.bak:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c.bak:                   !can_see( to, ch ) ? "It" : capitalize( his_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c.bak:                   !can_see( to, ch ) ? "it" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c.bak:               if( vch->sex > 2 || vch->sex < 0 )
comm.c.bak:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c.bak:                   !can_see( to, vch ) ? "It" : capitalize( his_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c.bak:                   !can_see( to, vch ) ? "it" : his_her[URANGE( 0, vch->sex, 2 )];
comm.c.bak:   if( !ch->in_room )
comm.c.bak:      to = ch->in_room->first_person;
comm.c.bak:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_SECRETIVE ) && type != TO_CHAR )
comm.c.bak:         bug( "%s (%s)", ch->name, format );
comm.c.bak:      if( !vch->in_room )
comm.c.bak:         bug( "%s -> %s (%s)", ch->name, vch->name, format );
comm.c.bak:         || ( !IS_NPC(ch) && (xIS_SET(ch->act, PLR_WIZINVIS)
comm.c.bak:         && ( get_trust(to) < ( ch->pcdata ? ch->pcdata->wizinvis : 0 ) ) ) ) ) )
comm.c.bak:   if( !NOT_AUTHED( ch ) || ch->pcdata->auth_state != 2 )
comm.c.bak:   if( check_playing( ch->desc, argument, FALSE ) == BERR )
comm.c.bak:   if( !str_cmp( ch->name, ucase_argument ) )
comm.c.bak:   STRFREE( ch->name );
comm.c.bak:   ch->name = STRALLOC( ucase_argument );
comm.c.bak:   STRFREE( ch->pcdata->filename );
comm.c.bak:   ch->pcdata->filename = STRALLOC( ucase_argument );
comm.c.bak:   ch->pcdata->auth_state = 0;
comm.c.bak:   if( ch->fighting != NULL )
comm.c.bak:      ch_printf( ch, "Consider this carefuly %s, if you delete, you will not\r\nbe reinstated as an immortal!\r\n", ch->name );
comm.c.bak:   write_to_buffer( ch->desc, (const char *)echo_off_str, 0 );
comm.c.bak:   ch->desc->connected = CON_DELETE;
comm.c.bak:   bool ansi = ( !IS_NPC( och ) && xIS_SET( och->act, PLR_ANSI ) );
comm.c.bak:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_HELPSTART ) )
comm.c.bak:   else if( !IS_NPC( ch ) && ch->substate != SUB_NONE && ch->pcdata->subprompt && ch->pcdata->subprompt[0] != '\0' )
comm.c.bak:      prompt = ch->pcdata->subprompt;
comm.c.bak:   else if( IS_NPC( ch ) || ( !ch->fighting && ( !ch->pcdata->prompt || !*ch->pcdata->prompt ) ) )
comm.c.bak:   else if( ch->fighting )
comm.c.bak:      if( !ch->pcdata->fprompt || !*ch->pcdata->fprompt )
comm.c.bak:         prompt = ch->pcdata->fprompt;
comm.c.bak:      prompt = ch->pcdata->prompt;
comm.c.bak:                  if( ch->level >= 10 )
comm.c.bak:                     pstat = ch->alignment;
comm.c.bak:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.bak:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.bak:                  pstat = ch->hit;
comm.c.bak:                  pstat = ch->max_hit;
comm.c.bak:                     pstat = ch->mana;
comm.c.bak:                     pstat = ch->max_mana;
comm.c.bak:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.bak:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.bak:                     pstat = ch->pcdata->condition[COND_BLOODTHIRST];
comm.c.bak:                     pstat = ch->level + 10;
comm.c.bak:                  pstat = ch->move;
comm.c.bak:                  pstat = ch->max_move;
comm.c.bak:                  pstat = ch->gold;
comm.c.bak:                     pstat = ch->in_room->vnum;
comm.c.bak:                     snprintf( pbuf, MAX_STRING_LENGTH, "%s", ext_flag_string( &ch->in_room->room_flags, r_flags ) );
comm.c.bak:                  if( xIS_SET( och->act, PLR_ROOMVNUM ) )
comm.c.bak:                     snprintf( pbuf, MAX_STRING_LENGTH, "<#%d> ", ch->in_room->vnum );
comm.c.bak:                     if( IS_SET( ch->pcdata->flags, PCFLAG_DND ) )
comm.c.bak:                  pstat = ch->exp;
comm.c.bak:                  pstat = exp_level( ch, ch->level + 1 ) - ch->exp;
comm.c.bak:                  pstat = ch->carry_weight;
comm.c.bak:                  if( ch->style == STYLE_BERSERK )
comm.c.bak:                  else if( ch->style == STYLE_AGGRESSIVE )
comm.c.bak:                  else if( ch->style == STYLE_DEFENSIVE )
comm.c.bak:                  else if( ch->style == STYLE_EVASIVE )
comm.c.bak:                  if( ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_WIZINVIS ) ) ||
comm.c.bak:                      ( IS_NPC( ch ) && xIS_SET( ch->act, ACT_MOBINVIS ) ) )
comm.c.bak:                               ( IS_NPC( ch ) ? ch->mobinvis : ch->pcdata->wizinvis ) );
comm.c.bak:                  pstat = ( IS_NPC( ch ) ? ( xIS_SET( ch->act, ACT_MOBINVIS ) ? ch->mobinvis : 0 )
comm.c.bak:                            : ( xIS_SET( ch->act, PLR_WIZINVIS ) ? ch->pcdata->wizinvis : 0 ) );
comm.c.bak:   pclines = UMAX( ch->pcdata->pagerlen, 5 ) - 1;
comm.c.bak:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.bak:   if( xIS_SET( ch->act, PLR_ANSI ) )
comments.c:   if( !ch->desc )
comments.c:   if( ch->desc->connected == CON_EDITING )
comments.c:   switch ( ch->substate )
comments.c:         if( !ch->pnote )
comments.c:         if( ch->dest_buf != ch->pnote )
comments.c:            bug( "%s: sub_writing_note: ch->dest_buf != ch->pnote", __func__ );
comments.c:         STRFREE( ch->pnote->text );
comments.c:         ch->pnote->text = copy_buffer( ch );
comments.c:      ch->substate = SUB_WRITING_NOTE;
comments.c:      ch->dest_buf = ch->pnote;
comments.c:      start_editing( ch, ch->pnote->text );
comments.c:      STRFREE( ch->pnote->subject );
comments.c:      ch->pnote->subject = STRALLOC( argument );
comments.c:      STRFREE( ch->pnote->to_list );
comments.c:      ch->pnote->to_list = STRALLOC( argument );
comments.c:      if( ch->pnote )
comments.c:         STRFREE( ch->pnote->text );
comments.c:         STRFREE( ch->pnote->subject );
comments.c:         STRFREE( ch->pnote->to_list );
comments.c:         STRFREE( ch->pnote->date );
comments.c:         STRFREE( ch->pnote->sender );
comments.c:         DISPOSE( ch->pnote );
comments.c:      ch->pnote = NULL;
comments.c:      if( !ch->pnote )
comments.c:      ch_printf( ch, "%s: %s\r\nTo: %s\r\n", ch->pnote->sender, ch->pnote->subject, ch->pnote->to_list );
comments.c:      send_to_char( ch->pnote->text, ch );
comments.c:      if( !ch->pnote )
comments.c:      STRFREE( ch->pnote->date );
comments.c:      ch->pnote->date = STRALLOC( strtime );
comments.c:      pnote = ch->pnote;
comments.c:      ch->pnote = NULL;
comments.c:   if( !ch->comments )
comments.c:   for( pnote = ch->comments; pnote; pnote = pnote->next )
comments.c:      ch->comments = pnote;
db.c:         for( pch = first_char; pch; pch = pch->next )
db.c:            if( !IS_NPC( pch ) && IS_AWAKE( pch ) && pch->in_room && pch->in_room->area == pArea )
db.c:   ch->editor = NULL;
db.c:   ch->hunting = NULL;
db.c:   ch->fearing = NULL;
db.c:   ch->hating = NULL;
db.c:   ch->name = NULL;
db.c:   ch->short_descr = NULL;
db.c:   ch->long_descr = NULL;
db.c:   ch->description = NULL;
db.c:   ch->next = NULL;
db.c:   ch->prev = NULL;
db.c:   ch->reply = NULL;
db.c:   ch->retell = NULL;
db.c:   ch->variables = NULL;
db.c:   ch->first_carrying = NULL;
db.c:   ch->last_carrying = NULL;
db.c:   ch->next_in_room = NULL;
db.c:   ch->prev_in_room = NULL;
db.c:   ch->fighting = NULL;
db.c:   ch->switched = NULL;
db.c:   ch->first_affect = NULL;
db.c:   ch->last_affect = NULL;
db.c:   ch->prev_cmd = NULL; /* maps */
db.c:   ch->last_cmd = NULL;
db.c:   ch->dest_buf = NULL;
db.c:   ch->alloc_ptr = NULL;
db.c:   ch->spare_ptr = NULL;
db.c:   ch->mount = NULL;
db.c:   ch->morph = NULL;
db.c:   xCLEAR_BITS( ch->affected_by );
db.c:   ch->logon = current_time;
db.c:   ch->armor = 100;
db.c:   ch->position = POS_STANDING;
db.c:   ch->practice = 0;
db.c:   ch->hit = 20;
db.c:   ch->max_hit = 20;
db.c:   ch->mana = 100;
db.c:   ch->max_mana = 100;
db.c:   ch->move = 100;
db.c:   ch->max_move = 100;
db.c:   ch->height = 72;
db.c:   ch->weight = 180;
db.c:   ch->xflags = 0;
db.c:   ch->race = 0;
db.c:   ch->Class = 3;
db.c:   ch->speaking = LANG_COMMON;
db.c:   ch->speaks = LANG_COMMON;
db.c:   ch->barenumdie = 1;
db.c:   ch->baresizedie = 4;
db.c:   ch->substate = 0;
db.c:   ch->tempnum = 0;
db.c:   ch->perm_str = 13;
db.c:   ch->perm_dex = 13;
db.c:   ch->perm_int = 13;
db.c:   ch->perm_wis = 13;
db.c:   ch->perm_cha = 13;
db.c:   ch->perm_con = 13;
db.c:   ch->perm_lck = 13;
db.c:   ch->mod_str = 0;
db.c:   ch->mod_dex = 0;
db.c:   ch->mod_int = 0;
db.c:   ch->mod_wis = 0;
db.c:   ch->mod_cha = 0;
db.c:   ch->mod_con = 0;
db.c:   ch->mod_lck = 0;
db.c:   if( ch->desc )
db.c:   if( ch->morph )
db.c:      DISPOSE( ch->morph );
db.c:   while( ( obj = ch->last_carrying ) != NULL )
db.c:   while( ( paf = ch->last_affect ) != NULL )
db.c:   while( ( timer = ch->first_timer ) != NULL )
db.c:   if( ch->editor )
db.c:   STRFREE( ch->name );
db.c:   STRFREE( ch->short_descr );
db.c:   STRFREE( ch->long_descr );
db.c:   STRFREE( ch->description );
db.c:   STRFREE( ch->spec_funname );
db.c:   if( ch->pnote )
db.c:      free_note( ch->pnote );
db.c:   for( vd = ch->variables; vd; vd = vd_next )
db.c:   if( ch->pcdata )
db.c:      if( ch->pcdata->pet )
db.c:         extract_char( ch->pcdata->pet, TRUE );
db.c:         ch->pcdata->pet = NULL;
db.c:      for( temp = ch->pcdata->first_ignored; temp; temp = next )
db.c:         UNLINK( temp, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
db.c:      STRFREE( ch->pcdata->filename );
db.c:      STRFREE( ch->pcdata->deity_name );
db.c:      STRFREE( ch->pcdata->clan_name );
db.c:      STRFREE( ch->pcdata->council_name );
db.c:      if( ch->pcdata->recent_site )
db.c:         STRFREE( ch->pcdata->recent_site );
db.c:      if( ch->pcdata->prev_site )
db.c:         STRFREE( ch->pcdata->prev_site );
db.c:      DISPOSE( ch->pcdata->pwd );   /* no hash */
db.c:      DISPOSE( ch->pcdata->bamfin );   /* no hash */
db.c:      DISPOSE( ch->pcdata->bamfout );  /* no hash */
db.c:      DISPOSE( ch->pcdata->rank );
db.c:      STRFREE( ch->pcdata->title );
db.c:      STRFREE( ch->pcdata->bio );
db.c:      DISPOSE( ch->pcdata->bestowments ); /* no hash */
db.c:      DISPOSE( ch->pcdata->homepage ); /* no hash */
db.c:      STRFREE( ch->pcdata->authed_by );
db.c:      STRFREE( ch->pcdata->prompt );
db.c:      STRFREE( ch->pcdata->fprompt );
db.c:      if( ch->pcdata->helled_by )
db.c:         STRFREE( ch->pcdata->helled_by );
db.c:      if( ch->pcdata->subprompt )
db.c:         STRFREE( ch->pcdata->subprompt );
db.c:      if( ch->pcdata->tell_history )
db.c:            if( ch->pcdata->tell_history[i] )
db.c:               STRFREE( ch->pcdata->tell_history[i] );
db.c:         DISPOSE( ch->pcdata->tell_history );
db.c:      DISPOSE( ch->pcdata );
db.c:   for( mpact = ch->mpact; mpact; mpact = mpact_next )
db.c:   for( comments = ch->comments; comments; comments = comments_next )
db.c:      fprintf( fp, "[%5d] %s: %s\n", ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
db.c:   for( ch = first_char; ch; ch = ch->next )
db.c:      if( ch->was_in_room == room )
db.c:         ch->was_in_room = ch->in_room;
db.c:      if( ch->substate == SUB_ROOM_DESC && ch->dest_buf == room )
db.c:         ch->substate = SUB_NONE;
db.c:         ch->dest_buf = NULL;
db.c:      else if( ch->substate == SUB_ROOM_EXTRA && ch->dest_buf )
db.c:            if( ed == ch->dest_buf )
db.c:               ch->substate = SUB_NONE;
db.c:               ch->dest_buf = NULL;
db.c:      ch_next = ch->next;
db.c:      if( ch->pIndexData == mob )
db.c:      else if( ch->substate == SUB_MPROG_EDIT && ch->dest_buf )
db.c:            if( mp == ch->dest_buf )
db.c:               ch->dest_buf = NULL;
db.c:               ch->substate = SUB_NONE;
db.c:      pwatch->imm_level = number;
db.c:      pwatch->imm_name = fread_string_nohash( fp );
db.c:      pwatch->target_name = fread_string_nohash( fp );
db.c:      if( strlen( pwatch->target_name ) < 2 )
db.c:         DISPOSE( pwatch->target_name );
db.c:      pwatch->player_site = fread_string_nohash( fp );
db.c:      if( strlen( pwatch->player_site ) < 2 )
db.c:         DISPOSE( pwatch->player_site );
db.c:      if( pwatch->target_name )
db.c:         for( cmd = command_hash[( int )pwatch->target_name[0]]; cmd; cmd = cmd->next )
db.c:            if( !str_cmp( pwatch->target_name, cmd->name ) )
db.c:      if( !str_cmp( lmsg->name, ch->name ) )
db.c:            bug( "%s: Error: Unknown login msg: %d for %s.", __func__, lmsg->type, ch->name );
deity.c:   switch ( ch->substate )
deity.c:         deity = ( DEITY_DATA * ) ch->dest_buf;
deity.c:         ch->substate = ch->tempnum;
deity.c:      for( vch = first_char; vch; vch = vch->next )
deity.c:            if( vch->pcdata->deity == deity )
deity.c:               snprintf( buf, MAX_STRING_LENGTH, "&R\r\nYour deity, %s, has met its demise!\r\n", vch->pcdata->deity_name );
deity.c:               if( !vch->desc )
deity.c:                  add_loginmsg( vch->name, 18, buf );
deity.c:               xREMOVE_BITS( vch->affected_by, vch->pcdata->deity->affected );
deity.c:               REMOVE_BIT( vch->resistant, vch->pcdata->deity->element );
deity.c:               REMOVE_BIT( vch->susceptible, vch->pcdata->deity->suscept );
deity.c:               vch->pcdata->deity = NULL;
deity.c:               STRFREE( vch->pcdata->deity_name );
deity.c:               vch->pcdata->deity_name = STRALLOC( "" );
deity.c:      if( ch->substate == SUB_REPEATCMD )
deity.c:         ch->tempnum = SUB_REPEATCMD;
deity.c:         ch->tempnum = SUB_NONE;
deity.c:      ch->substate = SUB_DEITYDESC;
deity.c:      ch->dest_buf = deity;
deity.c:   if( ch->level < 5 )
deity.c:      if( !ch->pcdata->deity )
deity.c:      --ch->pcdata->deity->worshippers;
deity.c:      if( ch->pcdata->deity->worshippers < 0 )
deity.c:         ch->pcdata->deity->worshippers = 0;
deity.c:      ch->pcdata->favor = -2500;
deity.c:      ch->mental_state = -80;
deity.c:      xREMOVE_BITS( ch->affected_by, ch->pcdata->deity->affected );
deity.c:      REMOVE_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:      REMOVE_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      save_deity( ch->pcdata->deity );
deity.c:      ch->pcdata->deity = NULL;
deity.c:      STRFREE( ch->pcdata->deity_name );
deity.c:      ch->pcdata->deity_name = STRALLOC( "" );
deity.c:   if( ch->pcdata->deity )
deity.c:   if( ( deity->Class != -1 ) && ( deity->Class != ch->Class ) )
deity.c:   if( ( deity->sex != -1 ) && ( deity->sex != ch->sex ) )
deity.c:      if( ( deity->race != ch->race ) && ( deity->race2 != ch->race ) )
deity.c:   STRFREE( ch->pcdata->deity_name );
deity.c:   ch->pcdata->deity_name = QUICKLINK( deity->name );
deity.c:   ch->pcdata->deity = deity;
deity.c:   if( ch->pcdata->favor > deity->affectednum )
deity.c:      xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
deity.c:   if( ch->pcdata->favor > deity->elementnum )
deity.c:      SET_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:   if( ch->pcdata->favor < deity->susceptnum )
deity.c:      SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:   act( AT_MAGIC, "Body and soul, you devote yourself to $t!", ch, ch->pcdata->deity_name, NULL, TO_CHAR );
deity.c:   ++ch->pcdata->deity->worshippers;
deity.c:   save_deity( ch->pcdata->deity );
deity.c:   if( IS_NPC( ch ) || !ch->pcdata->deity )
deity.c:   oldfavor = ch->pcdata->favor;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->scorpse )
deity.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
deity.c:      snprintf( buf2, MAX_STRING_LENGTH, "the corpse of %s", ch->name );
deity.c:                  ch->pcdata->favor -= ch->pcdata->deity->scorpse;
deity.c:            obj = obj_to_room( obj, ch->in_room );
deity.c:      ch->pcdata->favor -= ch->pcdata->deity->scorpse;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->savatar )
deity.c:      char_to_room( victim, ch->in_room );
deity.c:      snprintf( buf, MAX_STRING_LENGTH, victim->short_descr, ch->pcdata->deity->name );
deity.c:      snprintf( buf, MAX_STRING_LENGTH, victim->long_descr, ch->pcdata->deity->name );
deity.c:      snprintf( buf, MAX_STRING_LENGTH, victim->description, ch->pcdata->deity->name );
deity.c:      victim->hit = ch->hit * 6 + ch->pcdata->favor;
deity.c:      victim->alignment = ch->pcdata->deity->alignment;
deity.c:      victim->max_hit = ch->hit * 6 + ch->pcdata->favor;
deity.c:      ch->pcdata->favor -= ch->pcdata->deity->savatar;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->sdeityobj )
deity.c:      obj = create_object( pObjIndex, ch->level );
deity.c:         obj = obj_to_room( obj, ch->in_room );
deity.c:      snprintf( buf, MAX_STRING_LENGTH, "sigil %s", ch->pcdata->deity->name );
deity.c:      snprintf( buf, MAX_STRING_LENGTH, obj->short_descr, ch->pcdata->deity->name );
deity.c:      snprintf( buf, MAX_STRING_LENGTH, obj->description, ch->pcdata->deity->name );
deity.c:      ch->pcdata->favor -= ch->pcdata->deity->sdeityobj;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:      switch ( ch->pcdata->deity->objstat )
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->srecall )
deity.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_NOSUPPLICATE ) )
deity.c:      if( !IS_NPC( ch ) && ch->pcdata->clan )
deity.c:         location = get_room_index( ch->pcdata->clan->recall );
deity.c:      if( !IS_NPC( ch ) && !location && ch->level >= 5 && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
deity.c:         location = get_room_index( race_table[ch->race]->race_recall );
deity.c:      if( ch->mount )
deity.c:         char_from_room( ch->mount );
deity.c:         char_to_room( ch->mount, location );
deity.c:      ch->pcdata->favor -= ch->pcdata->deity->srecall;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:   if( IS_NPC( ch ) || !ch->pcdata->deity )
deity.c:   oldfavor = ch->pcdata->favor;
deity.c:   if( ( ch->alignment - ch->pcdata->deity->alignment > 650
deity.c:         || ch->alignment - ch->pcdata->deity->alignment < -650 ) && ch->pcdata->deity->alignment != 0 )
deity.c:      ch->pcdata->favor -= 2;
deity.c:      ch->pcdata->favor = URANGE( -2500, ch->pcdata->favor, 2500 );
deity.c:      if( ch->pcdata->favor > ch->pcdata->deity->affectednum )
deity.c:         xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
deity.c:      if( ch->pcdata->favor > ch->pcdata->deity->elementnum )
deity.c:         SET_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->flee / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->flee_npcrace / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->kill / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->kill_npcrace / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->kill_magic / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->sac / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->bury_corpse / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->aid_spell / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->aid / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->steal / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->backstab / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->die / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->die_npcrace / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->spell_aid / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->dig_corpse / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->die_npcfoe / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->flee_npcfoe / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->kill_npcfoe / mod );
deity.c:   ch->pcdata->favor = URANGE( -2500, ch->pcdata->favor, 2500 );
deity.c:   if( ch->pcdata->favor > ch->pcdata->deity->affectednum )
deity.c:      xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
deity.c:   if( ch->pcdata->favor > ch->pcdata->deity->elementnum )
deity.c:      SET_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:   if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:      SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:   if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:         ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:       ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:         ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:       ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
fight.c:   int oldgold = ch->gold;
fight.c:      if( !CAN_WEAR( content, ITEM_TAKE ) && ch->level < sysdata.level_getobjnotake )
fight.c:      ch->gold += content->value[0] * content->count;
fight.c:   if( ch->gold - oldgold > 1 && ch->position > POS_SLEEPING )
fight.c:      snprintf( buf, MAX_INPUT_LENGTH, "%d", ch->gold - oldgold );
fight.c:   if( !ch->hunting || ch->hunting->who != victim )
fight.c:   if( !ch->hating || ch->hating->who != victim )
fight.c:   if( !ch->fearing || ch->fearing->who != victim )
fight.c:   if( ch->hunting )
fight.c:      STRFREE( ch->hunting->name );
fight.c:      DISPOSE( ch->hunting );
fight.c:      ch->hunting = NULL;
fight.c:   if( ch->hating )
fight.c:      STRFREE( ch->hating->name );
fight.c:      DISPOSE( ch->hating );
fight.c:      ch->hating = NULL;
fight.c:   if( ch->fearing )
fight.c:      STRFREE( ch->fearing->name );
fight.c:      DISPOSE( ch->fearing );
fight.c:      ch->fearing = NULL;
fight.c:   if( ch->hunting )
fight.c:   CREATE( ch->hunting, HHF_DATA, 1 );
fight.c:   ch->hunting->name = QUICKLINK( victim->name );
fight.c:   ch->hunting->who = victim;
fight.c:   if( ch->hating )
fight.c:   CREATE( ch->hating, HHF_DATA, 1 );
fight.c:   ch->hating->name = QUICKLINK( victim->name );
fight.c:   ch->hating->who = victim;
fight.c:   if( ch->fearing )
fight.c:   CREATE( ch->fearing, HHF_DATA, 1 );
fight.c:   ch->fearing->name = QUICKLINK( victim->name );
fight.c:   ch->fearing->who = victim;
fight.c:      if( who_fighting( ch->fighting->who ) == ch && IS_AFFECTED( who_fighting( ch ), AFF_GRAPPLE ) )
fight.c:      if( ch->fighting && ( ++ch->fighting->duration % 24 ) == 0 )
fight.c:         ch->fighting->xp = ( ( ch->fighting->xp * 9 ) / 10 );
fight.c:      for( timer = ch->first_timer; timer; timer = timer_next )
fight.c:         if( ch->fighting && timer->type == TIMER_DO_FUN )
fight.c:            tempsub = ch->substate;
fight.c:            ch->substate = SUB_TIMER_DO_ABORT;
fight.c:            ch->substate = tempsub;
fight.c:               DISPOSE( ch->pcdata->nuisance );
fight.c:               tempsub = ch->substate;
fight.c:               ch->substate = timer->value;
fight.c:               ch->substate = tempsub;
fight.c:      for( paf = ch->first_affect; paf; paf = paf_next )
fight.c:               ch->desc->character = ch->desc->original;
fight.c:               ch->desc->original = NULL;
fight.c:               ch->desc->character->desc = ch->desc;
fight.c:               ch->desc->character->switched = NULL;
fight.c:               ch->desc = NULL;
fight.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
fight.c:         log_printf( "violence_update: %s fighting %s in a SAFE room.", ch->name, victim->name );
fight.c:      else if( IS_AWAKE( ch ) && ch->in_room == victim->in_room )
fight.c:         if( !xIS_EMPTY( ch->attacks ) )
fight.c:            if( 30 + ( ch->level / 4 ) >= number_percent(  ) )
fight.c:                  if( xIS_SET( ch->attacks, attacktype ) )
fight.c:                     retcode = spell_energy_drain( skill_lookup( "energy drain" ), ch->level, ch, victim );
fight.c:                     retcode = spell_fire_breath( skill_lookup( "fire breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_frost_breath( skill_lookup( "frost breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_acid_breath( skill_lookup( "acid breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_lightning_breath( skill_lookup( "lightning breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_gas_breath( skill_lookup( "gas breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_spiral_blast( skill_lookup( "spiral blast" ), ch->level, ch, victim );
fight.c:                     retcode = spell_poison( gsn_poison, ch->level, ch, victim );
fight.c:                      * retcode = spell_nasty_poison( skill_lookup( "nasty poison" ), ch->level, ch, victim );
fight.c:                      * retcode = spell_gaze( skill_lookup( "gaze" ), ch->level, ch, victim );
fight.c:                     retcode = spell_blindness( gsn_blindness, ch->level, ch, victim );
fight.c:                     retcode = spell_cause_serious( skill_lookup( "cause serious" ), ch->level, ch, victim );
fight.c:                     retcode = spell_earthquake( skill_lookup( "earthquake" ), ch->level, ch, victim );
fight.c:                     retcode = spell_cause_critical( skill_lookup( "cause critical" ), ch->level, ch, victim );
fight.c:                     retcode = spell_curse( skill_lookup( "curse" ), ch->level, ch, victim );
fight.c:                     retcode = spell_flamestrike( skill_lookup( "flamestrike" ), ch->level, ch, victim );
fight.c:                     retcode = spell_harm( skill_lookup( "harm" ), ch->level, ch, victim );
fight.c:                     retcode = spell_fireball( skill_lookup( "fireball" ), ch->level, ch, victim );
fight.c:                     retcode = spell_colour_spray( skill_lookup( "colour spray" ), ch->level, ch, victim );
fight.c:                     retcode = spell_weaken( skill_lookup( "weaken" ), ch->level, ch, victim );
fight.c:         if( !xIS_EMPTY( ch->defenses ) )
fight.c:            if( 50 + ( ch->level / 4 ) > number_percent(  ) )
fight.c:                  if( xIS_SET( ch->defenses, attacktype ) )
fight.c:                     if( ch->hit < ch->max_hit )
fight.c:                        retcode = spell_smaug( skill_lookup( "cure light" ), ch->level, ch, ch );
fight.c:                     if( ch->hit < ch->max_hit )
fight.c:                        retcode = spell_smaug( skill_lookup( "cure serious" ), ch->level, ch, ch );
fight.c:                     if( ch->hit < ch->max_hit )
fight.c:                        retcode = spell_smaug( skill_lookup( "cure critical" ), ch->level, ch, ch );
fight.c:                     if( ch->hit < ch->max_hit )
fight.c:                        retcode = spell_smaug( skill_lookup( "heal" ), ch->level, ch, ch );
fight.c:                        retcode = spell_dispel_magic( skill_lookup( "dispel magic" ), ch->level, ch, victim );
fight.c:                     retcode = spell_dispel_evil( skill_lookup( "dispel evil" ), ch->level, ch, victim );
fight.c:                     retcode = spell_teleport( skill_lookup( "teleport" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "shockshield" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "venomshield" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "acidmist" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "fireshield" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "iceshield" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "true" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "sanctuary" ), ch->level, ch, ch );
fight.c:      for( rch = ch->in_room->first_person; rch; rch = trvch_next( lcr ) )
fight.c:             && ( rch->fighting )
fight.c:             && ( who_fighting( rch->fighting->who ) == ch )
fight.c:             && ( !xIS_SET( rch->fighting->who->act, ACT_AUTONOMOUS ) ) && ( rch->style < ch->style ) )
fight.c:            rch->fighting->who->fighting->who = rch;
fight.c:         if( IS_AWAKE( rch ) && !rch->fighting )
fight.c:               if( ( ( !IS_NPC( rch ) && rch->desc )
fight.c:            if( IS_NPC( rch ) && !IS_AFFECTED( rch, AFF_CHARM ) && !xIS_SET( rch->act, ACT_NOASSIST )
fight.c:                && !xIS_SET( rch->act, ACT_PET ) )
fight.c:               if( rch->pIndexData == ch->pIndexData || number_bits( 3 ) == 0 )
fight.c:                  for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
fight.c:                        if( vch->mount && vch->mount == rch )
fight.c:      if( xIS_SET( ch->act, PLR_NICE ) )
fight.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_NOATTACK ) )
fight.c:      dual_bonus = IS_NPC( ch ) ? ( ch->level / 10 ) : ( LEARNED( ch, gsn_dual_wield ) / 10 );
fight.c:      schance = IS_NPC( ch ) ? ch->level : LEARNED( ch, gsn_dual_wield );
fight.c:   if( ch->move < 10 )
fight.c:   if( IS_NPC( ch ) && ch->numattacks > 0 )
fight.c:      for( schance = 0; schance < ch->numattacks; schance++ )
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_second_attack ) + dual_bonus ) / 1.5 );
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_third_attack ) + ( dual_bonus * 1.5 ) ) / 2 );
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_fourth_attack ) + ( dual_bonus * 2 ) ) / 3 );
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_fifth_attack ) + ( dual_bonus * 3 ) ) / 4 );
fight.c:   schance = IS_NPC( ch ) ? ( int )( ch->level / 2 ) : 0;
fight.c:         move = encumbrance( ch, movement_loss[UMIN( SECT_MAX - 1, ch->in_room->sector_type )] );
fight.c:      if( ch->move )
fight.c:         ch->move = UMAX( 0, ch->move - move );
fight.c:   if( !IS_NPC( ch ) && ch->level > 5 && wield )
fight.c:       * ( 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) );
fight.c:         bonus -= ch->pcdata->favor / -400;
fight.c:      lvl = UMAX( 1, ( ch->level - 10 ) / 2 );
fight.c:            return ch->level;
fight.c:      lvl = ch->level / 2;
fight.c:   if( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:   if( ch->fighting  /* make sure fight is already started */
fight.c:       && dt == TYPE_UNDEFINED && IS_NPC( ch ) && !xIS_EMPTY( ch->attacks ) )
fight.c:         if( xIS_SET( ch->attacks, attacktype ) )
fight.c:      thac0_00 = ch->mobthac0;
fight.c:      thac0_00 = class_table[ch->Class]->thac0_00;
fight.c:      thac0_32 = class_table[ch->Class]->thac0_32;
fight.c:   thac0 = interpolate( ch->level, thac0_00, thac0_32 ) - GET_HITROLL( ch );
fight.c:   if( ch->fighting && ch->fighting->who == victim )
fight.c:      short times = ch->fighting->timeskilled;
fight.c:      dam = number_range( ch->barenumdie, ch->baresizedie * ch->barenumdie ) + ch->damplus;
fight.c:   if( ch->position == POS_BERSERK )
fight.c:   else if( ch->position == POS_AGGRESSIVE )
fight.c:   else if( ch->position == POS_DEFENSIVE )
fight.c:   else if( ch->position == POS_EVASIVE )
fight.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c:      dam *= ( 2 + URANGE( 2, ch->level - ( victim->level / 4 ), 30 ) / 8 );
fight.c:      dam *= ( 2 + URANGE( 2, ch->level - ( victim->level / 4 ), 30 ) / 11 );
fight.c:      dam *= ( 2 + URANGE( 2, ch->level - ( victim->level / 4 ), 30 ) / 16 );
fight.c:      thac0_00 = ch->mobthac0;
fight.c:      thac0_00 = class_table[ch->Class]->thac0_00;
fight.c:      thac0_32 = class_table[ch->Class]->thac0_32;
fight.c:   thac0 = interpolate( ch->level, thac0_00, thac0_32 ) - GET_HITROLL( ch ) + ( dist * 2 );
fight.c:   victim_ac = ((((ch->pcdata->def + ch->pcdata->defplus) * ch->pcdata->deflevel) /15 ) * -1);
fight.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c:   if( IS_SET( ch->immune, ris ) && !IS_SET( ch->no_immune, ris ) )
fight.c:   if( IS_SET( ch->resistant, ris ) && !IS_SET( ch->no_resistant, ris ) )
fight.c:   if( IS_SET( ch->susceptible, ris ) && !IS_SET( ch->no_susceptible, ris ) )
fight.c:      if( IS_NPC( ch ) && IS_SET( ch->immune, ris ) )
fight.c:               victim->hunting->name = QUICKLINK( ch->name );
fight.c:            victim->hating->name = QUICKLINK( ch->name );
fight.c://      maxdam = ch->level * 80;
fight.c://      maxdam = ch->level * 40;
fight.c:	dam = ((dam + ch->pcdata->str + ch->pcdata->att) * ch->pcdata->attlevel) * ((ch->pcdata->dex/100) +1);
fight.c:      bug( "** %s (lvl %d) -> %s **", ch->name, ch->level, victim->name );
fight.c:         if( !victim->fighting && victim->in_room == ch->in_room )
fight.c:         if( !ch->fighting && victim->in_room == ch->in_room )
fight.c:             && victim->master && victim->master->in_room == ch->in_room && number_bits( 3 ) == 0 )
fight.c:      for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:      for( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:                 ( ch->leader == victim ) ? victim : ch, NULL,
fight.c:                 ( ch->leader == victim ) ? victim->master : ch->master, TO_NOTVICT );
fight.c:            if( ch->leader == victim )
fight.c:         if( ch->leader != NULL && !IS_NPC( ch->leader ) && !IS_PKILL( ch->leader ) )
fight.c:            act( AT_ACTION, "$n disbands from $N's group.", ch, NULL, ch->master, TO_NOTVICT );
fight.c:            for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:                  act( AT_ACTION, "$n disbands from $N's group.", ch, NULL, gch->master, TO_NOTVICT );
fight.c:            for( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:                  act( AT_ACTION, "$n disbands from $N's group.", gch, NULL, gch->master, TO_NOTVICT );
fight.c:         xREMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
fight.c:         xREMOVE_BIT( ch->affected_by, AFF_HIDE );
fight.c:      if( dt >= TYPE_HIT && ch->in_room == victim->in_room )
fight.c:         if( IS_NPC( ch ) && xIS_SET( ch->defenses, DFND_DISARM ) && ch->level > 9 && number_percent(  ) < ch->level / 3 ) /* Was 2 try this --Shaddai */
fight.c:         if( IS_NPC( ch ) && xIS_SET( ch->attacks, ATCK_TRIP ) && ch->level > 5 && number_percent(  ) < ch->level / 2 )
fight.c:            if( ch->level < LEVEL_AVATAR )
fight.c:   if( dam && ch != victim && !IS_NPC( ch ) && ch->fighting && ch->fighting->xp )
fight.c:      if( ch->fighting->who == victim )
fight.c:         xp_gain = ( int )( ch->fighting->xp * dam ) / victim->max_hit;
fight.c:       && is_wielding_poisoned( ch ) && !IS_SET( victim->immune, RIS_POISON ) && !saves_poison_death( ch->level, victim ) )
fight.c:            add_loginmsg( victim->name, 17, ( IS_NPC(ch) ? ch->short_descr : ch->name ) );
fight.c:                   victim->name, victim->level, ( IS_NPC( ch ) ? ch->short_descr : ch->name ), victim->in_room->vnum );
fight.c:         if( !IS_NPC( ch ) && !IS_IMMORTAL( ch ) && ch->pcdata->clan
fight.c:             && ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD && victim != ch )
fight.c:            snprintf( filename, 256, "%s%s.record", CLAN_DIR, ch->pcdata->clan->name );
fight.c:                      ch->level,
fight.c:                      ch->name,
fight.c:                      "&P(&WUnclanned&P)", victim->name, ch->in_room->area->name );
fight.c:            if( victim->pcdata && victim->pcdata->clan && victim->pcdata->clan->name == ch->pcdata->clan->name )
fight.c:                     ch->level,
fight.c:                     ch->pcdata->clan ? ch->pcdata->clan->badge :
fight.c:                     "&P(&WUnclanned&P)", ch->name, victim->in_room->area->name );
fight.c:            if( ch->pcdata && ch->pcdata->clan && ch->pcdata->clan->name == victim->pcdata->clan->name )
fight.c:         for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:      if( !IS_NPC( ch ) && ch->pcdata->clan )
fight.c:      if( ch->in_room == victim->in_room )
fight.c:          && new_corpse->in_room == ch->in_room && can_see_obj( ch, new_corpse ) && ch->position > POS_SLEEPING )
fight.c:         if( xIS_SET( ch->act, PLR_AUTOGOLD ) && !loot_coins_from_corpse( ch, new_corpse ) )
fight.c:         if( new_corpse && !obj_extracted( new_corpse ) && new_corpse->in_room == ch->in_room
fight.c:             && ch->position > POS_SLEEPING && can_see_obj( ch, new_corpse ) )
fight.c:            if( xIS_SET( ch->act, PLR_AUTOLOOT ) )
fight.c:            if( !char_died( ch ) && xIS_SET( ch->act, PLR_AUTOSAC ) && !obj_extracted( new_corpse )
fight.c:                && new_corpse->in_room == ch->in_room && ch->position > POS_SLEEPING && can_see_obj( ch, new_corpse ) )
fight.c:      bug( "Is_safe: %s opponent does not exist!", ch->name );
fight.c:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
fight.c:   if( calculate_age( ch ) < 18 || ch->level < 5 )
fight.c:   if( ch->level - victim->level > 5 || victim->level - ch->level > 5 )
fight.c:   if( IS_NPC( ch ) && !ch->master )
fight.c:       && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) && IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) )
fight.c:            level_ratio = URANGE( 1, ch->level, MAX_LEVEL );
fight.c:            level_ratio = URANGE( 1, ch->level / victim->level, MAX_LEVEL );
fight.c:         if( ch->pcdata->clan )
fight.c:            ch->pcdata->clan->mkills++;
fight.c:         ch->pcdata->mkills++;
fight.c:         ch->in_room->area->mkills++;
fight.c:         if( ch->pcdata->deity )
fight.c:            if( victim->race == ch->pcdata->deity->npcrace )
fight.c:            else if( victim->race == ch->pcdata->deity->npcfoe )
fight.c:   if( ch == victim || ch->level >= LEVEL_IMMORTAL )
fight.c:         ch->pcdata->pkills++;
fight.c:         if( ch->pcdata->clan )
fight.c:               ch->pcdata->clan->pkills[0]++;
fight.c:               ch->pcdata->clan->pkills[1]++;
fight.c:               ch->pcdata->clan->pkills[2]++;
fight.c:               ch->pcdata->clan->pkills[3]++;
fight.c:               ch->pcdata->clan->pkills[4]++;
fight.c:               ch->pcdata->clan->pkills[5]++;
fight.c:               ch->pcdata->clan->pkills[6]++;
fight.c:         ch->pcdata->pkills++;
fight.c:         ch->in_room->area->pkills++;
fight.c:       && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) && IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) )
fight.c:      if( !ch->pcdata->clan
fight.c:          || ( ch->pcdata->clan->clan_type != CLAN_NOKILL
fight.c:               && victim->pcdata->clan->clan_type != CLAN_NOKILL && ch->pcdata->clan != victim->pcdata->clan ) )
fight.c:         if( ch->pcdata->clan )
fight.c:               ch->pcdata->clan->pkills[0]++;
fight.c:               ch->pcdata->clan->pkills[1]++;
fight.c:               ch->pcdata->clan->pkills[2]++;
fight.c:               ch->pcdata->clan->pkills[3]++;
fight.c:               ch->pcdata->clan->pkills[4]++;
fight.c:               ch->pcdata->clan->pkills[5]++;
fight.c:               ch->pcdata->clan->pkills[6]++;
fight.c:         ch->pcdata->pkills++;
fight.c:         ch->hit = ch->max_hit;
fight.c:         ch->mana = ch->max_mana;
fight.c:         ch->move = ch->max_move;
fight.c:         if( ch->pcdata )
fight.c:            ch->pcdata->condition[COND_BLOODTHIRST] = ( 10 + ch->level );
fight.c:            if( ch->level < 10 )
fight.c:            else if( ch->level < 15 )
fight.c:            else if( ch->level < 20 )
fight.c:            else if( ch->level < 30 )
fight.c:            else if( ch->level < 40 )
fight.c:            else if( ch->level < 50 )
fight.c:      if( !ch->master )
fight.c:         bug( "Check_killer: %s bad AFF_CHARM", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c:         xREMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c:      if( ch->master )
fight.c:         check_killer( ch->master, victim );
fight.c:         level_ratio = URANGE( 1, ch->level / victim->level, LEVEL_AVATAR );
fight.c:            if( ch->race == victim->pcdata->deity->npcrace )
fight.c:            else if( ch->race == victim->pcdata->deity->npcfoe )
fight.c:      if( ch->pcdata->clan )
fight.c:         ch->pcdata->clan->illegal_pk++;
fight.c:      ch->pcdata->illegal_pk++;
fight.c:      ch->in_room->area->illegal_pk++;
fight.c:         if( ch->level < 10 )
fight.c:         else if( ch->level < 15 )
fight.c:         else if( ch->level < 20 )
fight.c:         else if( ch->level < 30 )
fight.c:         else if( ch->level < 40 )
fight.c:         else if( ch->level < 50 )
fight.c:   if( xIS_SET( ch->act, PLR_KILLER ) )
fight.c:   xSET_BIT( ch->act, PLR_KILLER );
fight.c:   if( xIS_SET( ch->act, PLR_ATTACKER ) )
fight.c:      xREMOVE_BIT( ch->act, PLR_ATTACKER );
fight.c:    { if ( !(ch->pcdata->clan && victim->pcdata->clan
fight.c:      && ch->pcdata->clan == victim->pcdata->clan ) )  return; }
fight.c:      if( !ch->master )
fight.c:         bug( "Check_attacker: %s bad AFF_CHARM", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c:         xREMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c:       * xSET_BIT(ch->master->act, PLR_ATTACKER);
fight.c:       || ch == victim || ch->level >= LEVEL_IMMORTAL || xIS_SET( ch->act, PLR_ATTACKER ) || xIS_SET( ch->act, PLR_KILLER ) )
fight.c:   xSET_BIT( ch->act, PLR_ATTACKER );
fight.c:   if( ch->fighting )
fight.c:      bug( "%s: %s -> %s (already fighting %s)", __func__, ch->name, victim->name, ch->fighting->who->name );
fight.c:   ch->num_fighting = 1;
fight.c:   ch->fighting = fight;
fight.c:    * ch->position = POS_FIGHTING; 
fight.c:      ch->position = POS_FIGHTING;
fight.c:      switch ( ch->style )
fight.c:            ch->position = POS_EVASIVE;
fight.c:            ch->position = POS_DEFENSIVE;
fight.c:            ch->position = POS_AGGRESSIVE;
fight.c:            ch->position = POS_BERSERK;
fight.c:            ch->position = POS_FIGHTING;
fight.c:   if( !ch->fighting )
fight.c:   return ch->fighting->who;
fight.c:   if( ch->fighting )
fight.c:      if( !char_died( ch->fighting->who ) )
fight.c:         --ch->fighting->who->num_fighting;
fight.c:      DISPOSE( ch->fighting );
fight.c:   ch->fighting = NULL;
fight.c:   if( ch->mount )
fight.c:      ch->position = POS_MOUNTED;
fight.c:      ch->position = POS_STANDING;
fight.c:   for( fch = first_char; fch; fch = fch->next )
fight.c:         for( i = 0; i < 32 && ch->xflags; i++ )
fight.c:      name = IS_NPC( ch ) ? ch->short_descr : ch->name;
fight.c:      obj = obj_to_room( obj, ch->in_room );
fight.c:   was_in_room = ch->in_room;
fight.c:         ch->in_room = pexit->to_room;
fight.c:   ch->in_room = was_in_room;
fight.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:   lch = ch->leader ? ch->leader : ch;
fight.c:   for( gch = ch->in_room->first_person; gch; gch = gch_next )
fight.c:      gch_next = gch->next_in_room;
fight.c:      if( gch->level - lch->level > 8 )
fight.c:      if( gch->level - lch->level < -8 )
fight.c:      if( !gch->fighting )
fight.c:      gch->alignment = align_compute( gch, victim );
fight.c:        ch->pcdata->ap += (victim->level * get_curr_lck(ch));
fight.c:      for( obj = gch->first_carrying; obj; obj = obj_next )
fight.c:               obj = obj_to_room( obj, ch->in_room );
fight.c:   align = gch->alignment - victim->alignment;
fight.c:   if( gch->alignment > -350 && gch->alignment < 350 )
fight.c:      newalign = UMIN( gch->alignment + ( align - 500 ) / divalign, 1000 );
fight.c:      newalign = UMAX( gch->alignment + ( align + 500 ) / divalign, -1000 );
fight.c:      newalign = gch->alignment - ( int )( gch->alignment / divalign );
fight.c:   int gchlev = gch->level;
fight.c:   align = gch->alignment - victim->alignment;
fight.c:   if( gch->alignment > 300 && align < 250 )
fight.c:      xp_ratio = ( int )gch->played / gchlev;
fight.c:   if( ch->in_room != victim->in_room )
fight.c:      was_in_room = ch->in_room;
fight.c:      bug( "%s: bad dt %d from %s in %d.", __func__, dt, ch->name, ch->in_room->vnum );
fight.c:   if( dam == 0 && ( !IS_NPC( ch ) && ( IS_SET( ch->pcdata->flags, PCFLAG_GAG ) ) ) )
fight.c:         bug( "Dam_message: bad dt %d from %s in %d.", dt, ch->name, ch->in_room->vnum );
fight.c:         bug( "Dam_message: bad dt %d from %s in %d.", dt, ch->name, ch->in_room->vnum );
fight.c:   if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
fight.c:   if( ch->position == POS_FIGHTING
fight.c:       || ch->position == POS_EVASIVE
fight.c:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c:      if( ch->master == victim )
fight.c:         if( ch->master )
fight.c:            xSET_BIT( ch->master->act, PLR_ATTACKER );
fight.c:   if( ch->position == POS_FIGHTING
fight.c:       || ch->position == POS_EVASIVE
fight.c:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c:   if( !IS_NPC( victim ) && xIS_SET( ch->act, PLR_NICE ) )
fight.c:      log_printf_plus( LOG_NORMAL, ch->level, "%s: murder %s.", ch->name, victim->name );
fight.c:  // snprintf( buf, MAX_STRING_LENGTH, "Help!  I am being attacked by %s!", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_ARENA ) )
fight.c:   if( IS_SET( ch->in_room->area->flags, AFLAG_FREEKILL ) )
fight.c:   if( ch->in_room->vnum >= 29 && ch->in_room->vnum <= 43 )
fight.c:   if( !str_cmp( ch->in_room->area->filename, "arena.are" ) )
fight.c:            || ch->level - victim->level > 5
fight.c:            || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
fight.c:            snprintf( buf, MAX_STRING_LENGTH, " (%s)", ch->name );
fight.c:      if( ch->position == POS_FIGHTING
fight.c:          || ch->position == POS_EVASIVE
fight.c:          || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c:         if( ch->mount )
fight.c:            ch->position = POS_MOUNTED;
fight.c:            ch->position = POS_STANDING;
fight.c:   if( ch->move <= 0 )
fight.c:   if( !IS_NPC( ch ) && ch->position < POS_FIGHTING )
fight.c:   if( IS_NPC( ch ) && ch->position <= POS_SLEEPING )
fight.c:   was_in = ch->in_room;
fight.c:      xREMOVE_BIT( ch->affected_by, AFF_SNEAK );
fight.c:      if( ch->mount && ch->mount->fighting )
fight.c:         stop_fighting( ch->mount, TRUE );
fight.c:      if( ( now_in = ch->in_room ) == was_in )
fight.c:      ch->in_room = was_in;
fight.c:      ch->in_room = now_in;
fight.c:         los = ( int )( ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.2 );
fight.c:         if( ch->level < LEVEL_AVATAR )
fight.c:               if( ch->level > 1 )
fight.c:         if( wf && ch->pcdata->deity )
fight.c:            int level_ratio = URANGE( 1, wf->level / ch->level, MAX_LEVEL );
fight.c:            if( wf && wf->race == ch->pcdata->deity->npcrace )
fight.c:            else if( wf && wf->race == ch->pcdata->deity->npcfoe )
fight.c:   los = ( int )( ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.1 );
fight.c:   if( ch->level < LEVEL_AVATAR && number_bits( 3 ) == 1 )
fight.c:         if( ch->level > 1 )
fight.c.backup:   int oldgold = ch->gold;
fight.c.backup:      if( !CAN_WEAR( content, ITEM_TAKE ) && ch->level < sysdata.level_getobjnotake )
fight.c.backup:      ch->gold += content->value[0] * content->count;
fight.c.backup:   if( ch->gold - oldgold > 1 && ch->position > POS_SLEEPING )
fight.c.backup:      snprintf( buf, MAX_INPUT_LENGTH, "%d", ch->gold - oldgold );
fight.c.backup:   if( !ch->hunting || ch->hunting->who != victim )
fight.c.backup:   if( !ch->hating || ch->hating->who != victim )
fight.c.backup:   if( !ch->fearing || ch->fearing->who != victim )
fight.c.backup:   if( ch->hunting )
fight.c.backup:      STRFREE( ch->hunting->name );
fight.c.backup:      DISPOSE( ch->hunting );
fight.c.backup:      ch->hunting = NULL;
fight.c.backup:   if( ch->hating )
fight.c.backup:      STRFREE( ch->hating->name );
fight.c.backup:      DISPOSE( ch->hating );
fight.c.backup:      ch->hating = NULL;
fight.c.backup:   if( ch->fearing )
fight.c.backup:      STRFREE( ch->fearing->name );
fight.c.backup:      DISPOSE( ch->fearing );
fight.c.backup:      ch->fearing = NULL;
fight.c.backup:   if( ch->hunting )
fight.c.backup:   CREATE( ch->hunting, HHF_DATA, 1 );
fight.c.backup:   ch->hunting->name = QUICKLINK( victim->name );
fight.c.backup:   ch->hunting->who = victim;
fight.c.backup:   if( ch->hating )
fight.c.backup:   CREATE( ch->hating, HHF_DATA, 1 );
fight.c.backup:   ch->hating->name = QUICKLINK( victim->name );
fight.c.backup:   ch->hating->who = victim;
fight.c.backup:   if( ch->fearing )
fight.c.backup:   CREATE( ch->fearing, HHF_DATA, 1 );
fight.c.backup:   ch->fearing->name = QUICKLINK( victim->name );
fight.c.backup:   ch->fearing->who = victim;
fight.c.backup:      if( who_fighting( ch->fighting->who ) == ch && IS_AFFECTED( who_fighting( ch ), AFF_GRAPPLE ) )
fight.c.backup:      if( ch->fighting && ( ++ch->fighting->duration % 24 ) == 0 )
fight.c.backup:         ch->fighting->xp = ( ( ch->fighting->xp * 9 ) / 10 );
fight.c.backup:      for( timer = ch->first_timer; timer; timer = timer_next )
fight.c.backup:         if( ch->fighting && timer->type == TIMER_DO_FUN )
fight.c.backup:            tempsub = ch->substate;
fight.c.backup:            ch->substate = SUB_TIMER_DO_ABORT;
fight.c.backup:            ch->substate = tempsub;
fight.c.backup:               DISPOSE( ch->pcdata->nuisance );
fight.c.backup:               tempsub = ch->substate;
fight.c.backup:               ch->substate = timer->value;
fight.c.backup:               ch->substate = tempsub;
fight.c.backup:      for( paf = ch->first_affect; paf; paf = paf_next )
fight.c.backup:               ch->desc->character = ch->desc->original;
fight.c.backup:               ch->desc->original = NULL;
fight.c.backup:               ch->desc->character->desc = ch->desc;
fight.c.backup:               ch->desc->character->switched = NULL;
fight.c.backup:               ch->desc = NULL;
fight.c.backup:      if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
fight.c.backup:         log_printf( "violence_update: %s fighting %s in a SAFE room.", ch->name, victim->name );
fight.c.backup:      else if( IS_AWAKE( ch ) && ch->in_room == victim->in_room )
fight.c.backup:         if( !xIS_EMPTY( ch->attacks ) )
fight.c.backup:            if( 30 + ( ch->level / 4 ) >= number_percent(  ) )
fight.c.backup:                  if( xIS_SET( ch->attacks, attacktype ) )
fight.c.backup:                     retcode = spell_energy_drain( skill_lookup( "energy drain" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_fire_breath( skill_lookup( "fire breath" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_frost_breath( skill_lookup( "frost breath" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_acid_breath( skill_lookup( "acid breath" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_lightning_breath( skill_lookup( "lightning breath" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_gas_breath( skill_lookup( "gas breath" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_spiral_blast( skill_lookup( "spiral blast" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_poison( gsn_poison, ch->level, ch, victim );
fight.c.backup:                      * retcode = spell_nasty_poison( skill_lookup( "nasty poison" ), ch->level, ch, victim );
fight.c.backup:                      * retcode = spell_gaze( skill_lookup( "gaze" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_blindness( gsn_blindness, ch->level, ch, victim );
fight.c.backup:                     retcode = spell_cause_serious( skill_lookup( "cause serious" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_earthquake( skill_lookup( "earthquake" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_cause_critical( skill_lookup( "cause critical" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_curse( skill_lookup( "curse" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_flamestrike( skill_lookup( "flamestrike" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_harm( skill_lookup( "harm" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_fireball( skill_lookup( "fireball" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_colour_spray( skill_lookup( "colour spray" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_weaken( skill_lookup( "weaken" ), ch->level, ch, victim );
fight.c.backup:         if( !xIS_EMPTY( ch->defenses ) )
fight.c.backup:            if( 50 + ( ch->level / 4 ) > number_percent(  ) )
fight.c.backup:                  if( xIS_SET( ch->defenses, attacktype ) )
fight.c.backup:                     if( ch->hit < ch->max_hit )
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "cure light" ), ch->level, ch, ch );
fight.c.backup:                     if( ch->hit < ch->max_hit )
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "cure serious" ), ch->level, ch, ch );
fight.c.backup:                     if( ch->hit < ch->max_hit )
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "cure critical" ), ch->level, ch, ch );
fight.c.backup:                     if( ch->hit < ch->max_hit )
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "heal" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_dispel_magic( skill_lookup( "dispel magic" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_dispel_evil( skill_lookup( "dispel evil" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_teleport( skill_lookup( "teleport" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "shockshield" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "venomshield" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "acidmist" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "fireshield" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "iceshield" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "true" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "sanctuary" ), ch->level, ch, ch );
fight.c.backup:      for( rch = ch->in_room->first_person; rch; rch = trvch_next( lcr ) )
fight.c.backup:             && ( rch->fighting )
fight.c.backup:             && ( who_fighting( rch->fighting->who ) == ch )
fight.c.backup:             && ( !xIS_SET( rch->fighting->who->act, ACT_AUTONOMOUS ) ) && ( rch->style < ch->style ) )
fight.c.backup:            rch->fighting->who->fighting->who = rch;
fight.c.backup:         if( IS_AWAKE( rch ) && !rch->fighting )
fight.c.backup:               if( ( ( !IS_NPC( rch ) && rch->desc )
fight.c.backup:            if( IS_NPC( rch ) && !IS_AFFECTED( rch, AFF_CHARM ) && !xIS_SET( rch->act, ACT_NOASSIST )
fight.c.backup:                && !xIS_SET( rch->act, ACT_PET ) )
fight.c.backup:               if( rch->pIndexData == ch->pIndexData || number_bits( 3 ) == 0 )
fight.c.backup:                  for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
fight.c.backup:                        if( vch->mount && vch->mount == rch )
fight.c.backup:      if( xIS_SET( ch->act, PLR_NICE ) )
fight.c.backup:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_NOATTACK ) )
fight.c.backup:      dual_bonus = IS_NPC( ch ) ? ( ch->level / 10 ) : ( LEARNED( ch, gsn_dual_wield ) / 10 );
fight.c.backup:      schance = IS_NPC( ch ) ? ch->level : LEARNED( ch, gsn_dual_wield );
fight.c.backup:   if( ch->move < 10 )
fight.c.backup:   if( IS_NPC( ch ) && ch->numattacks > 0 )
fight.c.backup:      for( schance = 0; schance < ch->numattacks; schance++ )
fight.c.backup:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_second_attack ) + dual_bonus ) / 1.5 );
fight.c.backup:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_third_attack ) + ( dual_bonus * 1.5 ) ) / 2 );
fight.c.backup:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_fourth_attack ) + ( dual_bonus * 2 ) ) / 3 );
fight.c.backup:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_fifth_attack ) + ( dual_bonus * 3 ) ) / 4 );
fight.c.backup:   schance = IS_NPC( ch ) ? ( int )( ch->level / 2 ) : 0;
fight.c.backup:         move = encumbrance( ch, movement_loss[UMIN( SECT_MAX - 1, ch->in_room->sector_type )] );
fight.c.backup:      if( ch->move )
fight.c.backup:         ch->move = UMAX( 0, ch->move - move );
fight.c.backup:   if( !IS_NPC( ch ) && ch->level > 5 && wield )
fight.c.backup:       * ( 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) );
fight.c.backup:         bonus -= ch->pcdata->favor / -400;
fight.c.backup:      lvl = UMAX( 1, ( ch->level - 10 ) / 2 );
fight.c.backup:            return ch->level;
fight.c.backup:      lvl = ch->level / 2;
fight.c.backup:   if( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c.backup:   if( ch->fighting  /* make sure fight is already started */
fight.c.backup:       && dt == TYPE_UNDEFINED && IS_NPC( ch ) && !xIS_EMPTY( ch->attacks ) )
fight.c.backup:         if( xIS_SET( ch->attacks, attacktype ) )
fight.c.backup:      thac0_00 = ch->mobthac0;
fight.c.backup:      thac0_00 = class_table[ch->Class]->thac0_00;
fight.c.backup:      thac0_32 = class_table[ch->Class]->thac0_32;
fight.c.backup:   thac0 = interpolate( ch->level, thac0_00, thac0_32 ) - GET_HITROLL( ch );
fight.c.backup:   if( ch->fighting && ch->fighting->who == victim )
fight.c.backup:      short times = ch->fighting->timeskilled;
fight.c.backup:      dam = number_range( ch->barenumdie, ch->baresizedie * ch->barenumdie ) + ch->damplus;
fight.c.backup:   if( ch->position == POS_BERSERK )
fight.c.backup:   else if( ch->position == POS_AGGRESSIVE )
fight.c.backup:   else if( ch->position == POS_DEFENSIVE )
fight.c.backup:   else if( ch->position == POS_EVASIVE )
fight.c.backup:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c.backup:      dam *= ( 2 + URANGE( 2, ch->level - ( victim->level / 4 ), 30 ) / 8 );
fight.c.backup:      dam *= ( 2 + URANGE( 2, ch->level - ( victim->level / 4 ), 30 ) / 11 );
fight.c.backup:      dam *= ( 2 + URANGE( 2, ch->level - ( victim->level / 4 ), 30 ) / 16 );
fight.c.backup:      thac0_00 = ch->mobthac0;
fight.c.backup:      thac0_00 = class_table[ch->Class]->thac0_00;
fight.c.backup:      thac0_32 = class_table[ch->Class]->thac0_32;
fight.c.backup:   thac0 = interpolate( ch->level, thac0_00, thac0_32 ) - GET_HITROLL( ch ) + ( dist * 2 );
fight.c.backup:   victim_ac = ((((ch->pcdata->def + ch->pcdata->defplus) * ch->pcdata->deflevel) /15 ) * -1);
fight.c.backup:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c.backup:   if( IS_SET( ch->immune, ris ) && !IS_SET( ch->no_immune, ris ) )
fight.c.backup:   if( IS_SET( ch->resistant, ris ) && !IS_SET( ch->no_resistant, ris ) )
fight.c.backup:   if( IS_SET( ch->susceptible, ris ) && !IS_SET( ch->no_susceptible, ris ) )
fight.c.backup:      if( IS_NPC( ch ) && IS_SET( ch->immune, ris ) )
fight.c.backup:               victim->hunting->name = QUICKLINK( ch->name );
fight.c.backup:            victim->hating->name = QUICKLINK( ch->name );
fight.c.backup://      maxdam = ch->level * 80;
fight.c.backup://      maxdam = ch->level * 40;
fight.c.backup:	dam = (dam + ch->pcdata->str + ch->pcdata->att + ch->pcdata->attplus) * ch->pcdata->attlevel;
fight.c.backup:      bug( "** %s (lvl %d) -> %s **", ch->name, ch->level, victim->name );
fight.c.backup:         if( !victim->fighting && victim->in_room == ch->in_room )
fight.c.backup:         if( !ch->fighting && victim->in_room == ch->in_room )
fight.c.backup:             && victim->master && victim->master->in_room == ch->in_room && number_bits( 3 ) == 0 )
fight.c.backup:      for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c.backup:      for( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c.backup:                 ( ch->leader == victim ) ? victim : ch, NULL,
fight.c.backup:                 ( ch->leader == victim ) ? victim->master : ch->master, TO_NOTVICT );
fight.c.backup:            if( ch->leader == victim )
fight.c.backup:         if( ch->leader != NULL && !IS_NPC( ch->leader ) && !IS_PKILL( ch->leader ) )
fight.c.backup:            act( AT_ACTION, "$n disbands from $N's group.", ch, NULL, ch->master, TO_NOTVICT );
fight.c.backup:            for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c.backup:                  act( AT_ACTION, "$n disbands from $N's group.", ch, NULL, gch->master, TO_NOTVICT );
fight.c.backup:            for( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c.backup:                  act( AT_ACTION, "$n disbands from $N's group.", gch, NULL, gch->master, TO_NOTVICT );
fight.c.backup:         xREMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
fight.c.backup:         xREMOVE_BIT( ch->affected_by, AFF_HIDE );
fight.c.backup:      if( dt >= TYPE_HIT && ch->in_room == victim->in_room )
fight.c.backup:         if( IS_NPC( ch ) && xIS_SET( ch->defenses, DFND_DISARM ) && ch->level > 9 && number_percent(  ) < ch->level / 3 ) /* Was 2 try this --Shaddai */
fight.c.backup:         if( IS_NPC( ch ) && xIS_SET( ch->attacks, ATCK_TRIP ) && ch->level > 5 && number_percent(  ) < ch->level / 2 )
fight.c.backup:            if( ch->level < LEVEL_AVATAR )
fight.c.backup:   if( dam && ch != victim && !IS_NPC( ch ) && ch->fighting && ch->fighting->xp )
fight.c.backup:      if( ch->fighting->who == victim )
fight.c.backup:         xp_gain = ( int )( ch->fighting->xp * dam ) / victim->max_hit;
fight.c.backup:       && is_wielding_poisoned( ch ) && !IS_SET( victim->immune, RIS_POISON ) && !saves_poison_death( ch->level, victim ) )
fight.c.backup:            add_loginmsg( victim->name, 17, ( IS_NPC(ch) ? ch->short_descr : ch->name ) );
fight.c.backup:                   victim->name, victim->level, ( IS_NPC( ch ) ? ch->short_descr : ch->name ), victim->in_room->vnum );
fight.c.backup:         if( !IS_NPC( ch ) && !IS_IMMORTAL( ch ) && ch->pcdata->clan
fight.c.backup:             && ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD && victim != ch )
fight.c.backup:            snprintf( filename, 256, "%s%s.record", CLAN_DIR, ch->pcdata->clan->name );
fight.c.backup:                      ch->level,
fight.c.backup:                      ch->name,
fight.c.backup:                      "&P(&WUnclanned&P)", victim->name, ch->in_room->area->name );
fight.c.backup:            if( victim->pcdata && victim->pcdata->clan && victim->pcdata->clan->name == ch->pcdata->clan->name )
fight.c.backup:                     ch->level,
fight.c.backup:                     ch->pcdata->clan ? ch->pcdata->clan->badge :
fight.c.backup:                     "&P(&WUnclanned&P)", ch->name, victim->in_room->area->name );
fight.c.backup:            if( ch->pcdata && ch->pcdata->clan && ch->pcdata->clan->name == victim->pcdata->clan->name )
fight.c.backup:         for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c.backup:      if( !IS_NPC( ch ) && ch->pcdata->clan )
fight.c.backup:      if( ch->in_room == victim->in_room )
fight.c.backup:          && new_corpse->in_room == ch->in_room && can_see_obj( ch, new_corpse ) && ch->position > POS_SLEEPING )
fight.c.backup:         if( xIS_SET( ch->act, PLR_AUTOGOLD ) && !loot_coins_from_corpse( ch, new_corpse ) )
fight.c.backup:         if( new_corpse && !obj_extracted( new_corpse ) && new_corpse->in_room == ch->in_room
fight.c.backup:             && ch->position > POS_SLEEPING && can_see_obj( ch, new_corpse ) )
fight.c.backup:            if( xIS_SET( ch->act, PLR_AUTOLOOT ) )
fight.c.backup:            if( !char_died( ch ) && xIS_SET( ch->act, PLR_AUTOSAC ) && !obj_extracted( new_corpse )
fight.c.backup:                && new_corpse->in_room == ch->in_room && ch->position > POS_SLEEPING && can_see_obj( ch, new_corpse ) )
fight.c.backup:      bug( "Is_safe: %s opponent does not exist!", ch->name );
fight.c.backup:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
fight.c.backup:   if( calculate_age( ch ) < 18 || ch->level < 5 )
fight.c.backup:   if( ch->level - victim->level > 5 || victim->level - ch->level > 5 )
fight.c.backup:   if( IS_NPC( ch ) && !ch->master )
fight.c.backup:       && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) && IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) )
fight.c.backup:            level_ratio = URANGE( 1, ch->level, MAX_LEVEL );
fight.c.backup:            level_ratio = URANGE( 1, ch->level / victim->level, MAX_LEVEL );
fight.c.backup:         if( ch->pcdata->clan )
fight.c.backup:            ch->pcdata->clan->mkills++;
fight.c.backup:         ch->pcdata->mkills++;
fight.c.backup:         ch->in_room->area->mkills++;
fight.c.backup:         if( ch->pcdata->deity )
fight.c.backup:            if( victim->race == ch->pcdata->deity->npcrace )
fight.c.backup:            else if( victim->race == ch->pcdata->deity->npcfoe )
fight.c.backup:   if( ch == victim || ch->level >= LEVEL_IMMORTAL )
fight.c.backup:         ch->pcdata->pkills++;
fight.c.backup:         if( ch->pcdata->clan )
fight.c.backup:               ch->pcdata->clan->pkills[0]++;
fight.c.backup:               ch->pcdata->clan->pkills[1]++;
fight.c.backup:               ch->pcdata->clan->pkills[2]++;
fight.c.backup:               ch->pcdata->clan->pkills[3]++;
fight.c.backup:               ch->pcdata->clan->pkills[4]++;
fight.c.backup:               ch->pcdata->clan->pkills[5]++;
fight.c.backup:               ch->pcdata->clan->pkills[6]++;
fight.c.backup:         ch->pcdata->pkills++;
fight.c.backup:         ch->in_room->area->pkills++;
fight.c.backup:       && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) && IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) )
fight.c.backup:      if( !ch->pcdata->clan
fight.c.backup:          || ( ch->pcdata->clan->clan_type != CLAN_NOKILL
fight.c.backup:               && victim->pcdata->clan->clan_type != CLAN_NOKILL && ch->pcdata->clan != victim->pcdata->clan ) )
fight.c.backup:         if( ch->pcdata->clan )
fight.c.backup:               ch->pcdata->clan->pkills[0]++;
fight.c.backup:               ch->pcdata->clan->pkills[1]++;
fight.c.backup:               ch->pcdata->clan->pkills[2]++;
fight.c.backup:               ch->pcdata->clan->pkills[3]++;
fight.c.backup:               ch->pcdata->clan->pkills[4]++;
fight.c.backup:               ch->pcdata->clan->pkills[5]++;
fight.c.backup:               ch->pcdata->clan->pkills[6]++;
fight.c.backup:         ch->pcdata->pkills++;
fight.c.backup:         ch->hit = ch->max_hit;
fight.c.backup:         ch->mana = ch->max_mana;
fight.c.backup:         ch->move = ch->max_move;
fight.c.backup:         if( ch->pcdata )
fight.c.backup:            ch->pcdata->condition[COND_BLOODTHIRST] = ( 10 + ch->level );
fight.c.backup:            if( ch->level < 10 )
fight.c.backup:            else if( ch->level < 15 )
fight.c.backup:            else if( ch->level < 20 )
fight.c.backup:            else if( ch->level < 30 )
fight.c.backup:            else if( ch->level < 40 )
fight.c.backup:            else if( ch->level < 50 )
fight.c.backup:      if( !ch->master )
fight.c.backup:         bug( "Check_killer: %s bad AFF_CHARM", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c.backup:         xREMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c.backup:      if( ch->master )
fight.c.backup:         check_killer( ch->master, victim );
fight.c.backup:         level_ratio = URANGE( 1, ch->level / victim->level, LEVEL_AVATAR );
fight.c.backup:            if( ch->race == victim->pcdata->deity->npcrace )
fight.c.backup:            else if( ch->race == victim->pcdata->deity->npcfoe )
fight.c.backup:      if( ch->pcdata->clan )
fight.c.backup:         ch->pcdata->clan->illegal_pk++;
fight.c.backup:      ch->pcdata->illegal_pk++;
fight.c.backup:      ch->in_room->area->illegal_pk++;
fight.c.backup:         if( ch->level < 10 )
fight.c.backup:         else if( ch->level < 15 )
fight.c.backup:         else if( ch->level < 20 )
fight.c.backup:         else if( ch->level < 30 )
fight.c.backup:         else if( ch->level < 40 )
fight.c.backup:         else if( ch->level < 50 )
fight.c.backup:   if( xIS_SET( ch->act, PLR_KILLER ) )
fight.c.backup:   xSET_BIT( ch->act, PLR_KILLER );
fight.c.backup:   if( xIS_SET( ch->act, PLR_ATTACKER ) )
fight.c.backup:      xREMOVE_BIT( ch->act, PLR_ATTACKER );
fight.c.backup:    { if ( !(ch->pcdata->clan && victim->pcdata->clan
fight.c.backup:      && ch->pcdata->clan == victim->pcdata->clan ) )  return; }
fight.c.backup:      if( !ch->master )
fight.c.backup:         bug( "Check_attacker: %s bad AFF_CHARM", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c.backup:         xREMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c.backup:       * xSET_BIT(ch->master->act, PLR_ATTACKER);
fight.c.backup:       || ch == victim || ch->level >= LEVEL_IMMORTAL || xIS_SET( ch->act, PLR_ATTACKER ) || xIS_SET( ch->act, PLR_KILLER ) )
fight.c.backup:   xSET_BIT( ch->act, PLR_ATTACKER );
fight.c.backup:   if( ch->fighting )
fight.c.backup:      bug( "%s: %s -> %s (already fighting %s)", __func__, ch->name, victim->name, ch->fighting->who->name );
fight.c.backup:   ch->num_fighting = 1;
fight.c.backup:   ch->fighting = fight;
fight.c.backup:    * ch->position = POS_FIGHTING; 
fight.c.backup:      ch->position = POS_FIGHTING;
fight.c.backup:      switch ( ch->style )
fight.c.backup:            ch->position = POS_EVASIVE;
fight.c.backup:            ch->position = POS_DEFENSIVE;
fight.c.backup:            ch->position = POS_AGGRESSIVE;
fight.c.backup:            ch->position = POS_BERSERK;
fight.c.backup:            ch->position = POS_FIGHTING;
fight.c.backup:   if( !ch->fighting )
fight.c.backup:   return ch->fighting->who;
fight.c.backup:   if( ch->fighting )
fight.c.backup:      if( !char_died( ch->fighting->who ) )
fight.c.backup:         --ch->fighting->who->num_fighting;
fight.c.backup:      DISPOSE( ch->fighting );
fight.c.backup:   ch->fighting = NULL;
fight.c.backup:   if( ch->mount )
fight.c.backup:      ch->position = POS_MOUNTED;
fight.c.backup:      ch->position = POS_STANDING;
fight.c.backup:   for( fch = first_char; fch; fch = fch->next )
fight.c.backup:         for( i = 0; i < 32 && ch->xflags; i++ )
fight.c.backup:      name = IS_NPC( ch ) ? ch->short_descr : ch->name;
fight.c.backup:      obj = obj_to_room( obj, ch->in_room );
fight.c.backup:   was_in_room = ch->in_room;
fight.c.backup:         ch->in_room = pexit->to_room;
fight.c.backup:   ch->in_room = was_in_room;
fight.c.backup:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c.backup:   lch = ch->leader ? ch->leader : ch;
fight.c.backup:   for( gch = ch->in_room->first_person; gch; gch = gch_next )
fight.c.backup:      gch_next = gch->next_in_room;
fight.c.backup:      if( gch->level - lch->level > 8 )
fight.c.backup:      if( gch->level - lch->level < -8 )
fight.c.backup:      if( !gch->fighting )
fight.c.backup:      gch->alignment = align_compute( gch, victim );
fight.c.backup:        ch->pcdata->ap += (victim->level * get_curr_lck(ch));
fight.c.backup:      for( obj = gch->first_carrying; obj; obj = obj_next )
fight.c.backup:               obj = obj_to_room( obj, ch->in_room );
fight.c.backup:   align = gch->alignment - victim->alignment;
fight.c.backup:   if( gch->alignment > -350 && gch->alignment < 350 )
fight.c.backup:      newalign = UMIN( gch->alignment + ( align - 500 ) / divalign, 1000 );
fight.c.backup:      newalign = UMAX( gch->alignment + ( align + 500 ) / divalign, -1000 );
fight.c.backup:      newalign = gch->alignment - ( int )( gch->alignment / divalign );
fight.c.backup:   int gchlev = gch->level;
fight.c.backup:   align = gch->alignment - victim->alignment;
fight.c.backup:   if( gch->alignment > 300 && align < 250 )
fight.c.backup:      xp_ratio = ( int )gch->played / gchlev;
fight.c.backup:   if( ch->in_room != victim->in_room )
fight.c.backup:      was_in_room = ch->in_room;
fight.c.backup:      bug( "%s: bad dt %d from %s in %d.", __func__, dt, ch->name, ch->in_room->vnum );
fight.c.backup:   if( dam == 0 && ( !IS_NPC( ch ) && ( IS_SET( ch->pcdata->flags, PCFLAG_GAG ) ) ) )
fight.c.backup:         bug( "Dam_message: bad dt %d from %s in %d.", dt, ch->name, ch->in_room->vnum );
fight.c.backup:         bug( "Dam_message: bad dt %d from %s in %d.", dt, ch->name, ch->in_room->vnum );
fight.c.backup:   if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
fight.c.backup:   if( ch->position == POS_FIGHTING
fight.c.backup:       || ch->position == POS_EVASIVE
fight.c.backup:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c.backup:      if( ch->master == victim )
fight.c.backup:         if( ch->master )
fight.c.backup:            xSET_BIT( ch->master->act, PLR_ATTACKER );
fight.c.backup:   if( ch->position == POS_FIGHTING
fight.c.backup:       || ch->position == POS_EVASIVE
fight.c.backup:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c.backup:   if( !IS_NPC( victim ) && xIS_SET( ch->act, PLR_NICE ) )
fight.c.backup:      log_printf_plus( LOG_NORMAL, ch->level, "%s: murder %s.", ch->name, victim->name );
fight.c.backup:  // snprintf( buf, MAX_STRING_LENGTH, "Help!  I am being attacked by %s!", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c.backup:   if( xIS_SET( ch->in_room->room_flags, ROOM_ARENA ) )
fight.c.backup:   if( IS_SET( ch->in_room->area->flags, AFLAG_FREEKILL ) )
fight.c.backup:   if( ch->in_room->vnum >= 29 && ch->in_room->vnum <= 43 )
fight.c.backup:   if( !str_cmp( ch->in_room->area->filename, "arena.are" ) )
fight.c.backup:            || ch->level - victim->level > 5
fight.c.backup:            || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
fight.c.backup:            snprintf( buf, MAX_STRING_LENGTH, " (%s)", ch->name );
fight.c.backup:      if( ch->position == POS_FIGHTING
fight.c.backup:          || ch->position == POS_EVASIVE
fight.c.backup:          || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c.backup:         if( ch->mount )
fight.c.backup:            ch->position = POS_MOUNTED;
fight.c.backup:            ch->position = POS_STANDING;
fight.c.backup:   if( ch->move <= 0 )
fight.c.backup:   if( !IS_NPC( ch ) && ch->position < POS_FIGHTING )
fight.c.backup:   if( IS_NPC( ch ) && ch->position <= POS_SLEEPING )
fight.c.backup:   was_in = ch->in_room;
fight.c.backup:      xREMOVE_BIT( ch->affected_by, AFF_SNEAK );
fight.c.backup:      if( ch->mount && ch->mount->fighting )
fight.c.backup:         stop_fighting( ch->mount, TRUE );
fight.c.backup:      if( ( now_in = ch->in_room ) == was_in )
fight.c.backup:      ch->in_room = was_in;
fight.c.backup:      ch->in_room = now_in;
fight.c.backup:         los = ( int )( ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.2 );
fight.c.backup:         if( ch->level < LEVEL_AVATAR )
fight.c.backup:               if( ch->level > 1 )
fight.c.backup:         if( wf && ch->pcdata->deity )
fight.c.backup:            int level_ratio = URANGE( 1, wf->level / ch->level, MAX_LEVEL );
fight.c.backup:            if( wf && wf->race == ch->pcdata->deity->npcrace )
fight.c.backup:            else if( wf && wf->race == ch->pcdata->deity->npcfoe )
fight.c.backup:   los = ( int )( ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.1 );
fight.c.backup:   if( ch->level < LEVEL_AVATAR && number_bits( 3 ) == 1 )
fight.c.backup:         if( ch->level > 1 )
handler.c:      else if( !ch->in_room )
handler.c:         first = ptr = ch->in_room->first_person;
handler.c:         first = ptr = ch->in_room->last_person;
handler.c:   return ch->exp;
handler.c:   wexp = ch->level * ch->level * ch->level * 5;
handler.c:   wexp += ch->max_hit;
handler.c:   wexp -= ( ch->armor - 50 ) * 2;
handler.c:   wexp += ( ch->barenumdie * ch->baresizedie + GET_DAMROLL( ch ) ) * 50;
handler.c:   wexp += GET_HITROLL( ch ) * ch->level * 10;
handler.c:   return class_table[ch->Class]->exp_base;
handler.c:   if( ch->desc && ch->desc->original )
handler.c:      ch = ch->desc->original;
handler.c:   if( ch->trust != 0 )
handler.c:      return ch->trust;
handler.c:   if( IS_NPC( ch ) && ch->level >= LEVEL_AVATAR )
handler.c:   return ch->level;
handler.c:   ch_days = ( ch->pcdata->month + 1 ) * sysdata.dayspermonth;
handler.c:   ch_days += ch->pcdata->day;
handler.c:   age = time_info.year - ch->pcdata->year;
handler.c:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_STR )
handler.c:   else if( class_table[ch->Class]->attr_second == APPLY_STR )
handler.c:   else if( class_table[ch->Class]->attr_deficient == APPLY_STR )
handler.c:   return URANGE( 3, ch->perm_str + ch->mod_str, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_INT )
handler.c:   else if( class_table[ch->Class]->attr_second == APPLY_INT )
handler.c:   else if( class_table[ch->Class]->attr_deficient == APPLY_INT )
handler.c:   return URANGE( 3, ch->perm_int + ch->mod_int, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_WIS )
handler.c:   else if( class_table[ch->Class]->attr_second == APPLY_WIS )
handler.c:   else if( class_table[ch->Class]->attr_deficient == APPLY_WIS )
handler.c:   return URANGE( 3, ch->perm_wis + ch->mod_wis, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_DEX )
handler.c:   else if( class_table[ch->Class]->attr_second == APPLY_DEX )
handler.c:   else if( class_table[ch->Class]->attr_deficient == APPLY_DEX )
handler.c:   return URANGE( 3, ch->perm_dex + ch->mod_dex, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_CON )
handler.c:   else if( class_table[ch->Class]->attr_second == APPLY_CON )
handler.c:   else if( class_table[ch->Class]->attr_deficient == APPLY_CON )
handler.c:   return URANGE( 3, ch->perm_con + ch->mod_con, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_CHA )
handler.c:   else if( class_table[ch->Class]->attr_second == APPLY_CHA )
handler.c:   else if( class_table[ch->Class]->attr_deficient == APPLY_CHA )
handler.c:   return URANGE( 3, ch->perm_cha + ch->mod_cha, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_LCK )
handler.c:   else if( class_table[ch->Class]->attr_second == APPLY_LCK )
handler.c:   else if( class_table[ch->Class]->attr_deficient == APPLY_LCK )
handler.c:   return URANGE( 3, ch->perm_lck + ch->mod_lck, max );
handler.c:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_IMMORTAL ) )
handler.c:      return ch->level * 200;
handler.c:   return URANGE( 5, ( ch->level + 15 ) / 5 + get_curr_dex( ch ) - 13 - penalty, 20 );
handler.c:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_IMMORTAL ) )
handler.c:   else if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_PROTOTYPE ) )
handler.c:         ch->pcdata->learned[sn] += mod;
handler.c:         ch->pcdata->learned[sn] = URANGE( 0, ch->pcdata->learned[sn] + mod, GET_ADEPT( ch, sn ) );
handler.c:      xSET_BITS( ch->affected_by, paf->bitvector );
handler.c:            xSET_BIT( ch->affected_by, AFF_RECURRINGSPELL );
handler.c:            bug( "affect_modify(%s) APPLY_RECURRINGSPELL with bad sn %d", ch->name, mod );
handler.c:      xREMOVE_BITS( ch->affected_by, paf->bitvector );
handler.c:            bug( "affect_modify(%s) APPLY_RECURRINGSPELL with bad sn %d", ch->name, mod );
handler.c:         xREMOVE_BIT( ch->affected_by, AFF_RECURRINGSPELL );
handler.c:            REMOVE_BIT( ch->affected_by.bits[0], mod );
handler.c:            xREMOVE_BIT( ch->affected_by, mod );
handler.c:            REMOVE_BIT( ch->resistant, mod );
handler.c:            REMOVE_BIT( ch->immune, mod );
handler.c:            REMOVE_BIT( ch->susceptible, mod );
handler.c:            SET_BIT( ch->affected_by.bits[0], mod );
handler.c:         bug( "%s: unknown location %d. (%s)", __func__, paf->location, ch->name );
handler.c:         ch->mod_str += mod;
handler.c:         ch->mod_dex += mod;
handler.c:         ch->mod_int += mod;
handler.c:         ch->mod_wis += mod;
handler.c:         ch->mod_con += mod;
handler.c:         ch->mod_cha += mod;
handler.c:         ch->mod_lck += mod;
handler.c:         ch->sex = ( ch->sex + mod ) % 3;
handler.c:         if( ch->sex < 0 )
handler.c:            ch->sex += 2;
handler.c:         ch->sex = URANGE( 0, ch->sex, 2 );
handler.c:         ch->height += mod;
handler.c:         ch->weight += mod;
handler.c:         ch->max_mana += mod;
handler.c:         ch->max_hit += mod;
handler.c:         ch->max_move += mod;
handler.c:         ch->armor += mod;
handler.c:         ch->hitroll += mod;
handler.c:         ch->damroll += mod;
handler.c:         ch->saving_poison_death += mod;
handler.c:         ch->saving_wand += mod;
handler.c:         ch->saving_para_petri += mod;
handler.c:         ch->saving_breath += mod;
handler.c:         ch->saving_spell_staff += mod;
handler.c:         SET_BIT( ch->affected_by.bits[0], mod );
handler.c:         xSET_BIT( ch->affected_by, mod );
handler.c:         SET_BIT( ch->resistant, mod );
handler.c:         SET_BIT( ch->immune, mod );
handler.c:         SET_BIT( ch->susceptible, mod );
handler.c:         REMOVE_BIT( ch->affected_by.bits[0], mod );
handler.c:            ch->pcdata->condition[COND_FULL] = URANGE( 0, ch->pcdata->condition[COND_FULL] + mod, 48 );
handler.c:            ch->pcdata->condition[COND_THIRST] = URANGE( 0, ch->pcdata->condition[COND_THIRST] + mod, 48 );
handler.c:            ch->pcdata->condition[COND_DRUNK] = URANGE( 0, ch->pcdata->condition[COND_DRUNK] + mod, 48 );
handler.c:            ch->pcdata->condition[COND_BLOODTHIRST] =
handler.c:               URANGE( 0, ch->pcdata->condition[COND_BLOODTHIRST] + mod, ch->level + 10 );
handler.c:         ch->mental_state = URANGE( -100, ch->mental_state + mod, 100 );
handler.c:         ch->emotional_state = URANGE( -100, ch->emotional_state + mod, 100 );
handler.c:         if( xIS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) || IS_SET( ch->immune, RIS_MAGIC )
handler.c:            if( ( retcode = ( *skill->spell_fun ) ( mod, ch->level, ch, ch ) ) == rCHAR_DIED || char_died( ch ) )
handler.c:      bug( "%s (%s, NULL)", __func__, ch->name );
handler.c:   LINK( paf_new, ch->first_affect, ch->last_affect, next, prev );
handler.c:   if( ch->in_room )
handler.c:      room_affect( ch->in_room, paf_new, TRUE );
handler.c:   if( !ch->first_affect )
handler.c:      bug( "%s (%s, %d): no affect.", __func__, ch->name, paf ? paf->type : 0 );
handler.c:   if( ch->in_room )
handler.c:      room_affect( ch->in_room, paf, FALSE );
handler.c:   UNLINK( paf, ch->first_affect, ch->last_affect, next, prev );
handler.c:   for( paf = ch->first_affect; paf; paf = paf_next )
handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c:   for( paf_old = ch->first_affect; paf_old; paf_old = paf_old->next )
handler.c:   xSET_BITS( ch->affected_by, paf->bitvector );
handler.c:         SET_BIT( ch->affected_by.bits[0], paf->modifier );
handler.c:         SET_BIT( ch->resistant, paf->modifier );
handler.c:         SET_BIT( ch->susceptible, paf->modifier );
handler.c:         SET_BIT( ch->immune, paf->modifier );
handler.c:   xCLEAR_BITS( ch->affected_by );
handler.c:   ch->resistant = 0;
handler.c:   ch->immune = 0;
handler.c:   ch->susceptible = 0;
handler.c:   xCLEAR_BITS( ch->no_affected_by );
handler.c:   ch->no_resistant = 0;
handler.c:   ch->no_immune = 0;
handler.c:   ch->no_susceptible = 0;
handler.c:   xSET_BITS( ch->affected_by, race_table[ch->race]->affected );
handler.c:   SET_BIT( ch->resistant, race_table[ch->race]->resist );
handler.c:   SET_BIT( ch->susceptible, race_table[ch->race]->suscept );
handler.c:   xSET_BITS( ch->affected_by, class_table[ch->Class]->affected );
handler.c:   SET_BIT( ch->resistant, class_table[ch->Class]->resist );
handler.c:   SET_BIT( ch->susceptible, class_table[ch->Class]->suscept );
handler.c:   if( ch->pcdata->deity )
handler.c:      if( ch->pcdata->favor > ch->pcdata->deity->affectednum )
handler.c:         xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
handler.c:      if( ch->pcdata->favor > ch->pcdata->deity->elementnum )
handler.c:         SET_BIT( ch->resistant, ch->pcdata->deity->element );
handler.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
handler.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c:   if( ch->in_room )
handler.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:   if( ch->in_room ) /* non-existant char booboo-fix --TRI */
handler.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c:   if( ch->morph )
handler.c:      xSET_BITS( ch->affected_by, ch->morph->affected_by );
handler.c:      SET_BIT( ch->immune, ch->morph->immune );
handler.c:      SET_BIT( ch->resistant, ch->morph->resistant );
handler.c:      SET_BIT( ch->susceptible, ch->morph->suscept );
handler.c:      xSET_BITS( ch->no_affected_by, ch->morph->no_affected_by );
handler.c:      SET_BIT( ch->no_immune, ch->morph->no_immune );
handler.c:      SET_BIT( ch->no_resistant, ch->morph->no_resistant );
handler.c:      SET_BIT( ch->no_susceptible, ch->morph->no_suscept );
handler.c:      xSET_BIT( ch->affected_by, AFF_HIDE );
handler.c:   if( !ch->in_room )
handler.c:      --ch->in_room->area->nplayer;
handler.c:       && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room->light > 0 )
handler.c:      --ch->in_room->light;
handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c:      room_affect( ch->in_room, paf, FALSE );
handler.c:   for( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c:   for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
handler.c:   UNLINK( ch, ch->in_room->first_person, ch->in_room->last_person, next_in_room, prev_in_room );
handler.c:   ch->was_in_room = ch->in_room;
handler.c:   ch->in_room = NULL;
handler.c:   ch->next_in_room = NULL;
handler.c:   ch->prev_in_room = NULL;
handler.c:      bug( "%s: %s -> NULL room!  Putting char in limbo (%d)", __func__, ch->name, ROOM_VNUM_LIMBO );
handler.c:   ch->in_room = pRoomIndex;
handler.c:   if( ch->home_vnum < 1 )
handler.c:      ch->home_vnum = ch->in_room->vnum;
handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c:   if( !ch->was_in_room )
handler.c:      ch->was_in_room = ch->in_room;
handler.c:      if( !IS_IMMORTAL( ch ) && ( !IS_NPC( ch ) || !xIS_SET( ch->act, ACT_PROTOTYPE ) ) )
handler.c:         return obj_to_room( obj, ch->in_room );
handler.c:   if( IS_NPC( ch ) && ch->pIndexData->pShop )
handler.c:      for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
handler.c:      if( !IS_NPC( ch ) || !ch->pIndexData->pShop )
handler.c:         LINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c:         for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
handler.c:               INSERT( obj, otmp, ch->first_carrying, next_content, prev_content );
handler.c:               INSERT( obj, otmp, ch->first_carrying, next_content, prev_content );
handler.c:            LINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c:      ch->carry_number += onum;
handler.c:      ch->carry_weight += oweight;
handler.c:      ch->carry_weight += oweight;
handler.c:   UNLINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c:   ch->carry_number -= get_obj_number( obj );
handler.c:   ch->carry_weight -= get_obj_weight( obj );
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:      bug( "%s: %s already equipped (%d).", __func__, ch->name, iWear );
handler.c:      obj = obj_to_room( obj, ch->in_room );
handler.c:   ch->armor -= apply_ac( obj, iWear );
handler.c:   ch->carry_number -= get_obj_number( obj );
handler.c:      ch->carry_weight -= get_obj_weight( obj );
handler.c:       && obj->item_type == ITEM_LIGHT && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room )
handler.c:      ++ch->in_room->light;
handler.c:   ch->carry_number += get_obj_number( obj );
handler.c:      ch->carry_weight += get_obj_weight( obj );
handler.c:   ch->armor += apply_ac( obj, obj->wear_loc );
handler.c:       && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room && ch->in_room->light > 0 )
handler.c:      --ch->in_room->light;
handler.c:   if( !ch->in_room )
handler.c:      bug( "%s: %s in NULL room.", __func__, ch->name ? ch->name : "???" );
handler.c:      bug( "%s: %s already died!", __func__, ch->name );
handler.c:   if( ch->mount )
handler.c:      xREMOVE_BIT( ch->mount->act, ACT_MOUNTED );
handler.c:      ch->mount = NULL;
handler.c:      ch->position = POS_STANDING;
handler.c:      xREMOVE_BIT( ch->act, ACT_MOUNTED );
handler.c:      for( wch = first_char; wch; wch = wch->next )
handler.c:         if( wch->mount == ch )
handler.c:            wch->mount = NULL;
handler.c:            wch->position = POS_STANDING;
handler.c:            if( wch->in_room == ch->in_room )
handler.c:         if( wch->pcdata && wch->pcdata->pet == ch )
handler.c:            wch->pcdata->pet = NULL;
handler.c:            if( wch->in_room == ch->in_room )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj_prev )
handler.c:      if( !IS_NPC( ch ) && ch->pcdata->clan )
handler.c:         location = get_room_index( ch->pcdata->clan->recall );
handler.c:         snprintf( buf, MAX_STRING_LENGTH, "Welcome back to the land of the living, %s", capitalize( ch->name ) );
handler.c:      ch->position = POS_RESTING;
handler.c:      --ch->pIndexData->count;
handler.c:   if( ch->desc && ch->desc->original )
handler.c:   if( ch->switched && ch->switched->desc )
handler.c:      do_return( ch->switched, "" );
handler.c:   for( wch = first_char; wch; wch = wch->next )
handler.c:      if( wch->reply == ch )
handler.c:         wch->reply = NULL;
handler.c:      if( wch->retell == ch )
handler.c:         wch->retell = NULL;
handler.c:   if( ch->desc )
handler.c:      if( ch->desc->character != ch )
handler.c:         ch->desc->character = NULL;
handler.c:         close_socket( ch->desc, FALSE );
handler.c:         ch->desc = NULL;
handler.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c:      if( can_see( ch, rch ) && ( nifty_is_name( arg, rch->name ) || ( IS_NPC( rch ) && vnum == rch->pIndexData->vnum ) ) )
handler.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c:      if( !can_see( ch, rch ) || !nifty_is_name_prefix( arg, rch->name ) )
handler.c:   for( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c:      if( can_see( ch, wch ) && ( nifty_is_name( arg, wch->name ) || ( IS_NPC( wch ) && vnum == wch->pIndexData->vnum ) ) )
handler.c:   for( wch = first_char; wch; wch = wch->next )
handler.c:      if( can_see( ch, wch ) && ( nifty_is_name( arg, wch->name ) || ( IS_NPC( wch ) && vnum == wch->pIndexData->vnum ) ) )
handler.c:   for( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c:      if( !can_see( ch, wch ) || !nifty_is_name_prefix( arg, wch->name ) )
handler.c:   for( wch = first_char; wch; wch = wch->next )
handler.c:      if( !can_see( ch, wch ) || !nifty_is_name_prefix( arg, wch->name ) )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   obj = get_obj_list_rev( ch, argument, ch->in_room->last_content );
handler.c:   int ms = ch->mental_state;
handler.c:   int drunk = IS_NPC( ch ) ? 0 : ch->pcdata->condition[COND_DRUNK];
handler.c:   for( rch = pRoomIndex->first_person; rch; rch = rch->next_in_room )
handler.c:      if( !IS_NPC( rch ) && rch->pcdata && IS_IMMORTAL( rch )
handler.c:          && IS_SET( rch->pcdata->flags, PCFLAG_DND ) && get_trust( ch ) < get_trust( rch ) && can_see( ch, rch ) )
handler.c:   for( rch = pRoomIndex->first_person; rch; rch = rch->next_in_room )
handler.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c:      if( room_is_dark( ch->in_room ) && !IS_AFFECTED( ch, AFF_INFRARED ) )
handler.c:      if( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, "Newbie Council" ) )
handler.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c:   if( IS_NPC( ch ) && ch->pIndexData->vnum == MOB_VNUM_SUPERMOB )
handler.c:   if( room_is_dark( ch->in_room ) )
handler.c:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c:   if( IS_NPC( ch ) && ch->pIndexData->vnum == MOB_VNUM_SUPERMOB )
handler.c:   if( !ch->in_room || !ch->in_room->first_content )
handler.c:   for( check = ch->in_room->first_content; check; check = check->next_content )
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:         for( vch = room->first_person; vch; vch = vch->next )
handler.c:         for( vch = room->first_person; vch; vch = vch->next )
handler.c:   ch->perm_str = UMIN( 18, ch->perm_str );
handler.c:   ch->perm_wis = UMIN( 18, ch->perm_wis );
handler.c:   ch->perm_dex = UMIN( 18, ch->perm_dex );
handler.c:   ch->perm_int = UMIN( 18, ch->perm_int );
handler.c:   ch->perm_con = UMIN( 18, ch->perm_con );
handler.c:   ch->perm_cha = UMIN( 18, ch->perm_cha );
handler.c:   ch->perm_lck = UMIN( 18, ch->perm_lck );
handler.c:   ch->perm_str = UMAX( 9, ch->perm_str );
handler.c:   ch->perm_wis = UMAX( 9, ch->perm_wis );
handler.c:   ch->perm_dex = UMAX( 9, ch->perm_dex );
handler.c:   ch->perm_int = UMAX( 9, ch->perm_int );
handler.c:   ch->perm_con = UMAX( 9, ch->perm_con );
handler.c:   ch->perm_cha = UMAX( 9, ch->perm_cha );
handler.c:   ch->perm_lck = UMAX( 9, ch->perm_lck );
handler.c:   for( x = 0; x < strlen( ch->name ); x++ )
handler.c:      c = ch->name[x] + x;
handler.c:            ch->perm_str = UMIN( 18, ch->perm_str + a );
handler.c:            ch->perm_dex = UMIN( 18, ch->perm_dex + a );
handler.c:            ch->perm_wis = UMIN( 18, ch->perm_wis + a );
handler.c:            ch->perm_int = UMIN( 18, ch->perm_int + a );
handler.c:            ch->perm_con = UMIN( 18, ch->perm_con + a );
handler.c:            ch->perm_cha = UMIN( 18, ch->perm_cha + a );
handler.c:            ch->perm_lck = UMIN( 18, ch->perm_lck + a );
handler.c:            ch->perm_str = UMAX( 9, ch->perm_str - a );
handler.c:            ch->perm_dex = UMAX( 9, ch->perm_dex - a );
handler.c:            ch->perm_wis = UMAX( 9, ch->perm_wis - a );
handler.c:            ch->perm_int = UMAX( 9, ch->perm_int - a );
handler.c:            ch->perm_con = UMAX( 9, ch->perm_con - a );
handler.c:            ch->perm_cha = UMAX( 9, ch->perm_cha - a );
handler.c:            ch->perm_lck = UMAX( 9, ch->perm_lck - a );
handler.c:   for( aff = ch->first_affect; aff; aff = aff->next )
handler.c:   if( ch->in_room )
handler.c:      for( aff = ch->in_room->first_affect; aff; aff = aff->next )
handler.c:      for( aff = ch->in_room->first_permaffect; aff; aff = aff->next )
handler.c:   xCLEAR_BITS( ch->affected_by );
handler.c:   xSET_BITS( ch->affected_by, race_table[ch->race]->affected );
handler.c:   ch->mental_state = -10;
handler.c:   ch->hit = UMAX( 1, ch->hit );
handler.c:   ch->mana = UMAX( 1, ch->mana );
handler.c:   ch->move = UMAX( 1, ch->move );
handler.c:   ch->armor = 100;
handler.c:   ch->mod_str = 0;
handler.c:   ch->mod_dex = 0;
handler.c:   ch->mod_wis = 0;
handler.c:   ch->mod_int = 0;
handler.c:   ch->mod_con = 0;
handler.c:   ch->mod_cha = 0;
handler.c:   ch->mod_lck = 0;
handler.c:   ch->damroll = 0;
handler.c:   ch->hitroll = 0;
handler.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
handler.c:   ch->saving_breath = 0;
handler.c:   ch->saving_wand = 0;
handler.c:   ch->saving_para_petri = 0;
handler.c:   ch->saving_spell_staff = 0;
handler.c:   ch->saving_poison_death = 0;
handler.c:   for( aff = ch->first_affect; aff; aff = aff->next )
handler.c:   if( ch->in_room )
handler.c:      for( aff = ch->in_room->first_affect; aff; aff = aff->next )
handler.c:      for( aff = ch->in_room->first_permaffect; aff; aff = aff->next )
handler.c:   ch->carry_weight = 0;
handler.c:   ch->carry_number = 0;
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:         ch->carry_number += get_obj_number( obj );
handler.c:         ch->carry_weight += get_obj_weight( obj );
handler.c:   cur_room = ch->in_room;
handler.c:   ccd->room = ch->in_room;
handler.c:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c:      LINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c:   UNLINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c:   else if( ch->level >= tarea->low_soft_range || ch->level <= tarea->hi_soft_range )
handler.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
handler.c:       || victim->level >= ch->level + 15
handler.c:       || ( IS_NPC( victim ) && saves_spell_staff( ch->level, victim ) )
handler.c:   else if( ch->level >= tarea->low_hard_range && ch->level <= tarea->hi_hard_range )
handler.c:    clan_factor = 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) / 1000; 
handler.c:      deity_factor = ch->pcdata->favor / -500;
handler.c:   ms = 10 - abs( ch->mental_state );
handler.c:      deity_factor = ch->pcdata->favor / -500;
handler.c:   if( ch->mental_state < 0 )
handler.c:      ch->mental_state = URANGE( -100, ch->mental_state + c, 0 );
handler.c:   else if( ch->mental_state > 0 )
handler.c:      ch->mental_state = URANGE( 0, ch->mental_state - c, 100 );
handler.c:   if( !IS_NPC( ch ) && ch->pcdata->nuisance && ch->pcdata->nuisance->flags > 2 )
handler.c:      c += ( int )( .4 * ( ( ch->pcdata->nuisance->flags - 2 ) * ch->pcdata->nuisance->power ) );
handler.c:   if( ch->mental_state < 0 )
handler.c:      ch->mental_state = URANGE( -100, ch->mental_state - c, 100 );
handler.c:   else if( ch->mental_state > 0 )
handler.c:      ch->mental_state = URANGE( -100, ch->mental_state + c, 100 );
handler.c:      ch->mental_state -= c;
handler.c:   track = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
handler.c:      if( ch->pcdata->killed[x].vnum == vnum )
handler.c:         if( ch->pcdata->killed[x].count < 50 )
handler.c:            ++ch->pcdata->killed[x].count;
handler.c:      else if( ch->pcdata->killed[x].vnum == 0 )
handler.c:   memmove( ( char * )ch->pcdata->killed + sizeof( KILLED_DATA ),
handler.c:            ch->pcdata->killed, ( track - 1 ) * sizeof( KILLED_DATA ) );
handler.c:   ch->pcdata->killed[0].vnum = vnum;
handler.c:   ch->pcdata->killed[0].count = 1;
handler.c:      ch->pcdata->killed[track].vnum = 0;
handler.c:   track = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
handler.c:      if( ch->pcdata->killed[x].vnum == vnum )
handler.c:         return ch->pcdata->killed[x].count;
handler.c:      else if( ch->pcdata->killed[x].vnum == 0 )
handler.c:   for( ch = first_char; ch; ch = ch->next )
handler.c:   if( !ch->switched )
handler.c:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->bestowments && is_name( cmd->name, ch->pcdata->bestowments )
handler.c:      set_char_color( AT_BLUE, ch->switched );
handler.c:      send_to_char( "You suddenly forfeit the power to switch!\n\r", ch->switched );
handler.c:   do_return( ch->switched, "" );
handler.c.backup:      else if( !ch->in_room )
handler.c.backup:         first = ptr = ch->in_room->first_person;
handler.c.backup:         first = ptr = ch->in_room->last_person;
handler.c.backup:   return ch->exp;
handler.c.backup:   wexp = ch->level * ch->level * ch->level * 5;
handler.c.backup:   wexp += ch->max_hit;
handler.c.backup:   wexp -= ( ch->armor - 50 ) * 2;
handler.c.backup:   wexp += ( ch->barenumdie * ch->baresizedie + GET_DAMROLL( ch ) ) * 50;
handler.c.backup:   wexp += GET_HITROLL( ch ) * ch->level * 10;
handler.c.backup:   return class_table[ch->Class]->exp_base;
handler.c.backup:   if( ch->desc && ch->desc->original )
handler.c.backup:      ch = ch->desc->original;
handler.c.backup:   if( ch->trust != 0 )
handler.c.backup:      return ch->trust;
handler.c.backup:   if( IS_NPC( ch ) && ch->level >= LEVEL_AVATAR )
handler.c.backup:   return ch->level;
handler.c.backup:   ch_days = ( ch->pcdata->month + 1 ) * sysdata.dayspermonth;
handler.c.backup:   ch_days += ch->pcdata->day;
handler.c.backup:   age = time_info.year - ch->pcdata->year;
handler.c.backup:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_STR )
handler.c.backup:   else if( class_table[ch->Class]->attr_second == APPLY_STR )
handler.c.backup:   else if( class_table[ch->Class]->attr_deficient == APPLY_STR )
handler.c.backup:   return URANGE( 3, ch->perm_str + ch->mod_str, max );
handler.c.backup:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_INT )
handler.c.backup:   else if( class_table[ch->Class]->attr_second == APPLY_INT )
handler.c.backup:   else if( class_table[ch->Class]->attr_deficient == APPLY_INT )
handler.c.backup:   return URANGE( 3, ch->perm_int + ch->mod_int, max );
handler.c.backup:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_WIS )
handler.c.backup:   else if( class_table[ch->Class]->attr_second == APPLY_WIS )
handler.c.backup:   else if( class_table[ch->Class]->attr_deficient == APPLY_WIS )
handler.c.backup:   return URANGE( 3, ch->perm_wis + ch->mod_wis, max );
handler.c.backup:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_DEX )
handler.c.backup:   else if( class_table[ch->Class]->attr_second == APPLY_DEX )
handler.c.backup:   else if( class_table[ch->Class]->attr_deficient == APPLY_DEX )
handler.c.backup:   return URANGE( 3, ch->perm_dex + ch->mod_dex, max );
handler.c.backup:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_CON )
handler.c.backup:   else if( class_table[ch->Class]->attr_second == APPLY_CON )
handler.c.backup:   else if( class_table[ch->Class]->attr_deficient == APPLY_CON )
handler.c.backup:   return URANGE( 3, ch->perm_con + ch->mod_con, max );
handler.c.backup:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_CHA )
handler.c.backup:   else if( class_table[ch->Class]->attr_second == APPLY_CHA )
handler.c.backup:   else if( class_table[ch->Class]->attr_deficient == APPLY_CHA )
handler.c.backup:   return URANGE( 3, ch->perm_cha + ch->mod_cha, max );
handler.c.backup:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_LCK )
handler.c.backup:   else if( class_table[ch->Class]->attr_second == APPLY_LCK )
handler.c.backup:   else if( class_table[ch->Class]->attr_deficient == APPLY_LCK )
handler.c.backup:   return URANGE( 3, ch->perm_lck + ch->mod_lck, max );
handler.c.backup:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c.backup:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_IMMORTAL ) )
handler.c.backup:      return ch->level * 200;
handler.c.backup:   return URANGE( 5, ( ch->level + 15 ) / 5 + get_curr_dex( ch ) - 13 - penalty, 20 );
handler.c.backup:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c.backup:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_IMMORTAL ) )
handler.c.backup:   else if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_PROTOTYPE ) )
handler.c.backup:         ch->pcdata->learned[sn] += mod;
handler.c.backup:         ch->pcdata->learned[sn] = URANGE( 0, ch->pcdata->learned[sn] + mod, GET_ADEPT( ch, sn ) );
handler.c.backup:      xSET_BITS( ch->affected_by, paf->bitvector );
handler.c.backup:            xSET_BIT( ch->affected_by, AFF_RECURRINGSPELL );
handler.c.backup:            bug( "affect_modify(%s) APPLY_RECURRINGSPELL with bad sn %d", ch->name, mod );
handler.c.backup:      xREMOVE_BITS( ch->affected_by, paf->bitvector );
handler.c.backup:            bug( "affect_modify(%s) APPLY_RECURRINGSPELL with bad sn %d", ch->name, mod );
handler.c.backup:         xREMOVE_BIT( ch->affected_by, AFF_RECURRINGSPELL );
handler.c.backup:            REMOVE_BIT( ch->affected_by.bits[0], mod );
handler.c.backup:            xREMOVE_BIT( ch->affected_by, mod );
handler.c.backup:            REMOVE_BIT( ch->resistant, mod );
handler.c.backup:            REMOVE_BIT( ch->immune, mod );
handler.c.backup:            REMOVE_BIT( ch->susceptible, mod );
handler.c.backup:            SET_BIT( ch->affected_by.bits[0], mod );
handler.c.backup:         bug( "%s: unknown location %d. (%s)", __func__, paf->location, ch->name );
handler.c.backup:         ch->mod_str += mod;
handler.c.backup:         ch->mod_dex += mod;
handler.c.backup:         ch->mod_int += mod;
handler.c.backup:         ch->mod_wis += mod;
handler.c.backup:         ch->mod_con += mod;
handler.c.backup:         ch->mod_cha += mod;
handler.c.backup:         ch->mod_lck += mod;
handler.c.backup:         ch->sex = ( ch->sex + mod ) % 3;
handler.c.backup:         if( ch->sex < 0 )
handler.c.backup:            ch->sex += 2;
handler.c.backup:         ch->sex = URANGE( 0, ch->sex, 2 );
handler.c.backup:         ch->height += mod;
handler.c.backup:         ch->weight += mod;
handler.c.backup:         ch->max_mana += mod;
handler.c.backup:         ch->max_hit += mod;
handler.c.backup:         ch->max_move += mod;
handler.c.backup:         ch->armor += mod;
handler.c.backup:         ch->hitroll += mod;
handler.c.backup:         ch->damroll += mod;
handler.c.backup:         ch->saving_poison_death += mod;
handler.c.backup:         ch->saving_wand += mod;
handler.c.backup:         ch->saving_para_petri += mod;
handler.c.backup:         ch->saving_breath += mod;
handler.c.backup:         ch->saving_spell_staff += mod;
handler.c.backup:         SET_BIT( ch->affected_by.bits[0], mod );
handler.c.backup:         xSET_BIT( ch->affected_by, mod );
handler.c.backup:         SET_BIT( ch->resistant, mod );
handler.c.backup:         SET_BIT( ch->immune, mod );
handler.c.backup:         SET_BIT( ch->susceptible, mod );
handler.c.backup:         REMOVE_BIT( ch->affected_by.bits[0], mod );
handler.c.backup:            ch->pcdata->condition[COND_FULL] = URANGE( 0, ch->pcdata->condition[COND_FULL] + mod, 48 );
handler.c.backup:            ch->pcdata->condition[COND_THIRST] = URANGE( 0, ch->pcdata->condition[COND_THIRST] + mod, 48 );
handler.c.backup:            ch->pcdata->condition[COND_DRUNK] = URANGE( 0, ch->pcdata->condition[COND_DRUNK] + mod, 48 );
handler.c.backup:            ch->pcdata->condition[COND_BLOODTHIRST] =
handler.c.backup:               URANGE( 0, ch->pcdata->condition[COND_BLOODTHIRST] + mod, ch->level + 10 );
handler.c.backup:         ch->mental_state = URANGE( -100, ch->mental_state + mod, 100 );
handler.c.backup:         ch->emotional_state = URANGE( -100, ch->emotional_state + mod, 100 );
handler.c.backup:         if( xIS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) || IS_SET( ch->immune, RIS_MAGIC )
handler.c.backup:            if( ( retcode = ( *skill->spell_fun ) ( mod, ch->level, ch, ch ) ) == rCHAR_DIED || char_died( ch ) )
handler.c.backup:      bug( "%s (%s, NULL)", __func__, ch->name );
handler.c.backup:   LINK( paf_new, ch->first_affect, ch->last_affect, next, prev );
handler.c.backup:   if( ch->in_room )
handler.c.backup:      room_affect( ch->in_room, paf_new, TRUE );
handler.c.backup:   if( !ch->first_affect )
handler.c.backup:      bug( "%s (%s, %d): no affect.", __func__, ch->name, paf ? paf->type : 0 );
handler.c.backup:   if( ch->in_room )
handler.c.backup:      room_affect( ch->in_room, paf, FALSE );
handler.c.backup:   UNLINK( paf, ch->first_affect, ch->last_affect, next, prev );
handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf_next )
handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c.backup:   for( paf_old = ch->first_affect; paf_old; paf_old = paf_old->next )
handler.c.backup:   xSET_BITS( ch->affected_by, paf->bitvector );
handler.c.backup:         SET_BIT( ch->affected_by.bits[0], paf->modifier );
handler.c.backup:         SET_BIT( ch->resistant, paf->modifier );
handler.c.backup:         SET_BIT( ch->susceptible, paf->modifier );
handler.c.backup:         SET_BIT( ch->immune, paf->modifier );
handler.c.backup:   xCLEAR_BITS( ch->affected_by );
handler.c.backup:   ch->resistant = 0;
handler.c.backup:   ch->immune = 0;
handler.c.backup:   ch->susceptible = 0;
handler.c.backup:   xCLEAR_BITS( ch->no_affected_by );
handler.c.backup:   ch->no_resistant = 0;
handler.c.backup:   ch->no_immune = 0;
handler.c.backup:   ch->no_susceptible = 0;
handler.c.backup:   xSET_BITS( ch->affected_by, race_table[ch->race]->affected );
handler.c.backup:   SET_BIT( ch->resistant, race_table[ch->race]->resist );
handler.c.backup:   SET_BIT( ch->susceptible, race_table[ch->race]->suscept );
handler.c.backup:   xSET_BITS( ch->affected_by, class_table[ch->Class]->affected );
handler.c.backup:   SET_BIT( ch->resistant, class_table[ch->Class]->resist );
handler.c.backup:   SET_BIT( ch->susceptible, class_table[ch->Class]->suscept );
handler.c.backup:   if( ch->pcdata->deity )
handler.c.backup:      if( ch->pcdata->favor > ch->pcdata->deity->affectednum )
handler.c.backup:         xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
handler.c.backup:      if( ch->pcdata->favor > ch->pcdata->deity->elementnum )
handler.c.backup:         SET_BIT( ch->resistant, ch->pcdata->deity->element );
handler.c.backup:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
handler.c.backup:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c.backup:   if( ch->in_room )
handler.c.backup:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c.backup:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
handler.c.backup:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c.backup:   if( ch->in_room ) /* non-existant char booboo-fix --TRI */
handler.c.backup:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c.backup:   if( ch->morph )
handler.c.backup:      xSET_BITS( ch->affected_by, ch->morph->affected_by );
handler.c.backup:      SET_BIT( ch->immune, ch->morph->immune );
handler.c.backup:      SET_BIT( ch->resistant, ch->morph->resistant );
handler.c.backup:      SET_BIT( ch->susceptible, ch->morph->suscept );
handler.c.backup:      xSET_BITS( ch->no_affected_by, ch->morph->no_affected_by );
handler.c.backup:      SET_BIT( ch->no_immune, ch->morph->no_immune );
handler.c.backup:      SET_BIT( ch->no_resistant, ch->morph->no_resistant );
handler.c.backup:      SET_BIT( ch->no_susceptible, ch->morph->no_suscept );
handler.c.backup:      xSET_BIT( ch->affected_by, AFF_HIDE );
handler.c.backup:   if( !ch->in_room )
handler.c.backup:      --ch->in_room->area->nplayer;
handler.c.backup:       && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room->light > 0 )
handler.c.backup:      --ch->in_room->light;
handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c.backup:      room_affect( ch->in_room, paf, FALSE );
handler.c.backup:   for( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c.backup:   for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
handler.c.backup:   UNLINK( ch, ch->in_room->first_person, ch->in_room->last_person, next_in_room, prev_in_room );
handler.c.backup:   ch->was_in_room = ch->in_room;
handler.c.backup:   ch->in_room = NULL;
handler.c.backup:   ch->next_in_room = NULL;
handler.c.backup:   ch->prev_in_room = NULL;
handler.c.backup:      bug( "%s: %s -> NULL room!  Putting char in limbo (%d)", __func__, ch->name, ROOM_VNUM_LIMBO );
handler.c.backup:   ch->in_room = pRoomIndex;
handler.c.backup:   if( ch->home_vnum < 1 )
handler.c.backup:      ch->home_vnum = ch->in_room->vnum;
handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c.backup:   if( !ch->was_in_room )
handler.c.backup:      ch->was_in_room = ch->in_room;
handler.c.backup:      if( !IS_IMMORTAL( ch ) && ( !IS_NPC( ch ) || !xIS_SET( ch->act, ACT_PROTOTYPE ) ) )
handler.c.backup:         return obj_to_room( obj, ch->in_room );
handler.c.backup:   if( IS_NPC( ch ) && ch->pIndexData->pShop )
handler.c.backup:      for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
handler.c.backup:      if( !IS_NPC( ch ) || !ch->pIndexData->pShop )
handler.c.backup:         LINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c.backup:         for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
handler.c.backup:               INSERT( obj, otmp, ch->first_carrying, next_content, prev_content );
handler.c.backup:               INSERT( obj, otmp, ch->first_carrying, next_content, prev_content );
handler.c.backup:            LINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c.backup:      ch->carry_number += onum;
handler.c.backup:      ch->carry_weight += oweight;
handler.c.backup:      ch->carry_weight += oweight;
handler.c.backup:   UNLINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c.backup:   ch->carry_number -= get_obj_number( obj );
handler.c.backup:   ch->carry_weight -= get_obj_weight( obj );
handler.c.backup:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c.backup:      bug( "%s: %s already equipped (%d).", __func__, ch->name, iWear );
handler.c.backup:      obj = obj_to_room( obj, ch->in_room );
handler.c.backup:   ch->armor -= apply_ac( obj, iWear );
handler.c.backup:   ch->carry_number -= get_obj_number( obj );
handler.c.backup:      ch->carry_weight -= get_obj_weight( obj );
handler.c.backup:       && obj->item_type == ITEM_LIGHT && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room )
handler.c.backup:      ++ch->in_room->light;
handler.c.backup:   ch->carry_number += get_obj_number( obj );
handler.c.backup:      ch->carry_weight += get_obj_weight( obj );
handler.c.backup:   ch->armor += apply_ac( obj, obj->wear_loc );
handler.c.backup:       && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room && ch->in_room->light > 0 )
handler.c.backup:      --ch->in_room->light;
handler.c.backup:   if( !ch->in_room )
handler.c.backup:      bug( "%s: %s in NULL room.", __func__, ch->name ? ch->name : "???" );
handler.c.backup:      bug( "%s: %s already died!", __func__, ch->name );
handler.c.backup:   if( ch->mount )
handler.c.backup:      xREMOVE_BIT( ch->mount->act, ACT_MOUNTED );
handler.c.backup:      ch->mount = NULL;
handler.c.backup:      ch->position = POS_STANDING;
handler.c.backup:      xREMOVE_BIT( ch->act, ACT_MOUNTED );
handler.c.backup:      for( wch = first_char; wch; wch = wch->next )
handler.c.backup:         if( wch->mount == ch )
handler.c.backup:            wch->mount = NULL;
handler.c.backup:            wch->position = POS_STANDING;
handler.c.backup:            if( wch->in_room == ch->in_room )
handler.c.backup:         if( wch->pcdata && wch->pcdata->pet == ch )
handler.c.backup:            wch->pcdata->pet = NULL;
handler.c.backup:            if( wch->in_room == ch->in_room )
handler.c.backup:   for( obj = ch->last_carrying; obj; obj = obj_prev )
handler.c.backup:      if( !IS_NPC( ch ) && ch->pcdata->clan )
handler.c.backup:         location = get_room_index( ch->pcdata->clan->recall );
handler.c.backup:         snprintf( buf, MAX_STRING_LENGTH, "Welcome back to the land of the living, %s", capitalize( ch->name ) );
handler.c.backup:      ch->position = POS_RESTING;
handler.c.backup:      --ch->pIndexData->count;
handler.c.backup:   if( ch->desc && ch->desc->original )
handler.c.backup:   if( ch->switched && ch->switched->desc )
handler.c.backup:      do_return( ch->switched, "" );
handler.c.backup:   for( wch = first_char; wch; wch = wch->next )
handler.c.backup:      if( wch->reply == ch )
handler.c.backup:         wch->reply = NULL;
handler.c.backup:      if( wch->retell == ch )
handler.c.backup:         wch->retell = NULL;
handler.c.backup:   if( ch->desc )
handler.c.backup:      if( ch->desc->character != ch )
handler.c.backup:         ch->desc->character = NULL;
handler.c.backup:         close_socket( ch->desc, FALSE );
handler.c.backup:         ch->desc = NULL;
handler.c.backup:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c.backup:      if( can_see( ch, rch ) && ( nifty_is_name( arg, rch->name ) || ( IS_NPC( rch ) && vnum == rch->pIndexData->vnum ) ) )
handler.c.backup:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c.backup:      if( !can_see( ch, rch ) || !nifty_is_name_prefix( arg, rch->name ) )
handler.c.backup:   for( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c.backup:      if( can_see( ch, wch ) && ( nifty_is_name( arg, wch->name ) || ( IS_NPC( wch ) && vnum == wch->pIndexData->vnum ) ) )
handler.c.backup:   for( wch = first_char; wch; wch = wch->next )
handler.c.backup:      if( can_see( ch, wch ) && ( nifty_is_name( arg, wch->name ) || ( IS_NPC( wch ) && vnum == wch->pIndexData->vnum ) ) )
handler.c.backup:   for( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c.backup:      if( !can_see( ch, wch ) || !nifty_is_name_prefix( arg, wch->name ) )
handler.c.backup:   for( wch = first_char; wch; wch = wch->next )
handler.c.backup:      if( !can_see( ch, wch ) || !nifty_is_name_prefix( arg, wch->name ) )
handler.c.backup:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c.backup:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c.backup:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c.backup:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c.backup:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c.backup:   obj = get_obj_list_rev( ch, argument, ch->in_room->last_content );
handler.c.backup:   int ms = ch->mental_state;
handler.c.backup:   int drunk = IS_NPC( ch ) ? 0 : ch->pcdata->condition[COND_DRUNK];
handler.c.backup:   for( rch = pRoomIndex->first_person; rch; rch = rch->next_in_room )
handler.c.backup:      if( !IS_NPC( rch ) && rch->pcdata && IS_IMMORTAL( rch )
handler.c.backup:          && IS_SET( rch->pcdata->flags, PCFLAG_DND ) && get_trust( ch ) < get_trust( rch ) && can_see( ch, rch ) )
handler.c.backup:   for( rch = pRoomIndex->first_person; rch; rch = rch->next_in_room )
handler.c.backup:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c.backup:      if( room_is_dark( ch->in_room ) && !IS_AFFECTED( ch, AFF_INFRARED ) )
handler.c.backup:      if( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, "Newbie Council" ) )
handler.c.backup:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c.backup:   if( IS_NPC( ch ) && ch->pIndexData->vnum == MOB_VNUM_SUPERMOB )
handler.c.backup:   if( room_is_dark( ch->in_room ) )
handler.c.backup:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c.backup:   if( IS_NPC( ch ) && ch->pIndexData->vnum == MOB_VNUM_SUPERMOB )
handler.c.backup:   if( !ch->in_room || !ch->in_room->first_content )
handler.c.backup:   for( check = ch->in_room->first_content; check; check = check->next_content )
handler.c.backup:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c.backup:         for( vch = room->first_person; vch; vch = vch->next )
handler.c.backup:         for( vch = room->first_person; vch; vch = vch->next )
handler.c.backup:   ch->perm_str = UMIN( 18, ch->perm_str );
handler.c.backup:   ch->perm_wis = UMIN( 18, ch->perm_wis );
handler.c.backup:   ch->perm_dex = UMIN( 18, ch->perm_dex );
handler.c.backup:   ch->perm_int = UMIN( 18, ch->perm_int );
handler.c.backup:   ch->perm_con = UMIN( 18, ch->perm_con );
handler.c.backup:   ch->perm_cha = UMIN( 18, ch->perm_cha );
handler.c.backup:   ch->perm_lck = UMIN( 18, ch->perm_lck );
handler.c.backup:   ch->perm_str = UMAX( 9, ch->perm_str );
handler.c.backup:   ch->perm_wis = UMAX( 9, ch->perm_wis );
handler.c.backup:   ch->perm_dex = UMAX( 9, ch->perm_dex );
handler.c.backup:   ch->perm_int = UMAX( 9, ch->perm_int );
handler.c.backup:   ch->perm_con = UMAX( 9, ch->perm_con );
handler.c.backup:   ch->perm_cha = UMAX( 9, ch->perm_cha );
handler.c.backup:   ch->perm_lck = UMAX( 9, ch->perm_lck );
handler.c.backup:   for( x = 0; x < strlen( ch->name ); x++ )
handler.c.backup:      c = ch->name[x] + x;
handler.c.backup:            ch->perm_str = UMIN( 18, ch->perm_str + a );
handler.c.backup:            ch->perm_dex = UMIN( 18, ch->perm_dex + a );
handler.c.backup:            ch->perm_wis = UMIN( 18, ch->perm_wis + a );
handler.c.backup:            ch->perm_int = UMIN( 18, ch->perm_int + a );
handler.c.backup:            ch->perm_con = UMIN( 18, ch->perm_con + a );
handler.c.backup:            ch->perm_cha = UMIN( 18, ch->perm_cha + a );
handler.c.backup:            ch->perm_lck = UMIN( 18, ch->perm_lck + a );
handler.c.backup:            ch->perm_str = UMAX( 9, ch->perm_str - a );
handler.c.backup:            ch->perm_dex = UMAX( 9, ch->perm_dex - a );
handler.c.backup:            ch->perm_wis = UMAX( 9, ch->perm_wis - a );
handler.c.backup:            ch->perm_int = UMAX( 9, ch->perm_int - a );
handler.c.backup:            ch->perm_con = UMAX( 9, ch->perm_con - a );
handler.c.backup:            ch->perm_cha = UMAX( 9, ch->perm_cha - a );
handler.c.backup:            ch->perm_lck = UMAX( 9, ch->perm_lck - a );
handler.c.backup:   for( aff = ch->first_affect; aff; aff = aff->next )
handler.c.backup:   if( ch->in_room )
handler.c.backup:      for( aff = ch->in_room->first_affect; aff; aff = aff->next )
handler.c.backup:      for( aff = ch->in_room->first_permaffect; aff; aff = aff->next )
handler.c.backup:   xCLEAR_BITS( ch->affected_by );
handler.c.backup:   xSET_BITS( ch->affected_by, race_table[ch->race]->affected );
handler.c.backup:   ch->mental_state = -10;
handler.c.backup:   ch->hit = UMAX( 1, ch->hit );
handler.c.backup:   ch->mana = UMAX( 1, ch->mana );
handler.c.backup:   ch->move = UMAX( 1, ch->move );
handler.c.backup:   ch->armor = 100;
handler.c.backup:   ch->mod_str = 0;
handler.c.backup:   ch->mod_dex = 0;
handler.c.backup:   ch->mod_wis = 0;
handler.c.backup:   ch->mod_int = 0;
handler.c.backup:   ch->mod_con = 0;
handler.c.backup:   ch->mod_cha = 0;
handler.c.backup:   ch->mod_lck = 0;
handler.c.backup:   ch->damroll = 0;
handler.c.backup:   ch->hitroll = 0;
handler.c.backup:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
handler.c.backup:   ch->saving_breath = 0;
handler.c.backup:   ch->saving_wand = 0;
handler.c.backup:   ch->saving_para_petri = 0;
handler.c.backup:   ch->saving_spell_staff = 0;
handler.c.backup:   ch->saving_poison_death = 0;
handler.c.backup:   for( aff = ch->first_affect; aff; aff = aff->next )
handler.c.backup:   if( ch->in_room )
handler.c.backup:      for( aff = ch->in_room->first_affect; aff; aff = aff->next )
handler.c.backup:      for( aff = ch->in_room->first_permaffect; aff; aff = aff->next )
handler.c.backup:   ch->carry_weight = 0;
handler.c.backup:   ch->carry_number = 0;
handler.c.backup:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c.backup:         ch->carry_number += get_obj_number( obj );
handler.c.backup:         ch->carry_weight += get_obj_weight( obj );
handler.c.backup:   cur_room = ch->in_room;
handler.c.backup:   ccd->room = ch->in_room;
handler.c.backup:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c.backup:      LINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c.backup:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c.backup:   UNLINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c.backup:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c.backup:   else if( ch->level >= tarea->low_soft_range || ch->level <= tarea->hi_soft_range )
handler.c.backup:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
handler.c.backup:       || victim->level >= ch->level + 15
handler.c.backup:       || ( IS_NPC( victim ) && saves_spell_staff( ch->level, victim ) )
handler.c.backup:   else if( ch->level >= tarea->low_hard_range && ch->level <= tarea->hi_hard_range )
handler.c.backup:    clan_factor = 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) / 1000; 
handler.c.backup:      deity_factor = ch->pcdata->favor / -500;
handler.c.backup:   ms = 10 - abs( ch->mental_state );
handler.c.backup:      deity_factor = ch->pcdata->favor / -500;
handler.c.backup:   if( ch->mental_state < 0 )
handler.c.backup:      ch->mental_state = URANGE( -100, ch->mental_state + c, 0 );
handler.c.backup:   else if( ch->mental_state > 0 )
handler.c.backup:      ch->mental_state = URANGE( 0, ch->mental_state - c, 100 );
handler.c.backup:   if( !IS_NPC( ch ) && ch->pcdata->nuisance && ch->pcdata->nuisance->flags > 2 )
handler.c.backup:      c += ( int )( .4 * ( ( ch->pcdata->nuisance->flags - 2 ) * ch->pcdata->nuisance->power ) );
handler.c.backup:   if( ch->mental_state < 0 )
handler.c.backup:      ch->mental_state = URANGE( -100, ch->mental_state - c, 100 );
handler.c.backup:   else if( ch->mental_state > 0 )
handler.c.backup:      ch->mental_state = URANGE( -100, ch->mental_state + c, 100 );
handler.c.backup:      ch->mental_state -= c;
handler.c.backup:   track = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
handler.c.backup:      if( ch->pcdata->killed[x].vnum == vnum )
handler.c.backup:         if( ch->pcdata->killed[x].count < 50 )
handler.c.backup:            ++ch->pcdata->killed[x].count;
handler.c.backup:      else if( ch->pcdata->killed[x].vnum == 0 )
handler.c.backup:   memmove( ( char * )ch->pcdata->killed + sizeof( KILLED_DATA ),
handler.c.backup:            ch->pcdata->killed, ( track - 1 ) * sizeof( KILLED_DATA ) );
handler.c.backup:   ch->pcdata->killed[0].vnum = vnum;
handler.c.backup:   ch->pcdata->killed[0].count = 1;
handler.c.backup:      ch->pcdata->killed[track].vnum = 0;
handler.c.backup:   track = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
handler.c.backup:      if( ch->pcdata->killed[x].vnum == vnum )
handler.c.backup:         return ch->pcdata->killed[x].count;
handler.c.backup:      else if( ch->pcdata->killed[x].vnum == 0 )
handler.c.backup:   for( ch = first_char; ch; ch = ch->next )
handler.c.backup:   if( !ch->switched )
handler.c.backup:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
handler.c.backup:         if( !IS_NPC( ch ) && ch->pcdata->bestowments && is_name( cmd->name, ch->pcdata->bestowments )
handler.c.backup:      set_char_color( AT_BLUE, ch->switched );
handler.c.backup:      send_to_char( "You suddenly forfeit the power to switch!\n\r", ch->switched );
handler.c.backup:   do_return( ch->switched, "" );
hotboot.c:      for( rch = first_char; rch; rch = rch->next )
hotboot.c:         if( !IS_NPC( rch ) || rch == supermob || xIS_SET( rch->act, ACT_PROTOTYPE ) || xIS_SET( rch->act, ACT_PET ) )
hotboot.c:   snprintf( log_buf, MAX_STRING_LENGTH, "Hotboot initiated by %s.", ch->name );
hotboot.c:   if( ch && ch->desc )
hotboot.c:      write_to_descriptor( ch->desc, "\033[0m", 0 );
hotboot.c:                  d->can_compress, och->in_room->vnum, d->port, d->idle, och->name, d->host );
hotboot.c:         och->pcdata->hotboot = TRUE;
house.c:         if( home->vnum[x] == ch->in_room->vnum )
house.c:               if( home->vnum[y] == vch->in_room->vnum )
house.c:   if( !ch || !ch->name || vnum <= 0 )
house.c:   tmphome->name = STRALLOC( ch->name );
house.c:      if( !str_cmp( home->name, ch->name ) )
house.c:   switch ( ch->substate )
house.c:         location = ( ROOM_INDEX_DATA * ) ch->dest_buf;
house.c:            bug( "%s: sub_room_desc: NULL ch->dest_buf", __func__ );
house.c:            location = ch->in_room;
house.c:         ch->substate = ch->tempnum;
house.c:      if( !str_cmp( homedata->name, ch->name ) )
house.c:         if( ch->gold >= DEFAULT_MOB_PRICE )
house.c:         ch->gold -= DEFAULT_MOB_PRICE;
house.c:         if( homedata->vnum[i] == ch->in_room->vnum )
house.c:            location = ch->in_room;
house.c:         ch->tempnum = SUB_NONE;
house.c:         ch->substate = SUB_ROOM_DESC;
house.c:         ch->dest_buf = location;
house.c:         log_printf( "%s: house desc", capitalize( ch->name ) );
house.c:         log_printf( "%s: house %s %s", capitalize( ch->name ), arg, argument );
house.c:         if( ch->gold < ADDITIONAL_ROOM_COST )
house.c:         ch->gold -= ADDITIONAL_ROOM_COST;
house.c:         log_printf( "%s: house %s %s", capitalize( ch->name ), arg, argument );
house.c:   log_printf( "%s: house %s %s", capitalize( ch->name ), arg, argument );
house.c:   if( IS_NPC( ch ) || !ch->desc )
house.c:      if( !str_cmp( home->name, ch->name ) )
house.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL ) || xIS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) )
house.c:   switch ( ch->position )
house.c:   snprintf( buf, MAX_STRING_LENGTH, "%s disappears in a vortex of luminescent light.", ch->name );
house.c:   if( ch->mount )
house.c:      char_from_room( ch->mount );
house.c:      char_to_room( ch->mount, room );
house.c:   snprintf( buf, MAX_STRING_LENGTH, "As a vortex of luminescent light forms, %s slides gracefully into their home.\r\n", ch->name );
house.c:      log_printf( "%s: accessories %s %s", capitalize( ch->name ), arg, argument );
house.c:         if( !str_cmp( home->name, ch->name ) )
house.c:      if( ch->gold < acc->price )
house.c:         if( ch->in_room->vnum == home->vnum[i] )
house.c:            location = ch->in_room;
house.c:      ch->gold -= acc->price;
house.c:         if( !str_cmp( home->name, ch->name ) )
house.c:         if( !str_cmp( checkhome->bidder, ch->name ) )
house.c:      if( !str_cmp( homeb->seller, ch->name ) )
house.c:      if( ch->gold < bid )
house.c:      homeb->bidder = STRALLOC( ch->name );
house.c:      if( !str_cmp( home->name, ch->name ) )
house.c:   if( !ch || IS_NPC( ch ) || ch->desc != NULL || ch->switched != NULL )
house.c:   if( ch->position == POS_MOUNTED )
house.c:   if( !ch->in_room || ( get_room_index( ch->in_room->vnum ) ) == NULL )
house.c:      ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
house.c:   if( sysdata.save_pets && ch->pcdata && ch->pcdata->pet )
house.c:      extract_char( ch->pcdata->pet, TRUE );
house.c:   if( ch->pcdata && ch->pcdata->clan )
house.c:      save_clan( ch->pcdata->clan );
imm_host.c:   for( i = 0; i < strlen( ch->name ); i++ )
imm_host.c:      my_name[i] = LOWER( ch->name[i] );
interp.c:   if( IS_NPC( ch ) && ch->position > 3 ) /*Band-aid alert?  -- Blod */
interp.c:   if( ch->position < position )
interp.c:      switch ( ch->position )
interp.c:            if( !found && ch->desc && get_trust( ch ) < pw->imm_level
interp.c:                     || ( pw->player_site && !str_prefix( pw->player_site, ch->desc->host ) ) ) )
interp.c:                         t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, ch->name, logline );
interp.c:         if( ( ( pw->target_name && !str_cmp( pw->target_name, ch->name ) )
interp.c:                    && !str_prefix( pw->player_site, ch->desc->host ) ) ) && get_trust( ch ) < pw->imm_level && ch->desc )
interp.c:                      t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, ch->name, logline );
interp.c:   if( !ch->in_room )
interp.c:   if( ch->substate == SUB_REPEATCMD )
interp.c:      if( ( fun = ch->last_cmd ) == NULL )
interp.c:         ch->substate = SUB_NONE;
interp.c:       * xREMOVE_BIT( ch->affected_by, AFF_HIDE ); 
interp.c:      if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_FREEZE ) )
interp.c:                  || ( !IS_NPC( ch ) && ch->pcdata->council
interp.c:                       && is_name( cmd->name, ch->pcdata->council->powers )
interp.c:                  || ( !IS_NPC( ch ) && IS_SET( ch->pcdata->flags, PCFLAG_RETIRED )
interp.c:                  || ( !IS_NPC( ch ) && ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0'
interp.c:                       && is_name( cmd->name, ch->pcdata->bestowments ) && cmd->level <= ( trust + sysdata.bestow_dif ) ) ) )
interp.c:      if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_AFK ) && ( str_cmp( command, "AFK" ) ) )
interp.c:         xREMOVE_BIT( ch->act, PLR_AFK );
interp.c:   snprintf( lastplayercmd, ( MAX_INPUT_LENGTH * 2 ), "%s used %s", ch->name, logline );
interp.c:   if( !IS_NPC( ch ) && ch->desc && valid_watch( logline ) )
interp.c:      else if( IS_SET( ch->pcdata->flags, PCFLAG_WATCH ) )
interp.c:   if( ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_LOG ) )
interp.c:      if( ch->desc && ch->desc->original )
interp.c:         snprintf( log_buf, MAX_STRING_LENGTH, "Log %s (%s): %s", ch->name, ch->desc->original->name, logline );
interp.c:         snprintf( log_buf, MAX_STRING_LENGTH, "Log %s: %s", ch->name, logline );
interp.c:      if( fLogAll && loglvl == LOG_NORMAL && ( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_LOG ) ) )
interp.c:   if( ch->desc && ch->desc->snoop_by )
interp.c:      snprintf( logname, MAX_INPUT_LENGTH, "%s", ch->name );
interp.c:      write_to_buffer( ch->desc->snoop_by, logname, 0 );
interp.c:      write_to_buffer( ch->desc->snoop_by, "% ", 2 );
interp.c:      write_to_buffer( ch->desc->snoop_by, logline, 0 );
interp.c:      write_to_buffer( ch->desc->snoop_by, "\r\n", 2 );
interp.c:      tempsub = ch->substate;
interp.c:      ch->substate = SUB_TIMER_DO_ABORT;
interp.c:      if( ch->substate != SUB_TIMER_CANT_ABORT )
interp.c:         ch->substate = tempsub;
interp.c:         ch->substate = tempsub;
interp.c:   if( !IS_NPC( ch ) && ch->pcdata->nuisance && ch->pcdata->nuisance->flags > 9
interp.c:       && number_percent(  ) < ( ( ch->pcdata->nuisance->flags - 9 ) * 10 * ch->pcdata->nuisance->power ) )
interp.c:   ch->prev_cmd = ch->last_cmd;  /* haus, for automapping */
interp.c:   ch->last_cmd = cmd->do_fun;
interp.c:      log_printf_plus( LOG_NORMAL, get_trust( ch ), "[*****] LAG: %s: %s %s (R:%d S:%ld.%06ld)", ch->name,
interp.c:                       ch->in_room ? ch->in_room->vnum : 0, time_used.tv_sec, time_used.tv_usec );
interp.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_NO_EMOTE ) )
interp.c:   switch ( ch->position )
interp.c:   room = ch->in_room;
interp.c:   for( victim = ch->in_room->first_person; victim; victim = victim_next )
interp.c:            ch_printf( victim, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see( victim, ch ) ? "Someone" : ch->name );
interp.c:   else if( ch->morph != NULL && IS_SET( cmd->flags, CMD_FLAG_POLYMORPHED ) )
liquids.c:      for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
liquids.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_DRUNK] > MAX_COND_VALUE - 8 )
liquids.c:                && ch->level > 5 && ch->pcdata->condition[COND_BLOODTHIRST] > ( 5 + ch->level / 10 ) )
liquids.c:            if( ch->pcdata->condition[COND_BLOODTHIRST] < ( 10 + ch->level ) )
liquids.c:               if( ch->pcdata->condition[COND_FULL] >= MAX_COND_VALUE
liquids.c:                   || ch->pcdata->condition[COND_THIRST] >= MAX_COND_VALUE )
liquids.c:            ch->pcdata->condition[COND_THIRST] = MAX_COND_VALUE;
liquids.c:         if( !IS_NPC( ch ) && ( ch->pcdata->condition[COND_THIRST] == MAX_COND_VALUE
liquids.c:                                || ch->pcdata->condition[COND_FULL] == MAX_COND_VALUE ) )
liquids.c:            ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
liquids.c:            if( ch->pcdata->condition[COND_DRUNK] > ( MAX_COND_VALUE / 2 )
liquids.c:                && ch->pcdata->condition[COND_DRUNK] < ( MAX_COND_VALUE * .4 ) )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] >= ( MAX_COND_VALUE * .4 )
liquids.c:                     && ch->pcdata->condition[COND_DRUNK] < ( MAX_COND_VALUE * .6 ) )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] >= ( MAX_COND_VALUE * .6 )
liquids.c:                     && ch->pcdata->condition[COND_DRUNK] < ( MAX_COND_VALUE * .9 ) )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] >= ( MAX_COND_VALUE * .9 )
liquids.c:                     && ch->pcdata->condition[COND_DRUNK] < MAX_COND_VALUE )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] == MAX_COND_VALUE )
liquids.c:            if( ch->pcdata->condition[COND_THIRST] > ( MAX_COND_VALUE / 2 )
liquids.c:                && ch->pcdata->condition[COND_THIRST] < ( MAX_COND_VALUE * .4 ) )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] >= ( MAX_COND_VALUE * .4 )
liquids.c:                     && ch->pcdata->condition[COND_THIRST] < ( MAX_COND_VALUE * .6 ) )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] >= ( MAX_COND_VALUE * .6 )
liquids.c:                     && ch->pcdata->condition[COND_THIRST] < ( MAX_COND_VALUE * .9 ) )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] >= ( MAX_COND_VALUE * .9 )
liquids.c:                     && ch->pcdata->condition[COND_THIRST] < MAX_COND_VALUE )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] == MAX_COND_VALUE )
liquids.c:               if( ch->pcdata->condition[COND_BLOODTHIRST] > ( MAX_COND_VALUE / 2 )
liquids.c:                   && ch->pcdata->condition[COND_BLOODTHIRST] < ( MAX_COND_VALUE * .4 ) )
liquids.c:               else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( MAX_COND_VALUE * .4 )
liquids.c:                        && ch->pcdata->condition[COND_BLOODTHIRST] < ( MAX_COND_VALUE * .6 ) )
liquids.c:               else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( MAX_COND_VALUE * .6 )
liquids.c:                        && ch->pcdata->condition[COND_BLOODTHIRST] < ( MAX_COND_VALUE * .9 ) )
liquids.c:               else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( MAX_COND_VALUE * .9 )
liquids.c:                        && ch->pcdata->condition[COND_BLOODTHIRST] < MAX_COND_VALUE )
liquids.c:            else if( !IS_VAMPIRE( ch ) && ch->pcdata->condition[COND_BLOODTHIRST] >= MAX_COND_VALUE )
liquids.c:               ch->pcdata->condition[COND_BLOODTHIRST] = MAX_COND_VALUE;
liquids.c:            ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
liquids.c:            if( ch->pcdata->condition[COND_DRUNK] > ( MAX_COND_VALUE / 2 )
liquids.c:                && ch->pcdata->condition[COND_DRUNK] < ( MAX_COND_VALUE * .4 ) )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] >= ( MAX_COND_VALUE * .4 )
liquids.c:                     && ch->pcdata->condition[COND_DRUNK] < ( MAX_COND_VALUE * .6 ) )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] >= ( MAX_COND_VALUE * .6 )
liquids.c:                     && ch->pcdata->condition[COND_DRUNK] < ( MAX_COND_VALUE * .9 ) )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] >= ( MAX_COND_VALUE * .9 )
liquids.c:                     && ch->pcdata->condition[COND_DRUNK] < MAX_COND_VALUE )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] == MAX_COND_VALUE )
liquids.c:            if( ch->pcdata->condition[COND_THIRST] > ( MAX_COND_VALUE / 2 )
liquids.c:                && ch->pcdata->condition[COND_THIRST] < ( MAX_COND_VALUE * .4 ) )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] >= ( MAX_COND_VALUE * .4 )
liquids.c:                     && ch->pcdata->condition[COND_THIRST] < ( MAX_COND_VALUE * .6 ) )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] >= ( MAX_COND_VALUE * .6 )
liquids.c:                     && ch->pcdata->condition[COND_THIRST] < ( MAX_COND_VALUE * .9 ) )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] >= ( MAX_COND_VALUE * .9 )
liquids.c:                     && ch->pcdata->condition[COND_THIRST] < MAX_COND_VALUE )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] == MAX_COND_VALUE )
liquids.c:               if( ch->pcdata->condition[COND_BLOODTHIRST] > ( MAX_COND_VALUE / 2 )
liquids.c:                   && ch->pcdata->condition[COND_BLOODTHIRST] < ( MAX_COND_VALUE * .4 ) )
liquids.c:               else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( MAX_COND_VALUE * .4 )
liquids.c:                        && ch->pcdata->condition[COND_BLOODTHIRST] < ( MAX_COND_VALUE * .6 ) )
liquids.c:               else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( MAX_COND_VALUE * .6 )
liquids.c:                        && ch->pcdata->condition[COND_BLOODTHIRST] < ( MAX_COND_VALUE * .9 ) )
liquids.c:               else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( MAX_COND_VALUE * .9 )
liquids.c:                        && ch->pcdata->condition[COND_BLOODTHIRST] < MAX_COND_VALUE )
liquids.c:            else if( !IS_VAMPIRE( ch ) && ch->pcdata->condition[COND_BLOODTHIRST] >= MAX_COND_VALUE )
liquids.c:               ch->pcdata->condition[COND_BLOODTHIRST] = MAX_COND_VALUE;
liquids.c:      for( source = ch->in_room->first_content; source; source = src_next )
liquids.c:                || ch->carry_weight + get_obj_weight( source ) > can_carry_w( ch )
liquids.c:               ch->gold += source->value[0];
liquids.c:         if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
liquids.c:            save_house_by_vnum( ch->in_room->vnum );
liquids.c:                || ch->carry_weight + get_obj_weight( source ) > can_carry_w( ch )
liquids.c:            if( !IS_OBJ_STAT( source, ITEM_CLANCORPSE ) || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
liquids.c:               if( str_cmp( name, ch->name ) && !IS_IMMORTAL( ch ) )
liquids.c:                  for( gch = first_char; gch; gch = gch->next )
liquids.c:                     if( !IS_NPC( gch ) && is_same_group( ch, gch ) && !str_cmp( name, gch->name ) )
liquids.c:                   || ch->carry_number + otmp->count > can_carry_n( ch )
liquids.c:                   || ch->carry_weight + get_obj_weight( otmp ) > can_carry_w( ch )
liquids.c:               if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
liquids.c:                  save_house_by_vnum( ch->in_room->vnum );
liquids.c:            if( xIS_SET( ch->in_room->room_flags, ROOM_NODROP ) || xIS_SET( ch->act, PLR_LITTERBUG ) )
liquids.c:            if( xIS_SET( ch->in_room->room_flags, ROOM_NODROPALL )
liquids.c:                || xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
liquids.c:            if( empty_obj( obj, NULL, ch->in_room ) )
liquids.c:         if( ch->in_room && xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
liquids.c:            save_house_by_vnum( ch->in_room->vnum );
liquids.c:         if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
liquids.c:               if( vault->vnum == ch->in_room->vnum )
magic.c:         return ( IS_SET( ch->immune, RIS_FIRE ) );
magic.c:         return ( IS_SET( ch->immune, RIS_COLD ) );
magic.c:         return ( IS_SET( ch->immune, RIS_ELECTRICITY ) );
magic.c:         return ( IS_SET( ch->immune, RIS_ENERGY ) );
magic.c:         return ( IS_SET( ch->immune, RIS_ACID ) );
magic.c:         return ( IS_SET( ch->immune, RIS_POISON ) );
magic.c:         return ( IS_SET( ch->immune, RIS_DRAIN ) );
magic.c:   if( ch->pcdata->learned[sn] > 0
magic.c:       && ( ch->level >= skill_table[sn]->skill_level[ch->Class] || ch->level >= skill_table[sn]->race_level[ch->race] ) )
magic.c:      if( ch->pcdata->learned[sn] > 0
magic.c:          && ch->level >= skill_table[sn]->skill_level[ch->Class]
magic.c:   if( !ch->pcdata )
magic.c:      if( !ch->pcdata->special_skills[sn] || !ch->pcdata->special_skills[sn]->name )
magic.c:      if( LOWER( name[0] ) == LOWER( ch->pcdata->special_skills[sn]->name[0] )
magic.c:          && !str_prefix( name, ch->pcdata->special_skills[sn]->name ) )
magic.c:   if( IS_NPC( ch ) || ch->Class == CLASS_MAGE )
magic.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
magic.c:         act( AT_MAGIC, ch->Class == rch->Class ? buf : buf2, ch, NULL, rch, TO_VICT );
magic.c:   if( IS_SET( ch->immune, ris ) && !IS_SET( ch->no_immune, ris ) )
magic.c:   if( IS_SET( ch->resistant, ris ) && !IS_SET( ch->no_resistant, ris ) )
magic.c:   if( IS_SET( ch->susceptible, ris ) && !IS_SET( ch->no_susceptible, ris ) )
magic.c:      if( IS_NPC( ch ) && IS_SET( ch->immune, ris ) )
magic.c:            return ch->hit;
magic.c:            return ch->mana;
magic.c:            return ch->move;
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:            if( ch->gold >= value )
magic.c:                     ch->gold -= value;
magic.c:            if( ch->hit >= value )
magic.c:                     ch->hit -= value;
magic.c:         if( !IS_NPC( ch ) && ch->pcdata->nuisance &&
magic.c:             ch->pcdata->nuisance->flags > 5
magic.c:             && number_percent(  ) < ( ( ( ch->pcdata->nuisance->flags - 5 ) * 8 ) + ch->pcdata->nuisance->power * 6 ) )
magic.c:               if( xIS_SET( ch->act, PLR_NICE ) && ch != *victim )
magic.c:            if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == *victim )
magic.c:         if( !IS_NPC( ch ) && ch->fighting && ch->pcdata->nuisance &&
magic.c:             ch->pcdata->nuisance->flags > 5
magic.c:             && number_percent(  ) < ( ( ( ch->pcdata->nuisance->flags - 5 ) * 8 ) + 6 * ch->pcdata->nuisance->power ) )
magic.c:         if( arg[0] != '\0' && !nifty_is_name( arg, ch->name ) )
magic.c:   switch ( ch->substate )
magic.c:         if( xIS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) || IS_SET( ch->in_room->area->flags, AFLAG_NOMAGIC ) )
magic.c:                || ( !IS_NPC( ch ) && ch->level < skill_table[sn]->skill_level[ch->Class] ) )
magic.c:         if( ch->position < skill->minimum_position && !IS_NPC( ch ) )
magic.c:            switch ( ch->position )
magic.c:             && skill->guild != CLASS_NONE && ( !ch->pcdata->clan || skill->guild != ch->pcdata->clan->Class ) )
magic.c:         if( !ch->in_room || ( skill->spell_sector && !IS_SET( skill->spell_sector, ( 1 << ch->in_room->sector_type ) ) ) )
magic.c:         mana = IS_NPC( ch ) ? 0 : UMAX( skill->min_mana, 100 / ( 2 + ch->level - skill->skill_level[ch->Class] ) );
magic.c:            if( ch->pcdata->condition[COND_BLOODTHIRST] < blood )
magic.c:         else if( !IS_NPC( ch ) && ch->mana < mana )
magic.c:         ch->alloc_ptr = str_dup( staticbuf );
magic.c:         ch->tempnum = sn;
magic.c:         DISPOSE( ch->alloc_ptr );
magic.c:         if( IS_VALID_SN( ( sn = ch->tempnum ) ) )
magic.c:            mana = IS_NPC( ch ) ? 0 : UMAX( skill->min_mana, 100 / ( 2 + ch->level - skill->skill_level[ch->Class] ) );
magic.c:            else if( ch->level < LEVEL_IMMORTAL )  /* so imms dont lose mana */
magic.c:               ch->mana -= mana / 3;
magic.c:         sn = ch->tempnum;
magic.c:         if( !ch->alloc_ptr || !IS_VALID_SN( sn ) || skill->type != SKILL_SPELL )
magic.c:            bug( "do_cast: ch->alloc_ptr NULL or bad sn (%d)", sn );
magic.c:         mana = IS_NPC( ch ) ? 0 : UMAX( skill->min_mana, 100 / ( 2 + ch->level - skill->skill_level[ch->Class] ) );
magic.c:         mudstrlcpy( staticbuf, ch->alloc_ptr, MAX_INPUT_LENGTH );
magic.c:         DISPOSE( ch->alloc_ptr );
magic.c:         ch->substate = SUB_NONE;
magic.c:            for( tmp = ch->in_room->first_person; tmp; tmp = tmp->next_in_room )
magic.c:               for( tmp = ch->in_room->first_person; tmp; tmp = tmp->next_in_room )
magic.c:               else if( ch->level < LEVEL_IMMORTAL )  /* so imms dont lose mana */
magic.c:                  ch->mana -= mana / 2;
magic.c:      else if( ch->level < LEVEL_IMMORTAL )  /* so imms dont lose mana */
magic.c:         ch->mana -= mana / 2;
magic.c:   if( !IS_NPC( ch ) && ( number_percent(  ) + skill->difficulty * 5 ) > ch->pcdata->learned[sn] )
magic.c:            if( ch->fighting )
magic.c:            if( ch->fighting )
magic.c:      else if( ch->level < LEVEL_IMMORTAL )  /* so imms dont lose mana */
magic.c:         ch->mana -= mana / 2;
magic.c:         ch->mana -= mana;
magic.c:         retcode = ( *skill->spell_fun ) ( sn, ch->level, ch, vo );
magic.c:   if( ch->in_room && IS_SET( ch->in_room->area->flags, AFLAG_SPELLLIMIT ) )
magic.c:      ch->in_room->area->curr_spell_count++;
magic.c:      for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:         vch_next = vch->next_in_room;
magic.c:            if( vch->master != ch && !vch->fighting )
magic.c:   int levdiff = ch->level - level;
magic.c:   if( !ch->in_room || xIS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) || IS_SET( ch->in_room->area->flags, AFLAG_NOMAGIC ) )
magic.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) && skill->target == TAR_CHAR_OFFENSIVE )
magic.c:         if( skill->type != SKILL_HERB && IS_SET( ch->immune, RIS_MAGIC ) )
magic.c:      for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:         vch_next = vch->next_in_room;
magic.c:         if( victim == vch && !vch->fighting && vch->master != ch )
magic.c:   struct WeatherCell *cell = getWeatherCell( ch->in_room->area );
magic.c:   where = ch->in_room;
magic.c:      if( !vch->in_room )
magic.c:      if( vch->in_room == where )
magic.c:         if( IS_NPC( vch ) && xIS_SET( vch->act, ACT_MOBINVIS ) )
magic.c:         if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:      else if( vch->in_room->area == where->area && IS_OUTSIDE( vch ) && IS_AWAKE( vch ) && number_bits( 2 ) == 0 )
magic.c:   if( ( ( get_curr_cha( ch ) / 3 ) + 1 ) > ch->pcdata->charmies )
magic.c:   log_printf_plus( LOG_NORMAL, ch->level, "%s has charmed %s.", ch->name, victim->name );
magic.c:      ch->pcdata->charmies++;
magic.c:   struct WeatherCell *cell = getWeatherCell( ch->in_room->area );
magic.c:   change = URANGE( 5, number_range( 5, 15 ) + ( ch->level / 10 ), 15 );
magic.c:   mushroom = obj_to_room( mushroom, ch->in_room );
magic.c:   struct WeatherCell *cell = getWeatherCell( ch->in_room->area );
magic.c:   if( ch->alignment < 350 )
magic.c:   if( IS_SET( ch->immune, RIS_MAGIC ) )
magic.c:   if( IS_NPC( ch ) || ch->Class == CLASS_MAGE )
magic.c:      if( ch->first_affect )
magic.c:         while( ch->first_affect )
magic.c:            affect_remove( ch, ch->first_affect );
magic.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   where = ch->in_room;
magic.c:      if( !vch->in_room )
magic.c:      if( vch->in_room == where )
magic.c:         if( IS_NPC( vch ) && xIS_SET( vch->act, ACT_MOBINVIS ) )
magic.c:         if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:      else if( vch->in_room->area == where->area && number_bits( 2 ) == 0 )
magic.c:   ch->alignment = UMAX( -1000, ch->alignment - 200 );
magic.c:      dam = ch->hit + 1;
magic.c:      ch->hit += dam;
magic.c:   if( ch->hit > ch->max_hit )
magic.c:      ch->hit = ch->max_hit;
magic.c:   for( ich = ch->in_room->first_person; ich; ich = ich->next_in_room )
magic.c:      if( !IS_NPC( ich ) && xIS_SET( ich->act, PLR_WIZINVIS ) )
magic.c:      xREMOVE_BIT( ich->affected_by, AFF_HIDE );
magic.c:      xREMOVE_BIT( ich->affected_by, AFF_INVISIBLE );
magic.c:      xREMOVE_BIT( ich->affected_by, AFF_SNEAK );
magic.c:   char_to_room( create_mobile( temp ), ch->in_room );
magic.c:                    name, ( ch->level > victim->level + 10 ) ? victim->name : "someone else" );
magic.c:      if( ( chance( ch, 50 ) && ch->level >= victim->level + 10 ) || IS_IMMORTAL( ch ) )
magic.c:   if( !ch->in_room->first_content )
magic.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
magic.c:      snprintf( log_buf, MAX_STRING_LENGTH, "%s has cast sleep on %s.", ch->name, victim->name );
magic.c:      log_string_plus( log_buf, LOG_NORMAL, ch->level );
magic.c:      to_channel( log_buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level ) );
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_ASTRAL )
magic.c:       || !in_hard_range( victim, ch->in_room->area )
magic.c:       || ( IS_SET( ch->in_room->area->flags, AFLAG_NOPKILL ) && IS_PKILL( victim ) )
magic.c:   if( ch->in_room->area != victim->in_room->area )
magic.c:      ch->position = POS_STUNNED;
magic.c:      snprintf( buf, MAX_STRING_LENGTH, "%s summoned %s to room %d.", ch->name, victim->name, ch->in_room->vnum );
magic.c:      log_string_plus( buf, LOG_NORMAL, ch->level );
magic.c:      to_channel( buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level ) );
magic.c:   char_to_room( victim, ch->in_room );
magic.c:   ROOM_INDEX_DATA *start = ch->in_room;
magic.c:      nch_next = nch->next_in_room;
magic.c:   ROOM_INDEX_DATA *start = ch->in_room, *pRoomIndex;
magic.c:   if( !IS_NPC( ch ) && ch->mana < mana )
magic.c:      nch_next = nch->next_in_room;
magic.c:   snprintf( buf3, MAX_STRING_LENGTH, "%s makes %s say '%s'.\r\n", capitalize( ch->name ), speaker, target_name );
magic.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
magic.c:      if( !is_name( speaker, vch->name ) )
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   for( vch = ch->in_room->first_person; vch; vch = trvch_next( loop_ctrl ) )
magic.c:      if( IS_NPC( vch ) && xIS_SET( vch->act, ACT_MOBINVIS ) )
magic.c:      if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:         hpch = UMAX( 10, ch->hit );
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:   if( victim->in_room == ch->in_room )
magic.c:   for( obj = ch->in_room->first_content; obj; obj = obj_next )
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_ASTRAL )
magic.c:       || IS_SET( ch->in_room->area->flags, AFLAG_NOPORTALOUT )
magic.c:       || IS_SET( ch->in_room->area->flags, AFLAG_NOASTRAL )
magic.c:   if( victim->in_room == ch->in_room )
magic.c:   fromRoom = ch->in_room;
magic.c:   snprintf( buf, MAX_STRING_LENGTH, "a portal created by %s", ch->name );
magic.c:   portalObj = obj_to_room( portalObj, ch->in_room );
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:   original = ch->in_room;
magic.c:      else if( chance( ch, 50 - ( ch->level / 2 ) ) )
magic.c:       || IS_SET( ch->in_room->area->flags, AFLAG_NOASTRAL )
magic.c:       || ( ch->in_room->sector_type != SECT_FOREST
magic.c:            && ch->in_room->sector_type != SECT_FIELD )
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:   if( ch->in_room->sector_type == SECT_FOREST )
magic.c:   if( ch->in_room->sector_type == SECT_FOREST )
magic.c:   if( IS_PKILL( ch ) && ch->pcdata->condition[COND_BLOODTHIRST] > 22 )
magic.c:       || IS_SET( ch->in_room->area->flags, AFLAG_NOASTRAL )
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:   struct WeatherCell *cell = getWeatherCell( ch->in_room->area );
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:       || IS_SET( ch->in_room->area->flags, AFLAG_NOASTRAL )
magic.c:            if( chance( ch, 50 ) && ch->level + 10 < victim->level )
magic.c:            if( chance( ch, 50 ) && ch->level + 15 < victim->level )
magic.c:   for( corpse = ch->in_room->first_content; corpse; corpse = corpse_next )
magic.c:         if( !IS_IMMORTAL( ch ) && ch->pcdata->condition[COND_BLOODTHIRST] - ( pMobIndex->level / 3 ) < 0 )
magic.c:      else if( ch->mana - ( pMobIndex->level * 4 ) < 0 )
magic.c:         ch->mana -= ( pMobIndex->level * 4 );
magic.c:   if( IS_IMMORTAL( ch ) || ( chance( ch, 75 ) && pMobIndex->level - ch->level < 10 ) )
magic.c:      char_to_room( mob, ch->in_room );
magic.c:      mob->level = UMIN( ch->level / 2, pMobIndex->level );
magic.c:                                   ( mob->max_hit * corpse->value[3] ) / 100, ch->level * dice( 20, 10 ) ), 1 );
magic.c:      mob->damroll = ch->level / 8;
magic.c:      mob->hitroll = ch->level / 6;
magic.c:      mob->alignment = ch->alignment;
magic.c:   if( !ch->desc || ch->desc->original )
magic.c:   af.duration = 20 + ( ch->level - victim->level ) / 2;
magic.c:   ch->desc->character = victim;
magic.c:   ch->desc->original = ch;
magic.c:   victim->desc = ch->desc;
magic.c:   ch->desc = NULL;
magic.c:   ch->switched = victim;
magic.c:   if( pexit->rexit && pexit->rexit->to_room == ch->in_room )
magic.c:   if( !( victim = get_char_world( ch, arg ) ) || victim->in_room->area != ch->in_room->area )
magic.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   for( vch = ch->in_room->first_person; vch; vch = trvch_next( lc ) )
magic.c:      if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:         hpch = UMAX( 10, ch->hit );
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:       || IS_SET( ch->in_room->area->flags, AFLAG_NOASTRAL )
magic.c:            if( ( dam > 0 && ch->fighting && ch->fighting->who == victim )
magic.c:               int xp = ch->fighting ? ch->fighting->xp : victim->fighting->xp;
magic.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:      vch_next = vch->next_in_room;
magic.c:      if( IS_NPC( vch ) && xIS_SET( vch->act, ACT_MOBINVIS ) )
magic.c:      if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:               vch->hit = URANGE( 0, vch->hit + dam, vch->max_hit );
magic.c:               if( ( dam > 0 && ch->fighting && ch->fighting->who == vch )
magic.c:                   || ( dam > 0 && vch->fighting && vch->fighting->who == ch ) )
magic.c:                  int xp = ch->fighting ? ch->fighting->xp : vch->fighting->xp;
magic.c:                  int xp_gain = ( int )( xp * dam * 2 ) / vch->max_hit;
magic.c:               if( ( af.modifier > 0 && ch->fighting && ch->fighting->who == victim )
magic.c:                  int xp = ch->fighting ? ch->fighting->xp : victim->fighting->xp;
magic.c:         victim = ch->in_room->first_person;
magic.c:   struct WeatherCell *cell = getWeatherCell( ch->in_room->area );
magic.c:               if( ch->level - obj->level < 10 || obj->cost > ch->level * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:               if( ch->level - obj->level < 20 || obj->cost > ch->level * get_curr_int( ch ) / 5 )
magic.c:               if( ch->level - obj->level < 5 || obj->cost > ch->level * 10 * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:               if( ch->level - obj->level < 0 || obj->cost > ch->level * 50 * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:      obj_to_room( obj, ch->in_room );
magic.c:   char_to_room( mob, ch->in_room );
magic.c:             ( ch->position == POS_FIGHTING
magic.c:               || ch->position == POS_EVASIVE
magic.c:               || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK ) )
magic.c:   ch->gold += val;
makeobjs.c:      if( ch && ch->in_room )
makeobjs.c:      name = ch->short_descr;
makeobjs.c:      if( ch->gold > 0 )
makeobjs.c:         if( ch->in_room )
makeobjs.c:            ch->in_room->area->gold_looted += ch->gold;
makeobjs.c:            sysdata.global_looted += ch->gold / 100;
makeobjs.c:         obj_to_obj( create_money( ch->gold ), corpse );
makeobjs.c:         ch->gold = 0;
makeobjs.c:	corpse->value[0] = (int)ch->pIndexData->vnum;
makeobjs.c:	corpse->value[1] = (int)ch->max_hit;
makeobjs.c:      corpse->cost = ( -( int )ch->pIndexData->vnum );
makeobjs.c:      name = ch->name;
makeobjs.c:      corpse->value[4] = ch->level;
makeobjs.c:   for( obj = ch->first_carrying; obj; obj = obj_next )
makeobjs.c:         obj_to_room( obj, ch->in_room );
makeobjs.c:   return obj_to_room( corpse, ch->in_room );
makeobjs.c:   for(obj = ch->in_room->first_content; obj; obj = obj->next_content )
makeobjs.c:      obj_to_room( obj, ch->in_room );
makeobjs.c:   for( obj = ch->in_room->first_content; obj; obj = obj_next )
makeobjs.c:         obj->value[1] += number_range( 3, UMIN( 5, ch->level ) );
makeobjs.c:   obj->value[1] = number_range( 3, UMIN( 5, ch->level ) );
makeobjs.c:   obj_to_room( obj, ch->in_room );
makeobjs.c:   obj_to_room( obj, ch->in_room );
mapout.c:   if( !ch->pnote )
mapout.c:      bug( "%s", "map_stats: ch->pnote == NULL!" );
mapout.c:   l = ch->pnote->text;
mapout.c:   if( !ch->desc )
mapout.c:   switch ( ch->substate )
mapout.c:         if( ch->dest_buf != ch->pnote )
mapout.c:            bug( "%s", "do_mapout: sub_writing_map: ch->dest_buf != ch->pnote" );
mapout.c:         STRFREE( ch->pnote->text );
mapout.c:         ch->pnote->text = copy_buffer( ch );
mapout.c:      if( !ch->pnote )
mapout.c:      ch->substate = SUB_WRITING_NOTE;
mapout.c:      ch->dest_buf = ch->pnote;
mapout.c:      start_editing( ch, ch->pnote->text );
mapout.c:      if( !ch->pnote )
mapout.c:      STRFREE( ch->pnote->text );
mapout.c:      STRFREE( ch->pnote->subject );
mapout.c:      STRFREE( ch->pnote->to_list );
mapout.c:      STRFREE( ch->pnote->date );
mapout.c:      STRFREE( ch->pnote->sender );
mapout.c:      DISPOSE( ch->pnote );
mapout.c:      ch->pnote = NULL;
mapout.c:      if( !ch->pnote )
mapout.c:      send_to_char( ch->pnote->text, ch );
mapout.c:      if( !ch->pnote )
mapout.c:         ed->description = QUICKLINK( ch->pnote->text );
mapout.c:   for( i = ch->pcdata->area->low_r_vnum; i <= ch->pcdata->area->hi_r_vnum; i++ )
mapout.c:         if( !( location = make_room( i, ch->pcdata->area ) ) )
mapout.c:         location->area = ch->pcdata->area;
mapout.c:   for( i = ch->pcdata->area->low_r_vnum; i <= ch->pcdata->area->hi_r_vnum; i++ )
mapout.c:/* This function takes the character string in ch->pnote and
mapout.c:   if( !ch->pnote )
mapout.c:      bug( "%s: ch->pnote==NULL!", __func__ );
mapout.c:   newmap = check_map( ch->pnote->text );
mapout.c:   STRFREE( ch->pnote->text );
mapout.c:   ch->pnote->text = STRALLOC( newmap );
mapout.c:      for( i = ch->pcdata->area->low_r_vnum; i <= ch->pcdata->area->hi_r_vnum; i++ )
mapout.c:   l = ch->pnote->text;
mapper.c:   for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
mapper.c:   if( xIS_SET( ch->act, PLR_AUTOEXIT ) )
mapper.c:   dmap[x][y].vnum = ch->in_room->vnum;
mapper.c:   map_exits( ch, ch->in_room, x, y, 0 );
mccp.c:   if( !ch->desc )
mccp.c:   if( !ch->desc->mccp->out_compress )
mccp.c:      if( !compressStart( ch->desc ) )
mccp.c:      compressEnd( ch->desc );
mccp.c:      ch->desc->can_compress = FALSE;
misc.c:   if( IS_NPC( ch ) || ch->pcdata->condition[COND_FULL] > 5 )
misc.c:      if( !IS_NPC( ch ) && ch->pcdata->condition[COND_FULL] > 40 )
misc.c:   if( !IS_NPC( ch ) && ( !IS_PKILL( ch ) || ( IS_PKILL( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_HIGHGAG ) ) ) )
misc.c:   if( ch->fighting && number_percent(  ) > ( get_curr_dex( ch ) * 2 + 47 ) )
misc.c:                ( ch->in_room->sector_type == SECT_UNDERWATER ||
misc.c:                  ch->in_room->sector_type == SECT_WATER_SWIM ||
misc.c:                  ch->in_room->sector_type == SECT_WATER_NOSWIM ) ? "dissolves in the water" :
misc.c:                ( ch->in_room->sector_type == SECT_AIR ||
misc.c:                  xIS_SET( ch->in_room->room_flags, ROOM_NOFLOOR ) ) ? "falls far below" : "is trampled underfoot" );
misc.c:               condition = ch->pcdata->condition[COND_FULL];
misc.c:               if( condition <= 1 && ch->pcdata->condition[COND_FULL] > 1 )
misc.c:               else if( ch->pcdata->condition[COND_FULL] > 40 )
misc.c:                  ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
misc.c:                  ch->mental_state = URANGE( 15, ch->mental_state + 5, 100 );
misc.c:               condition = ch->pcdata->condition[COND_FULL];
misc.c:               if( condition <= 1 && ch->pcdata->condition[COND_FULL] > 1 )
misc.c:               else if( ch->pcdata->condition[COND_FULL] > 40 )
misc.c:   if( !IS_NPC( ch ) && ( ch->pcdata->condition[COND_FULL] >= 48 || ch->pcdata->condition[COND_THIRST] >= 48 ) )
misc.c:   if( !IS_NPC( ch ) && ch->pcdata->nuisance &&
misc.c:       ch->pcdata->nuisance->flags > 3
misc.c:       && ( ch->pcdata->condition[COND_FULL] >= ( 48 - ( 3 * ch->pcdata->nuisance->flags ) + ch->pcdata->nuisance->power )
misc.c:            || ch->pcdata->condition[COND_THIRST] >= ( 48 - ( ch->pcdata->nuisance->flags ) + ch->pcdata->nuisance->power ) ) )
misc.c:   if( !IS_NPC( ch ) && ( !IS_PKILL( ch ) || ( IS_PKILL( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_HIGHGAG ) ) ) )
misc.c:   if( ch->fighting && number_percent(  ) > ( get_curr_dex( ch ) * 2 + 48 ) )
misc.c:      if( !IS_NPC( ch ) && ch->pcdata->condition[COND_THIRST] > 43 )
misc.c:   if( ( scroll->pIndexData->vnum == OBJ_VNUM_SCROLL_SCRIBING ) && ( ch->level + 10 < scroll->value[0] ) )
misc.c:      for( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:      snprintf( buf, MAX_STRING_LENGTH, "%s hit a DEATH TRIGGER in room %d!", ch->name, ch->in_room->vnum );
misc.c:            obj_to_room( tobj, ch->in_room );
misc.c:      room = ch->in_room;
misc.c:      obj_cast_spell( obj->value[1], URANGE( 1, ( obj->value[2] > 0 ) ? obj->value[2] : ch->level, MAX_LEVEL ), ch, ch,
misc.c:      for( container = ch->in_room->first_content; container; container = container->next_content )
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:         for( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:            for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
misc.c:         for( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:            for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
misc.c:   if( ch->fighting )
misc.c:      if( ( to_room = pexit->to_room ) != NULL && ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:         for( rch = to_room->first_person; rch; rch = rch->next_in_room )
misc.c:            obj_cast_spell( sn, UMIN( skill->min_level, ch->level ), ch, ch, NULL );
misc.c:   for( tinder = ch->last_carrying; tinder; tinder = tinder->prev_content )
misc.c:         if( ( obj = get_obj_list_rev( ch, arg, ch->in_room->last_content ) ) == NULL )
misc.c:         if( ( obj = get_obj_list_rev( ch, arg, ch->in_room->last_content ) ) == NULL )
misc.c:   if( ch->fighting )
modifier:handler.c:      xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c:      xREMOVE_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c:         bug( "%s: unknown location %d. (%s)", __func__, paf->location, ch->name );
modifier:handler.c:      bug( "%s (%s, %d): no affect.", __func__, ch->name, paf ? paf->type : 0 );
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:   xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c:         SET_BIT( ch->affected_by.bits[0], paf->modifier );
modifier:handler.c:         SET_BIT( ch->resistant, paf->modifier );
modifier:handler.c:         SET_BIT( ch->susceptible, paf->modifier );
modifier:handler.c:         SET_BIT( ch->immune, paf->modifier );
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c.backup:      xREMOVE_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c.backup:         bug( "%s: unknown location %d. (%s)", __func__, paf->location, ch->name );
modifier:handler.c.backup:      bug( "%s (%s, %d): no affect.", __func__, ch->name, paf ? paf->type : 0 );
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c.backup:         SET_BIT( ch->affected_by.bits[0], paf->modifier );
modifier:handler.c.backup:         SET_BIT( ch->resistant, paf->modifier );
modifier:handler.c.backup:         SET_BIT( ch->susceptible, paf->modifier );
modifier:handler.c.backup:         SET_BIT( ch->immune, paf->modifier );
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
modifier:player.c:      for( paf = ch->first_affect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:save.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:update.c:                     if( ( *skill->spell_fun ) ( paf->modifier, ch->level, ch, ch ) == rCHAR_DIED || char_died( ch ) )
modifier:handler.c:      xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c:      xREMOVE_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c:         bug( "%s: unknown location %d. (%s)", __func__, paf->location, ch->name );
modifier:handler.c:      bug( "%s (%s, %d): no affect.", __func__, ch->name, paf ? paf->type : 0 );
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:   xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c:         SET_BIT( ch->affected_by.bits[0], paf->modifier );
modifier:handler.c:         SET_BIT( ch->resistant, paf->modifier );
modifier:handler.c:         SET_BIT( ch->susceptible, paf->modifier );
modifier:handler.c:         SET_BIT( ch->immune, paf->modifier );
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c.backup:      xREMOVE_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c.backup:         bug( "%s: unknown location %d. (%s)", __func__, paf->location, ch->name );
modifier:handler.c.backup:      bug( "%s (%s, %d): no affect.", __func__, ch->name, paf ? paf->type : 0 );
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c.backup:         SET_BIT( ch->affected_by.bits[0], paf->modifier );
modifier:handler.c.backup:         SET_BIT( ch->resistant, paf->modifier );
modifier:handler.c.backup:         SET_BIT( ch->susceptible, paf->modifier );
modifier:handler.c.backup:         SET_BIT( ch->immune, paf->modifier );
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
modifier:player.c:      for( paf = ch->first_affect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:save.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:update.c:                     if( ( *skill->spell_fun ) ( paf->modifier, ch->level, ch, ch ) == rCHAR_DIED || char_died( ch ) )
mpxset.c:   if( !IS_NPC( ch ) || IS_AFFECTED( ch, AFF_CHARM ) || ch->desc )
mpxset.c:      snprintf( log_buf, MAX_STRING_LENGTH, "%s raising glory of %s by %d ...", ch->name, victim->name, value );
mpxset.c:   if( !IS_NPC( ch ) || IS_AFFECTED( ch, AFF_CHARM ) || ch->desc )
mud.h:#define WAIT_STATE(ch, npulse) ((ch)->wait=(!IS_NPC(ch)&&ch->pcdata->nuisance&&\
mud.h:			      (ch->pcdata->nuisance->flags>4))?UMAX((ch)->wait,\
mud.h:               		      ch->pcdata->nuisance->power)): \
mud.h:#define IS_PACIFIST(ch)		(IS_NPC(ch) && xIS_SET(ch->act, ACT_PACIFIST))
mud.h:#define IS_RETIRED(ch) (ch->pcdata && IS_SET(ch->pcdata->flags,PCFLAG_RETIRED))
mud.h:#define IS_GUEST(ch) (ch->pcdata && IS_SET(ch->pcdata->flags,PCFLAG_GUEST))
mud.h:#define NOT_AUTHED(ch)		(!IS_NPC(ch) && ch->pcdata->auth_state <= 3  \
mud.h:			      && IS_SET(ch->pcdata->flags, PCFLAG_UNAUTHED) )
mud.h:#define IS_WAITING_FOR_AUTH(ch) (!IS_NPC(ch) && ch->desc		     \
mud.h:			      && ch->pcdata->auth_state == 1		     \
mud.h:			      && IS_SET(ch->pcdata->flags, PCFLAG_UNAUTHED) )
mud.h.backup:#define WAIT_STATE(ch, npulse) ((ch)->wait=(!IS_NPC(ch)&&ch->pcdata->nuisance&&\
mud.h.backup:			      (ch->pcdata->nuisance->flags>4))?UMAX((ch)->wait,\
mud.h.backup:               		      ch->pcdata->nuisance->power)): \
mud.h.backup:#define IS_PACIFIST(ch)		(IS_NPC(ch) && xIS_SET(ch->act, ACT_PACIFIST))
mud.h.backup:#define IS_RETIRED(ch) (ch->pcdata && IS_SET(ch->pcdata->flags,PCFLAG_RETIRED))
mud.h.backup:#define IS_GUEST(ch) (ch->pcdata && IS_SET(ch->pcdata->flags,PCFLAG_GUEST))
mud.h.backup:#define NOT_AUTHED(ch)		(!IS_NPC(ch) && ch->pcdata->auth_state <= 3  \
mud.h.backup:			      && IS_SET(ch->pcdata->flags, PCFLAG_UNAUTHED) )
mud.h.backup:#define IS_WAITING_FOR_AUTH(ch) (!IS_NPC(ch) && ch->desc		     \
mud.h.backup:			      && ch->pcdata->auth_state == 1		     \
mud.h.backup:			      && IS_SET(ch->pcdata->flags, PCFLAG_UNAUTHED) )
mud_comm.c:   if( xIS_EMPTY( ch->in_room->progtypes ) )
mud_comm.c:      ch_printf( ch, "No programs on room:  %s - #%d\r\n", ch->in_room->name, ch->in_room->vnum );
mud_comm.c:   ch_printf( ch, "Name: %s.  Vnum: %d.\r\n", ch->in_room->name, ch->in_room->vnum );
mud_comm.c:   for( mprg = ch->in_room->mudprogs; mprg; mprg = mprg->next )
mud_comm.c:   if( ch->position == POS_FIGHTING
mud_comm.c:       || ch->position == POS_EVASIVE
mud_comm.c:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
mud_comm.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   was_in_room = ch->in_room;
mud_comm.c:         ch->in_room = pexit->to_room;
mud_comm.c:   ch->act = actflags;
mud_comm.c:   ch->in_room = was_in_room;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   if( ch->pIndexData == pMobIndex )
mud_comm.c:      victim->resetvnum = ch->resetvnum;
mud_comm.c:      victim->resetnum = ch->resetnum;
mud_comm.c:      ch->loadedself = true;
mud_comm.c:   char_to_room( victim, ch->in_room );
mud_comm.c:      obj_to_room( obj, ch->in_room );
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:      for( victim = ch->in_room->first_person; victim; victim = vnext )
mud_comm.c:      while( ch->in_room->first_content )
mud_comm.c:         extract_obj( ch->in_room->first_content );
mud_comm.c:      ch->mobinvis = level;
mud_comm.c:   if( ch->mobinvis < 2 )
mud_comm.c:      ch->mobinvis = ch->level;
mud_comm.c:   if( xIS_SET( ch->act, ACT_MOBINVIS ) )
mud_comm.c:      xREMOVE_BIT( ch->act, ACT_MOBINVIS );
mud_comm.c:      xSET_BIT( ch->act, ACT_MOBINVIS );
mud_comm.c:   in_room = ch->in_room;
mud_comm.c:   if( ch->fighting )
mud_comm.c:      fch_next = fch->next_in_room;
mud_comm.c:      if( fch->mount && fch->mount == ch )
mud_comm.c:   original = ch->in_room;
mud_comm.c:   if( victim->level > ch->level )
mud_comm.c:   if( !ch->in_room )
mud_comm.c:      destination = ch->in_room;
mud_comm.c:      for( victim = ch->in_room->last_person; victim; victim = ChNext )
mud_comm.c:             || ch->in_room->area != d->character->in_room->area
mud_comm.c:      for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
mud_comm.c:            mst = vch->mental_state;
mud_comm.c:            vch->mental_state = 0;
mud_comm.c:               drunk = vch->pcdata->condition[COND_DRUNK];
mud_comm.c:               vch->pcdata->condition[COND_DRUNK] = 0;
mud_comm.c:            vch->mental_state = mst;
mud_comm.c:               vch->pcdata->condition[COND_DRUNK] = drunk;
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !ch->pcdata->nuisance )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:      vch_next = vch->next;
mud_comm.c:      if( vch->in_room->area == ch->in_room->area && !IS_NPC( vch ) && IS_AWAKE( vch ) )
mud_comm.c:   ch->act = actflags;
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:      for( victim = ch->in_room->first_person; victim; victim = nextinroom )
mud_comm.c:             t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, ch->short_descr, argument );
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || IS_AFFECTED( ch, AFF_CHARM ) || ch->desc )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( gold <= ch->gold && ch->in_room )
mud_comm.c:      ch->gold -= gold;
mud_comm.c:      boost_economy( ch->in_room->area, gold );
mud_comm.c:   if( ch->gold < 1000000000 && gold < 1000000000 && ch->in_room && economy_has( ch->in_room->area, gold ) )
mud_comm.c:      ch->gold += gold;
mud_comm.c:      lower_economy( ch->in_room->area, gold );
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:      for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
mud_comm.c:         if( rch->fighting )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:                   victim->name, victim->level, ( IS_NPC( ch ) ? ch->short_descr : ch->name ), victim->in_room->vnum );
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( xIS_EMPTY( ch->in_room->progtypes ) )
mud_comm.c.backup:      ch_printf( ch, "No programs on room:  %s - #%d\r\n", ch->in_room->name, ch->in_room->vnum );
mud_comm.c.backup:   ch_printf( ch, "Name: %s.  Vnum: %d.\r\n", ch->in_room->name, ch->in_room->vnum );
mud_comm.c.backup:   for( mprg = ch->in_room->mudprogs; mprg; mprg = mprg->next )
mud_comm.c.backup:   if( ch->position == POS_FIGHTING
mud_comm.c.backup:       || ch->position == POS_EVASIVE
mud_comm.c.backup:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
mud_comm.c.backup:      for( obj = ch->first_carrying; obj; obj = obj_next )
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   was_in_room = ch->in_room;
mud_comm.c.backup:         ch->in_room = pexit->to_room;
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   ch->in_room = was_in_room;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   if( ch->pIndexData == pMobIndex )
mud_comm.c.backup:      victim->resetvnum = ch->resetvnum;
mud_comm.c.backup:      victim->resetnum = ch->resetnum;
mud_comm.c.backup:      ch->loadedself = true;
mud_comm.c.backup:   char_to_room( victim, ch->in_room );
mud_comm.c.backup:      obj_to_room( obj, ch->in_room );
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:      for( victim = ch->in_room->first_person; victim; victim = vnext )
mud_comm.c.backup:      while( ch->in_room->first_content )
mud_comm.c.backup:         extract_obj( ch->in_room->first_content );
mud_comm.c.backup:      ch->mobinvis = level;
mud_comm.c.backup:   if( ch->mobinvis < 2 )
mud_comm.c.backup:      ch->mobinvis = ch->level;
mud_comm.c.backup:   if( xIS_SET( ch->act, ACT_MOBINVIS ) )
mud_comm.c.backup:      xREMOVE_BIT( ch->act, ACT_MOBINVIS );
mud_comm.c.backup:      xSET_BIT( ch->act, ACT_MOBINVIS );
mud_comm.c.backup:   in_room = ch->in_room;
mud_comm.c.backup:   if( ch->fighting )
mud_comm.c.backup:      fch_next = fch->next_in_room;
mud_comm.c.backup:      if( fch->mount && fch->mount == ch )
mud_comm.c.backup:   original = ch->in_room;
mud_comm.c.backup:   if( victim->level > ch->level )
mud_comm.c.backup:   if( !ch->in_room )
mud_comm.c.backup:      destination = ch->in_room;
mud_comm.c.backup:      for( victim = ch->in_room->last_person; victim; victim = ChNext )
mud_comm.c.backup:             || ch->in_room->area != d->character->in_room->area
mud_comm.c.backup:      for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
mud_comm.c.backup:            mst = vch->mental_state;
mud_comm.c.backup:            vch->mental_state = 0;
mud_comm.c.backup:               drunk = vch->pcdata->condition[COND_DRUNK];
mud_comm.c.backup:               vch->pcdata->condition[COND_DRUNK] = 0;
mud_comm.c.backup:            vch->mental_state = mst;
mud_comm.c.backup:               vch->pcdata->condition[COND_DRUNK] = drunk;
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !ch->pcdata->nuisance )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:      vch_next = vch->next;
mud_comm.c.backup:      if( vch->in_room->area == ch->in_room->area && !IS_NPC( vch ) && IS_AWAKE( vch ) )
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:      for( victim = ch->in_room->first_person; victim; victim = nextinroom )
mud_comm.c.backup:             t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, ch->short_descr, argument );
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || IS_AFFECTED( ch, AFF_CHARM ) || ch->desc )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( gold <= ch->gold && ch->in_room )
mud_comm.c.backup:      ch->gold -= gold;
mud_comm.c.backup:      boost_economy( ch->in_room->area, gold );
mud_comm.c.backup:   if( ch->gold < 1000000000 && gold < 1000000000 && ch->in_room && economy_has( ch->in_room->area, gold ) )
mud_comm.c.backup:      ch->gold += gold;
mud_comm.c.backup:      lower_economy( ch->in_room->area, gold );
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:      for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
mud_comm.c.backup:         if( rch->fighting )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:                   victim->name, victim->level, ( IS_NPC( ch ) ? ch->short_descr : ch->name ), victim->in_room->vnum );
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_prog.c:         for( ch = first_char; ch; ch = ch->next )
mud_prog.c:                && ch->in_room
mud_prog.c:                && ch->in_room->area == chkchar->in_room->area
mud_prog.c:                && ch->desc && chkchar->desc && !str_cmp( ch->desc->host, chkchar->desc->host ) )
mud_prog.c:         for( ch = first_char; ch; ch = ch->next )
mud_prog.c:                && ch->desc && chkchar->desc && !str_cmp( ch->desc->host, chkchar->desc->host ) )
mud_prog.c:      for( ch = mob->in_room->first_person; ch; ch = ch->next_in_room )
mud_prog.c:         if( ( !IS_NPC( ch ) ) && get_trust( ch ) < LEVEL_IMMORTAL && nifty_is_name( ch->name, cvar ) )
mud_prog.c:      for( ch = first_char; ch; ch = ch->next )
mud_prog.c:             && ch->in_room->area == mob->in_room->area
mud_prog.c:             && get_trust( ch ) < LEVEL_IMMORTAL && nifty_is_name( ch->name, cvar ) )
mud_prog.c:      for( tch = room ? room->first_person : NULL; tch; tch = tch->next_in_room )
mud_prog.c:      for( tch = room ? room->first_person : NULL; tch; tch = tch->next_in_room )
mud_prog.c:      for( tch = room ? room->first_person : NULL; tch; tch = tch->next_in_room )
mud_prog.c:   for( vch = mob->in_room->first_person; vch; vch = vch->next_in_room )
mud_prog.c:      for( vch = mob->in_room->first_person; vch; vch = vch->next_in_room )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:   for( vmob = ch->in_room->first_person; vmob; vmob = vmob_next )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == vmob->pIndexData )
mud_prog.c:   for( vmob = ch->in_room->first_person; vmob; vmob = vmob_next )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == vmob->pIndexData )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:   for( vmob = ch->in_room->first_person; vmob; vmob = trvch_next( loop_ctrl ) )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == vmob->pIndexData )
mud_prog.c:      log_printf( "Greet_prog: too many mobs in room %d.", ch->in_room->vnum );
mud_prog.c:   for( vobj = ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:   for( vobj = ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:   for( vobj = ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:   if( HAS_PROG( ch->in_room, LEAVE_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, LOGIN_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, VOID_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, ENTER_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, IMMINFO_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, SLEEP_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, REST_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, RFIGHT_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, RDEATH_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, SPEECH_PROG ) )
mud_prog.c:      rprog_wordlist_check( txt, supermob, ch, NULL, NULL, NULL, SPEECH_PROG, ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, CMD_PROG ) )
mud_prog.c:      if( rprog_wordlist_check( txt, supermob, ch, NULL, NULL, NULL, CMD_PROG, ch->in_room ) )
mud_prog.c:   if( HAS_PROG( ch->in_room, RAND_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, TIME_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:      rprog_time_check( supermob, NULL, NULL, ch->in_room, TIME_PROG );
mud_prog.c:   if( HAS_PROG( ch->in_room, HOUR_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:      rprog_time_check( supermob, NULL, NULL, ch->in_room, HOUR_PROG );
mud_prog.c:         if( mpact->ch->in_room == room )
news.c:   switch ( ch->substate )
news.c:         news = ( NEWS * ) ch->dest_buf;
news.c:         ch->substate = ch->tempnum;
news.c:         news = ( NEWS * ) ch->dest_buf;
news.c:         ch->substate = ch->tempnum;
news.c:      news->name = STRALLOC( ch->name );
news.c:      if( ch->substate == SUB_REPEATCMD )
news.c:         ch->tempnum = SUB_REPEATCMD;
news.c:         ch->tempnum = SUB_NONE;
news.c:      ch->substate = SUB_NEWS_POST;
news.c:      ch->dest_buf = news;
news.c:      if( ch->substate == SUB_REPEATCMD )
news.c:         ch->tempnum = SUB_REPEATCMD;
news.c:         ch->tempnum = SUB_NONE;
news.c:      ch->substate = SUB_NEWS_EDIT;
news.c:      ch->dest_buf = news;
player.c:   ch_printf( ch, "You have %s gold pieces.\r\n", num_punct( ch->gold ) );
player.c:   pager_printf( ch, "\r\nWorth for %s%s.\r\n", ch->name, ch->pcdata->title );
player.c:   if( !ch->pcdata->deity )
player.c:   else if( ch->pcdata->favor > 2250 )
player.c:   else if( ch->pcdata->favor > 2000 )
player.c:   else if( ch->pcdata->favor > 1750 )
player.c:   else if( ch->pcdata->favor > 1500 )
player.c:   else if( ch->pcdata->favor > 1250 )
player.c:   else if( ch->pcdata->favor > 1000 )
player.c:   else if( ch->pcdata->favor > 750 )
player.c:   else if( ch->pcdata->favor > 250 )
player.c:   else if( ch->pcdata->favor > -250 )
player.c:   else if( ch->pcdata->favor > -750 )
player.c:   else if( ch->pcdata->favor > -1000 )
player.c:   else if( ch->pcdata->favor > -1250 )
player.c:   else if( ch->pcdata->favor > -1500 )
player.c:   else if( ch->pcdata->favor > -1750 )
player.c:   else if( ch->pcdata->favor > -2000 )
player.c:   else if( ch->pcdata->favor > -2250 )
player.c:   if( ch->level < 10 )
player.c:      if( ch->alignment > 900 )
player.c:      else if( ch->alignment > 700 )
player.c:      else if( ch->alignment > 350 )
player.c:      else if( ch->alignment > 100 )
player.c:      else if( ch->alignment > -100 )
player.c:      else if( ch->alignment > -350 )
player.c:      else if( ch->alignment > -700 )
player.c:      else if( ch->alignment > -900 )
player.c:      snprintf( buf2, MAX_STRING_LENGTH, "%d", ch->alignment );
player.c:   pager_printf( ch, "|Level: %-4d |Favor: %-10s |Alignment: %-9s |Experience: %-9d|\r\n", ch->level, buf, buf2, ch->exp );
player.c:   switch ( ch->style )
player.c:                 ch->pcdata->quest_curr, ch->carry_weight, buf, num_punct( ch->gold ) );
player.c:   if( ch->level < 15 && !IS_PKILL( ch ) )
player.c:   if( IS_NPC( ch ) && ch->Class < MAX_NPC_CLASS && ch->Class >= 0 )
player.c:      return ( npc_class[ch->Class] );
player.c:   else if( !IS_NPC( ch ) && ch->Class < MAX_PC_CLASS && ch->Class >= 0 )
player.c:      return class_table[ch->Class]->who_name;
player.c:   if( ch->race < MAX_PC_RACE && ch->race >= 0 )
player.c:      return ( race_table[ch->race]->race_name );
player.c:   if( ch->race < MAX_NPC_RACE && ch->race >= 0 )
player.c:      return ( npc_race[ch->race] );
player.c:   if( ch->level == 1 )
player.c:      lowlvl = UMAX( 2, ch->level - 5 );
player.c:   hilvl = URANGE( ch->level, ch->level + 5, MAX_LEVEL );
player.c:   snprintf( buf, MAX_STRING_LENGTH, " exp  (Current: %12s)", num_punct( ch->exp ) );
player.c:   snprintf( buf2, MAX_STRING_LENGTH, " exp  (Needed:  %12s)", num_punct( exp_level( ch, ch->level + 1 ) - ch->exp ) );
player.c:                 ( x == ch->level ) ? buf : ( x == ch->level + 1 ) ? buf2 : " exp" );
player.c:   if( !ch->pcdata->deity )
player.c:   if( ch->pcdata->favor < ch->level * 2 )
player.c:   pager_printf( ch, "%s appears in a vision, revealing that your remains... ", ch->pcdata->deity->name );
player.c:   snprintf( buf, MAX_STRING_LENGTH, "the corpse of %s", ch->name );
player.c:      ch->pcdata->favor -= ch->level * 2;
player.c:      ch_printf_color( ch, "&C%s\r\n", !xIS_EMPTY( ch->affected_by ) ? affect_bit_name( &ch->affected_by ) : "nothing" );
player.c:      if( ch->level >= 20 )
player.c:         if( ch->resistant > 0 )
player.c:            ch_printf_color( ch, "&C%s\r\n", flag_string( ch->resistant, ris_flags ) );
player.c:         if( ch->immune > 0 )
player.c:            ch_printf_color( ch, "&C%s\r\n", flag_string( ch->immune, ris_flags ) );
player.c:         if( ch->susceptible > 0 )
player.c:            ch_printf_color( ch, "&C%s\r\n", flag_string( ch->susceptible, ris_flags ) );
player.c:   if( !ch->first_affect )
player.c:      for( paf = ch->first_affect; paf; paf = paf->next )
player.c:            if( ch->level >= 20 || IS_PKILL( ch ) )
player.c:   STRFREE( ch->pcdata->title );
player.c:   ch->pcdata->title = STRALLOC( buf );
player.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ) )
player.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOCPOSE ) )
player.c:      if( !ch->pcdata->cpose )
player.c:         ch->pcdata->cpose = str_dup( "" );
player.c:      ch_printf( ch, "Your cpose is: %s\r\n", show_tilde( ch->pcdata->cpose ) );
player.c:      if( ch->pcdata->cpose )
player.c:         DISPOSE( ch->pcdata->cpose );
player.c:      ch->pcdata->cpose = str_dup( "" );
player.c:   if( ch->pcdata->cpose )
player.c:      DISPOSE( ch->pcdata->cpose );
player.c:   ch->pcdata->cpose = str_dup( buf );
player.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NODESC ) )
player.c:   if( !ch->desc )
player.c:   switch ( ch->substate )
player.c:         ch->substate = SUB_PERSONAL_DESC;
player.c:         ch->dest_buf = ch;
player.c:         start_editing( ch, ch->description );
player.c:         STRFREE( ch->description );
player.c:         ch->description = copy_buffer( ch );
player.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOBIO ) )
player.c:   if( !ch->desc )
player.c:   switch ( ch->substate )
player.c:         ch->substate = SUB_PERSONAL_BIO;
player.c:         ch->dest_buf = ch;
player.c:         start_editing( ch, ch->pcdata->bio );
player.c:         STRFREE( ch->pcdata->bio );
player.c:         ch->pcdata->bio = copy_buffer( ch );
player.c:                 ch->hit, ch->max_hit, ch->pcdata->condition[COND_BLOODTHIRST],
player.c:                 10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:                ch->hit, ch->max_hit, ch->pcdata->condition[COND_BLOODTHIRST],
player.c:                10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:                 ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:                ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:              ch->perm_str, ch->perm_wis, ch->perm_int, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
player.c:             ch->perm_str, ch->perm_wis, ch->perm_int, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
player.c:                 ch->hit, ch->max_hit, ch->pcdata->condition[COND_BLOODTHIRST],
player.c:                 10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:                 ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:              ch->perm_str, ch->perm_wis, ch->perm_int, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
player.c:   if( IS_NPC( ch ) && ch->fighting )
player.c:                 ch->hit, ch->max_hit,
player.c:                 ch->pcdata->condition[COND_BLOODTHIRST], 10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:                 ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:                ch->hit, ch->max_hit,
player.c:                ch->pcdata->condition[COND_BLOODTHIRST], 10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:                ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:      ch_printf( ch, "%s\r\n", !str_cmp( ch->pcdata->fprompt, "" ) ? "(default prompt)" : ch->pcdata->fprompt );
player.c:   ch_printf( ch, "%s\r\n", !str_cmp( ch->pcdata->fprompt, "" ) ? "(default prompt)" : ch->pcdata->fprompt );
player.c:   if( ch->pcdata->fprompt )
player.c:      STRFREE( ch->pcdata->fprompt );
player.c:      ch->pcdata->fprompt = STRALLOC( "" );
player.c:      ch->pcdata->fprompt = STRALLOC( ch->pcdata->prompt );
player.c:      ch->pcdata->fprompt = STRALLOC( argument );
player.c:      ch_printf( ch, "%s\r\n", !str_cmp( ch->pcdata->prompt, "" ) ? "(default prompt)" : ch->pcdata->prompt );
player.c:   ch_printf( ch, "%s\r\n", !str_cmp( ch->pcdata->prompt, "" ) ? "(default prompt)" : ch->pcdata->prompt );
player.c:   if( ch->pcdata->prompt )
player.c:      STRFREE( ch->pcdata->prompt );
player.c:      ch->pcdata->prompt = STRALLOC( "" );
player.c:      ch->pcdata->prompt = STRALLOC( ch->pcdata->fprompt );
player.c:      ch->pcdata->prompt = STRALLOC( argument );
player.c:      if( xIS_SET( ch->act, PLR_COMPASS ) )
player.c:         xREMOVE_BIT( ch->act, PLR_COMPASS );
player.c:         xSET_BIT( ch->act, PLR_COMPASS );
player.c:   if( !ch->pcdata->deity )
player.c:   else if( ch->pcdata->favor > 2250 )
player.c:   else if( ch->pcdata->favor > 2000 )
player.c:   else if( ch->pcdata->favor > 1750 )
player.c:   else if( ch->pcdata->favor > 1500 )
player.c:   else if( ch->pcdata->favor > 1250 )
player.c:   else if( ch->pcdata->favor > 1000 )
player.c:   else if( ch->pcdata->favor > 750 )
player.c:   else if( ch->pcdata->favor > 250 )
player.c:   else if( ch->pcdata->favor > -250 )
player.c:   else if( ch->pcdata->favor > -750 )
player.c:   else if( ch->pcdata->favor > -1000 )
player.c:   else if( ch->pcdata->favor > -1250 )
player.c:   else if( ch->pcdata->favor > -1500 )
player.c:   else if( ch->pcdata->favor > -1750 )
player.c:   else if( ch->pcdata->favor > -2000 )
player.c:   else if( ch->pcdata->favor > -2250 )
player.c:   ch_printf( ch, "%s considers you to be %s.\n\r", ch->pcdata->deity->name, buf );
polymorph.c:   if( ch->level < morph->level )
polymorph.c:   if( morph->sex != -1 && morph->sex != ch->sex )
polymorph.c:   if( morph->Class != 0 && !IS_SET( morph->Class, ( 1 << ch->Class ) ) )
polymorph.c:   if( morph->race != 0 && IS_SET( morph->race, ( 1 << ch->race ) ) )
polymorph.c:   if( morph->deity && ( !ch->pcdata->deity || !get_deity( morph->deity ) ) )
polymorph.c:   if( !ch->desc )
polymorph.c:   switch ( ch->substate )
polymorph.c:         if( !ch->dest_buf )
polymorph.c:            bug( "%s", "do_morphset: sub_morph_desc: NULL ch->dest_buf" );
polymorph.c:            ch->substate = SUB_NONE;
polymorph.c:         morph = ( MORPH_DATA * ) ch->dest_buf;
polymorph.c:         ch->substate = ch->tempnum;
polymorph.c:         if( ch->substate == SUB_REPEATCMD )
polymorph.c:            ch->dest_buf = morph;
polymorph.c:         if( !ch->dest_buf )
polymorph.c:            bug( "%s", "do_morphset: sub_morph_help: NULL ch->dest_buf" );
polymorph.c:            ch->substate = SUB_NONE;
polymorph.c:         morph = ( MORPH_DATA * ) ch->dest_buf;
polymorph.c:         ch->substate = ch->tempnum;
polymorph.c:         if( ch->substate == SUB_REPEATCMD )
polymorph.c:            ch->dest_buf = morph;
polymorph.c:   if( ch->substate == SUB_REPEATCMD )
polymorph.c:      morph = ( MORPH_DATA * ) ch->dest_buf;
polymorph.c:         ch->substate = SUB_NONE;
polymorph.c:         ch->dest_buf = NULL;
polymorph.c:         STRFREE( ch->pcdata->subprompt );
polymorph.c:   if( ch->substate != SUB_REPEATCMD && arg1[0] != '\0' && !str_cmp( arg1, "save" ) )
polymorph.c:   if( arg1[0] == '\0' || ( arg2[0] == '\0' && ch->substate != SUB_REPEATCMD ) || !str_cmp( arg1, "?" ) )
polymorph.c:      if( ch->substate == SUB_REPEATCMD )
polymorph.c:      ch->substate = SUB_REPEATCMD;
polymorph.c:      ch->dest_buf = morph;
polymorph.c:      STRFREE( ch->pcdata->subprompt );
polymorph.c:      ch->pcdata->subprompt = STRALLOC( buf );
polymorph.c:      if( ch->substate == SUB_REPEATCMD )
polymorph.c:         ch->tempnum = SUB_REPEATCMD;
polymorph.c:         ch->tempnum = SUB_NONE;
polymorph.c:      ch->substate = SUB_MORPH_DESC;
polymorph.c:      ch->dest_buf = morph;
polymorph.c:      if( ch->substate == SUB_REPEATCMD )
polymorph.c:         ch->tempnum = SUB_REPEATCMD;
polymorph.c:         ch->tempnum = SUB_NONE;
polymorph.c:      ch->substate = SUB_MORPH_HELP;
polymorph.c:      ch->dest_buf = morph;
polymorph.c:   else if( ch->substate == SUB_REPEATCMD )
polymorph.c:      ch->substate = SUB_RESTRICTED;
polymorph.c:      ch->substate = SUB_REPEATCMD;
polymorph.c:      ch->last_cmd = do_morphset;
polymorph.c:   if( ch->morph )
polymorph.c:   ch->armor += morph->ac;
polymorph.c:   ch->mod_str += morph->str;
polymorph.c:   ch->mod_int += morph->inte;
polymorph.c:   ch->mod_wis += morph->wis;
polymorph.c:   ch->mod_dex += morph->dex;
polymorph.c:   ch->mod_cha += morph->cha;
polymorph.c:   ch->mod_lck += morph->lck;
polymorph.c:   ch->saving_breath += morph->saving_breath;
polymorph.c:   ch->saving_para_petri += morph->saving_para_petri;
polymorph.c:   ch->saving_poison_death += morph->saving_poison_death;
polymorph.c:   ch->saving_spell_staff += morph->saving_spell_staff;
polymorph.c:   ch->saving_wand += morph->saving_wand;
polymorph.c:   ch->hitroll += ch_morph->hitroll;
polymorph.c:   ch->damroll += ch_morph->damroll;
polymorph.c:   if( ( ch->hit + ch_morph->hit ) > 32700 )
polymorph.c:      ch_morph->hit = ( 32700 - ch->hit );
polymorph.c:   ch->hit += ch_morph->hit;
polymorph.c:   if( ( ch->move + ch_morph->move ) > 32700 )
polymorph.c:      ch_morph->move = ( 32700 - ch->move );
polymorph.c:   ch->move += ch_morph->move;
polymorph.c:   if( ( ch->mana + ch_morph->mana ) > 32700 )
polymorph.c:      ch_morph->mana = ( 32700 - ch->mana );
polymorph.c:   ch->mana += ch_morph->mana;
polymorph.c:   xSET_BITS( ch->affected_by, morph->affected_by );
polymorph.c:   SET_BIT( ch->immune, morph->immune );
polymorph.c:   SET_BIT( ch->resistant, morph->resistant );
polymorph.c:   SET_BIT( ch->susceptible, morph->suscept );
polymorph.c:   xREMOVE_BITS( ch->affected_by, morph->no_affected_by );
polymorph.c:   REMOVE_BIT( ch->immune, morph->no_immune );
polymorph.c:   REMOVE_BIT( ch->resistant, morph->no_resistant );
polymorph.c:   REMOVE_BIT( ch->susceptible, morph->no_suscept );
polymorph.c:   ch->morph = ch_morph;
polymorph.c:   if( ch->morph )
polymorph.c:      if( ch->hit < morph->hpused )
polymorph.c:         ch->hit -= morph->hpused;
polymorph.c:      if( ch->move < morph->moveused )
polymorph.c:         ch->move -= morph->moveused;
polymorph.c:      if( ch->mana < morph->manaused )
polymorph.c:         ch->mana -= morph->manaused;
polymorph.c:      if( IS_NPC( ch ) || !ch->pcdata->deity || ch->pcdata->favor < morph->favourused )
polymorph.c:         ch->pcdata->favor -= morph->favourused;
polymorph.c:   if( ( morph = ch->morph ) == NULL )
polymorph.c:   ch->armor -= morph->ac;
polymorph.c:   ch->mod_str -= morph->str;
polymorph.c:   ch->mod_int -= morph->inte;
polymorph.c:   ch->mod_wis -= morph->wis;
polymorph.c:   ch->mod_dex -= morph->dex;
polymorph.c:   ch->mod_cha -= morph->cha;
polymorph.c:   ch->mod_lck -= morph->lck;
polymorph.c:   ch->saving_breath -= morph->saving_breath;
polymorph.c:   ch->saving_para_petri -= morph->saving_para_petri;
polymorph.c:   ch->saving_poison_death -= morph->saving_poison_death;
polymorph.c:   ch->saving_spell_staff -= morph->saving_spell_staff;
polymorph.c:   ch->saving_wand -= morph->saving_wand;
polymorph.c:   ch->hitroll -= morph->hitroll;
polymorph.c:   ch->damroll -= morph->damroll;
polymorph.c:   ch->hit -= morph->hit;
polymorph.c:   ch->move -= morph->move;
polymorph.c:   ch->mana -= morph->mana;
polymorph.c:   if( ch->mana > ch->max_mana )
polymorph.c:      ch->mana = ch->max_mana;
polymorph.c:   xREMOVE_BITS( ch->affected_by, morph->affected_by );
polymorph.c:   REMOVE_BIT( ch->immune, morph->immune );
polymorph.c:   REMOVE_BIT( ch->resistant, morph->resistant );
polymorph.c:   REMOVE_BIT( ch->susceptible, morph->suscept );
polymorph.c:   DISPOSE( ch->morph );
polymorph.c:   if( !ch->morph )
polymorph.c:   temp = ch->morph->morph;
polymorph.c:   if( !ch->morph )
polymorph.c:   for( vch = first_char; vch; vch = vch->next )
polymorph.c:      if( vch->morph == NULL || vch->morph->morph == NULL || vch->morph->morph != morph )
polymorph.c:   if( ch->morph == NULL )
polymorph.c:   morph = ch->morph;
polymorph.c:   ch->morph = morph;
renumber.c:   if( ch->level < LEVEL_SAVIOR )
renumber.c:   if( ch->level == LEVEL_SAVIOR )
renumber.c:      if( area->low_r_vnum < ch->pcdata->r_range_lo || area->hi_r_vnum > ch->pcdata->r_range_hi ||
renumber.c:          area->low_m_vnum < ch->pcdata->m_range_lo || area->hi_m_vnum > ch->pcdata->m_range_hi ||
renumber.c:          area->low_o_vnum < ch->pcdata->o_range_lo || area->hi_o_vnum > ch->pcdata->o_range_hi )
renumber.c:   if( ch->level == LEVEL_SAVIOR )
renumber.c:      if( r_area->low_room < ch->pcdata->r_range_lo || r_area->hi_room > ch->pcdata->r_range_hi ||
renumber.c:          r_area->low_obj < ch->pcdata->o_range_lo || r_area->hi_obj > ch->pcdata->o_range_hi ||
renumber.c:          r_area->low_mob < ch->pcdata->m_range_lo || r_area->hi_mob > ch->pcdata->m_range_hi )
reset.c:   for( rch = pRoom->first_person; rch; rch = rch->next_in_room )
reset.c:      add_reset( pRoom, 'M', 1, rch->pIndexData->vnum, rch->pIndexData->count, pRoom->vnum );
reset.c:      for( obj = rch->first_carrying; obj; obj = obj->next_content )
reset.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_SAVIOR || !ch->pcdata->area )
reset.c:   if( !can_rmodify( ch, ch->in_room ) )
reset.c:   if( ch->in_room->area != ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER )
reset.c:   if( ch->in_room->first_reset )
reset.c:      wipe_resets( ch->in_room );
reset.c:   instaroom( ch->in_room, dodoors );
reset.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_SAVIOR || !ch->pcdata->area )
reset.c:   pArea = ch->pcdata->area;
reset.c:      reset_area( ch->in_room->area );
reset.c:      for( room = ch->in_room->area->first_room; room; room = room->next_aroom )
reset.c:      for( pReset = ch->in_room->first_reset; pReset; pReset = pReset_next )
reset.c:            UNLINK( pReset, ch->in_room->first_reset, ch->in_room->last_reset, next, prev );
reset.c:      pReset = make_reset( 'R', 0, ch->in_room->vnum, door, 0 );
reset.c:      pReset->next = ch->in_room->first_reset;
reset.c:      if( ch->in_room->first_reset )
reset.c:         ch->in_room->first_reset->prev = pReset;
reset.c:      ch->in_room->first_reset = pReset;
reset.c:      if( !ch->in_room->last_reset )
reset.c:         ch->in_room->last_reset = pReset;
reset.c:         vnum = ch->in_room->vnum;
reset.c:         if( !( pReset = find_oreset( ch->in_room, oname ) ) )
reset.c:         tReset->next = ch->in_room->first_reset;
reset.c:         if( ch->in_room->first_reset )
reset.c:            ch->in_room->first_reset->prev = tReset;
reset.c:         ch->in_room->first_reset = tReset;
reset.c:         if( !ch->in_room->last_reset )
reset.c:            ch->in_room->last_reset = tReset;
reset.c:      if( !( pReset = find_oreset( ch->in_room, argument ) ) )
reset.c:         tReset->next = ch->in_room->first_reset;
reset.c:         if( ch->in_room->first_reset )
reset.c:            ch->in_room->first_reset->prev = tReset;
reset.c:         ch->in_room->first_reset = tReset;
reset.c:         if( !ch->in_room->last_reset )
reset.c:            ch->in_room->last_reset = tReset;
reset.c:   if( ch->loadedself )
reset.c:   if( !( room = get_room_index( ch->resetvnum ) ) )
reset.c:      if( ++nfind == ch->resetnum )
reset.c:         if( ++nfind == ch->resetnum )
reset.c:            if( ++nfind == ch->resetnum )
save.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
save.c:                    ch->name, MAX_LAYERS, obj->wear_loc, obj->name );
save.c:            bug( "%s had on %s:  ch->level = %d  obj->level = %d", ch->name, obj->name, ch->level, obj->level );
save.c:   if( ch->in_room )
save.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
save.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
save.c:   if( ch->in_room )
save.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
save.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
save.c:   age = ch->played / 86400;   /* Calculate realtime number of days played */
save.c:   ch->pcdata->day = ( number_range( 1, sysdata.dayspermonth ) - 1 );   /* Assign random day of birth */
save.c:   ch->pcdata->month = ( number_range( 1, sysdata.monthsperyear ) - 1 );   /* Assign random month of birth */
save.c:   ch->pcdata->year = time_info.year - age;  /* Assign birth year based on calculations above */
save.c:   if( IS_NPC( ch ) || ch->level < 2 )
save.c:   if( ch->desc && ch->desc->original )
save.c:      ch = ch->desc->original;
save.c:   ch->save_time = current_time;
save.c:   snprintf( strsave, MAX_INPUT_LENGTH, "%s%c/%s", PLAYER_DIR, tolower( ch->pcdata->filename[0] ),
save.c:             capitalize( ch->pcdata->filename ) );
save.c:      snprintf( strback, MAX_INPUT_LENGTH, "%s%c/%s", BACKUP_DIR, tolower( ch->pcdata->filename[0] ),
save.c:                capitalize( ch->pcdata->filename ) );
save.c:   if( ch->level >= LEVEL_IMMORTAL || IS_SET( ch->pcdata->flags, PCFLAG_RETIRED ) )
save.c:      snprintf( strback, MAX_INPUT_LENGTH, "%s%s", GOD_DIR, capitalize( ch->pcdata->filename ) );
save.c:         fprintf( fp, "Level        %d\n", ch->level );
save.c:         fprintf( fp, "Pcflags      %d\n", ch->pcdata->flags );
save.c:         if( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
save.c:            fprintf( fp, "RoomRange    %d %d\n", ch->pcdata->r_range_lo, ch->pcdata->r_range_hi );
save.c:         if( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
save.c:            fprintf( fp, "ObjRange     %d %d\n", ch->pcdata->o_range_lo, ch->pcdata->o_range_hi );
save.c:         if( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
save.c:            fprintf( fp, "MobRange     %d %d\n", ch->pcdata->m_range_lo, ch->pcdata->m_range_hi );
save.c:      if( ch->morph )
save.c:      if( ch->first_carrying )
save.c:         fwrite_obj( ch, ch->last_carrying, fp, 0, OS_CARRY, ch->pcdata->hotboot );
save.c:      if( sysdata.save_pets && ch->pcdata->pet )
save.c:         fwrite_mobile( fp, ch->pcdata->pet );
save.c:      if( ch->variables )
save.c:      if( ch->comments )   /* comments */
save.c:   fprintf( fp, "Name         %s~\n", ch->name );
save.c:   if( ch->description[0] != '\0' )
save.c:      fprintf( fp, "Description  %s~\n", ch->description );
save.c:   fprintf( fp, "Sex          %d\n", ch->sex );
save.c:   fprintf( fp, "Class        %d\n", ch->Class );
save.c:   fprintf( fp, "Race         %d\n", ch->race );
save.c:            ch->pcdata->age_bonus, ch->pcdata->day, ch->pcdata->month, ch->pcdata->year );
save.c:   fprintf( fp, "Languages    %d %d\n", ch->speaks, ch->speaking );
save.c:   fprintf( fp, "Level        %d\n", ch->level );
save.c:   fprintf( fp, "Played       %d\n", ch->played + ( int )( current_time - ch->logon ) );
save.c:            ( ch->in_room == get_room_index( ROOM_VNUM_LIMBO )
save.c:              && ch->was_in_room ) ? ch->was_in_room->vnum : ch->in_room->vnum );
save.c:   fprintf( fp, "HpManaMove   %d %d %d %d %d %d\n", ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move );
save.c:   fprintf( fp, "Gold         %d\n", ch->gold );
save.c:   fprintf( fp, "Exp          %d\n", ch->exp );
save.c:   fprintf( fp, "Height          %d\n", ch->height );
save.c:   fprintf( fp, "Weight          %d\n", ch->weight );
save.c:   fprintf( fp, "Str          %d\n", ch->pcdata->str );
save.c:   fprintf( fp, "Intel          %d\n", ch->pcdata->intel );
save.c:   fprintf( fp, "Dex         %d\n", ch->pcdata->dex );
save.c:   fprintf( fp, "Lck          %d\n", ch->pcdata->lck );
save.c:   fprintf( fp, "Att          %d\n", ch->pcdata->att );
save.c:   fprintf( fp, "Def          %d\n", ch->pcdata->def );
save.c:   fprintf( fp, "Matt          %d\n", ch->pcdata->matt );
save.c:   fprintf( fp, "Mdef          %d\n", ch->pcdata->mdef );
save.c:   fprintf( fp, "strplus          %d\n", ch->pcdata->strplus );
save.c:   fprintf( fp, "intplus          %d\n", ch->pcdata->intplus );
save.c:   fprintf( fp, "dexplus          %d\n", ch->pcdata->dexplus );
save.c:   fprintf( fp, "lckplus          %d\n", ch->pcdata->lckplus );
save.c:   fprintf( fp, "attplus          %d\n", ch->pcdata->attplus );
save.c:   fprintf( fp, "defplus          %d\n", ch->pcdata->defplus );
save.c:   fprintf( fp, "mattplus          %d\n", ch->pcdata->mattplus );
save.c:   fprintf( fp, "mdefplus          %d\n", ch->pcdata->mdefplus );
save.c:   fprintf( fp, "mlevel          %d\n", ch->pcdata->mlevel );
save.c:   fprintf( fp, "deflevel          %d\n", ch->pcdata->deflevel );
save.c:   fprintf( fp, "attlevel          %d\n", ch->pcdata->attlevel );
save.c:   if( !xIS_EMPTY( ch->act ) )
save.c:      fprintf( fp, "Act          %s\n", print_bitvector( &ch->act ) );
save.c:   if( !xIS_EMPTY( ch->affected_by ) )
save.c:      fprintf( fp, "AffectedBy   %s\n", print_bitvector( &ch->affected_by ) );
save.c:   if( !xIS_EMPTY( ch->no_affected_by ) )
save.c:      fprintf( fp, "NoAffectedBy %s\n", print_bitvector( &ch->no_affected_by ) );
save.c:   pos = ch->position;
save.c:   fprintf( fp, "Style     %d\n", ch->style );
save.c:   fprintf( fp, "Practice     %d\n", ch->practice );
save.c:            ch->saving_poison_death, ch->saving_wand, ch->saving_para_petri, ch->saving_breath, ch->saving_spell_staff );
save.c:   fprintf( fp, "Alignment    %d\n", ch->alignment );
save.c:   fprintf( fp, "Favor        %d\n", ch->pcdata->favor );
save.c:   fprintf( fp, "Balance      %d\n", ch->pcdata->balance );
save.c:   fprintf( fp, "Glory        %d\n", ch->pcdata->quest_curr );
save.c:   fprintf( fp, "MGlory       %d\n", ch->pcdata->quest_accum );
save.c:   fprintf( fp, "Ap        %d\n", ch->pcdata->ap );   
save.c:   fprintf( fp, "Tier        %d\n", ch->pcdata->tier );   
save.c:   fprintf( fp, "Hitroll      %d\n", ch->hitroll );
save.c:   fprintf( fp, "Damroll      %d\n", ch->damroll );
save.c:   fprintf( fp, "Armor        %d\n", ch->armor );
save.c:   if( ch->wimpy )
save.c:      fprintf( fp, "Wimpy        %d\n", ch->wimpy );
save.c:   if( ch->deaf )
save.c:      fprintf( fp, "Deaf         %d\n", ch->deaf );
save.c:   if( ch->resistant )
save.c:      fprintf( fp, "Resistant    %d\n", ch->resistant );
save.c:   if( ch->no_resistant )
save.c:      fprintf( fp, "NoResistant  %d\n", ch->no_resistant );
save.c:   if( ch->immune )
save.c:      fprintf( fp, "Immune       %d\n", ch->immune );
save.c:   if( ch->no_immune )
save.c:      fprintf( fp, "NoImmune     %d\n", ch->no_immune );
save.c:   if( ch->susceptible )
save.c:      fprintf( fp, "Susceptible  %d\n", ch->susceptible );
save.c:   if( ch->no_susceptible )
save.c:      fprintf( fp, "NoSusceptible  %d\n", ch->no_susceptible );
save.c:   if( ch->pcdata && ch->pcdata->outcast_time )
save.c:      fprintf( fp, "Outcast_time %ld\n", ch->pcdata->outcast_time );
save.c:   if( ch->pcdata && ch->pcdata->nuisance )
save.c:      fprintf( fp, "NuisanceNew %ld %ld %d %d\n", ch->pcdata->nuisance->set_time,
save.c:               ch->pcdata->nuisance->max_time, ch->pcdata->nuisance->flags, ch->pcdata->nuisance->power );
save.c:   if( ch->mental_state != -10 )
save.c:      fprintf( fp, "Mentalstate  %d\n", ch->mental_state );
save.c:   fprintf( fp, "Password     %s~\n", ch->pcdata->pwd );
save.c:   if( ch->pcdata->rank && ch->pcdata->rank[0] != '\0' )
save.c:      fprintf( fp, "Rank         %s~\n", ch->pcdata->rank );
save.c:   if( ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0' )
save.c:      fprintf( fp, "Bestowments  %s~\n", ch->pcdata->bestowments );
save.c:   fprintf( fp, "Title        %s~\n", ch->pcdata->title );
save.c:   fprintf( fp, "Cpose        %s~\n", ch->pcdata->cpose );
save.c:   fprintf( fp, "Hometown        %s~\n", ch->pcdata->hometown );
save.c:   fprintf( fp, "Customclass        %s~\n", ch->pcdata->customclass );
save.c:   if( ch->pcdata->homepage && ch->pcdata->homepage[0] != '\0' )
save.c:      fprintf( fp, "Homepage     %s~\n", ch->pcdata->homepage );
save.c:   if( ch->pcdata->bio && ch->pcdata->bio[0] != '\0' )
save.c:      fprintf( fp, "Bio          %s~\n", ch->pcdata->bio );
save.c:   if( ch->pcdata->authed_by && ch->pcdata->authed_by[0] != '\0' )
save.c:      fprintf( fp, "AuthedBy     %s~\n", ch->pcdata->authed_by );
save.c:   if( ch->pcdata->min_snoop )
save.c:      fprintf( fp, "Minsnoop     %d\n", ch->pcdata->min_snoop );
save.c:   if( ch->pcdata->prompt && *ch->pcdata->prompt )
save.c:      fprintf( fp, "Prompt       %s~\n", ch->pcdata->prompt );
save.c:   if( ch->pcdata->fprompt && *ch->pcdata->fprompt )
save.c:      fprintf( fp, "FPrompt	     %s~\n", ch->pcdata->fprompt );
save.c:   if( ch->pcdata->pagerlen != 24 )
save.c:      fprintf( fp, "Pagerlen     %d\n", ch->pcdata->pagerlen );
save.c:      for( temp = ch->pcdata->first_ignored; temp; temp = temp->next )
save.c:      if( ch->pcdata->bamfin && ch->pcdata->bamfin[0] != '\0' )
save.c:         fprintf( fp, "Bamfin       %s~\n", ch->pcdata->bamfin );
save.c:      if( ch->pcdata->bamfout && ch->pcdata->bamfout[0] != '\0' )
save.c:         fprintf( fp, "Bamfout      %s~\n", ch->pcdata->bamfout );
save.c:      if( ch->trust )
save.c:         fprintf( fp, "Trust        %d\n", ch->trust );
save.c:      if( ch->pcdata && ch->pcdata->restore_time )
save.c:         fprintf( fp, "Restore_time %ld\n", ch->pcdata->restore_time );
save.c:      fprintf( fp, "WizInvis     %d\n", ch->pcdata->wizinvis );
save.c:      if( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
save.c:         fprintf( fp, "RoomRange    %d %d\n", ch->pcdata->r_range_lo, ch->pcdata->r_range_hi );
save.c:      if( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
save.c:         fprintf( fp, "ObjRange     %d %d\n", ch->pcdata->o_range_lo, ch->pcdata->o_range_hi );
save.c:      if( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
save.c:         fprintf( fp, "MobRange     %d %d\n", ch->pcdata->m_range_lo, ch->pcdata->m_range_hi );
save.c:   if( ch->pcdata->council )
save.c:      fprintf( fp, "Council      %s~\n", ch->pcdata->council_name );
save.c:   if( ch->pcdata->deity_name && ch->pcdata->deity_name[0] != '\0' )
save.c:      fprintf( fp, "Deity	     %s~\n", ch->pcdata->deity_name );
save.c:   if( ch->pcdata->clan_name && ch->pcdata->clan_name[0] != '\0' )
save.c:      fprintf( fp, "Clan         %s~\n", ch->pcdata->clan_name );
save.c:   fprintf( fp, "Flags        %d\n", ch->pcdata->flags );
save.c:   if( ch->pcdata->release_date )
save.c:      fprintf( fp, "Helled       %d %s~\n", ( int )ch->pcdata->release_date, ch->pcdata->helled_by );
save.c:   fprintf( fp, "PKills       %d\n", ch->pcdata->pkills );
save.c:   fprintf( fp, "PDeaths      %d\n", ch->pcdata->pdeaths );
save.c:   fprintf( fp, "MKills       %d\n", ch->pcdata->mkills );
save.c:   fprintf( fp, "MDeaths      %d\n", ch->pcdata->mdeaths );
save.c:   fprintf( fp, "IllegalPK    %d\n", ch->pcdata->illegal_pk );
save.c:   fprintf( fp, "Timezone     %d\n", ch->pcdata->timezone );
save.c:            ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
save.c:            ch->mod_str, ch->mod_int, ch->mod_wis, ch->mod_dex, ch->mod_con, ch->mod_cha, ch->mod_lck );
save.c:            ch->pcdata->condition[0], ch->pcdata->condition[1], ch->pcdata->condition[2], ch->pcdata->condition[3] );
save.c:   if( ch->pcdata->recent_site )
save.c:      fprintf( fp, "Site         %s\n", ch->pcdata->recent_site );
save.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) && !IS_IMMORTAL( ch ) )
save.c:            if( tmphome->vnum[i] == ch->in_room->vnum )
save.c:         if( ch->in_room->vnum == tmphb->vnum )
save.c:      if( skill_table[sn]->name && ch->pcdata->learned[sn] > 0 )
save.c:               fprintf( fp, "Skill        %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:               fprintf( fp, "Ability      %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:               fprintf( fp, "Spell        %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:               fprintf( fp, "Weapon       %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:               fprintf( fp, "Tongue       %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:   for( paf = ch->first_affect; paf; paf = paf->next )
save.c:   track = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
save.c:      if( ch->pcdata->killed[sn].vnum == 0 )
save.c:      fprintf( fp, "Killed       %d %d\n", ch->pcdata->killed[sn].vnum, ch->pcdata->killed[sn].count );
save.c:         fprintf( fp, "%d ", ch->colors[x] );
save.c:      if( (ch && ch->level < obj->level)
save.c:   CREATE( ch->pcdata, PC_DATA, 1 );
save.c:   ch->desc = d;
save.c:   ch->pcdata->filename = STRALLOC( name );
save.c:   ch->name = NULL;
save.c:      ch->pcdata->recent_site = STRALLOC( d->host );
save.c:   ch->act = multimeb( PLR_BLANK, PLR_COMBINE, PLR_PROMPT, -1 );
save.c:   ch->perm_str = 13;
save.c:   ch->perm_int = 13;
save.c:   ch->perm_wis = 13;
save.c:   ch->perm_dex = 13;
save.c:   ch->perm_con = 13;
save.c:   ch->perm_cha = 13;
save.c:   ch->perm_lck = 13;
save.c:   ch->no_resistant = 0;
save.c:   ch->no_susceptible = 0;
save.c:   ch->no_immune = 0;
save.c:   ch->was_in_room = NULL;
save.c:   xCLEAR_BITS( ch->no_affected_by );
save.c:   ch->pcdata->condition[COND_THIRST] = 48;
save.c:   ch->pcdata->condition[COND_FULL] = 48;
save.c:   ch->pcdata->condition[COND_BLOODTHIRST] = 10;
save.c:   ch->pcdata->nuisance = NULL;
save.c:   ch->pcdata->wizinvis = 0;
save.c:   ch->pcdata->balance = 0;
save.c:   ch->pcdata->charmies = 0;
save.c:   ch->mental_state = -10;
save.c:   ch->mobinvis = 0;
save.c:      ch->pcdata->learned[i] = 0;
save.c:   ch->pcdata->release_date = 0;
save.c:   ch->pcdata->helled_by = NULL;
save.c:   ch->saving_poison_death = 0;
save.c:   ch->saving_wand = 0;
save.c:   ch->saving_para_petri = 0;
save.c:   ch->saving_breath = 0;
save.c:   ch->saving_spell_staff = 0;
save.c:   ch->style = STYLE_FIGHTING;
save.c:   ch->comments = NULL; /* comments */
save.c:   ch->pcdata->pagerlen = 24;
save.c:   ch->pcdata->first_ignored = NULL;   /* Ignore list */
save.c:   ch->pcdata->last_ignored = NULL;
save.c:   ch->pcdata->tell_history = NULL; /* imm only lasttell cmnd */
save.c:   ch->pcdata->lt_index = 0;  /* last tell index */
save.c:   ch->morph = NULL;
save.c:   ch->pcdata->hotboot = FALSE;  /* Never changed except when PC is saved during hotboot save */
save.c:                          preload ? "Preloading" : "Loading", ch->pcdata->filename, ( int )fst.st_size / 1024 );
save.c:               ch->pcdata->pet = mob;
save.c:               bug( "%s: Deleted mob saved on %s - skipping", __func__, ch->name );
save.c:      ch->name = STRALLOC( name );
save.c:      ch->short_descr = STRALLOC( "" );
save.c:      ch->long_descr = STRALLOC( "" );
save.c:      ch->description = STRALLOC( "" );
save.c:      ch->editor = NULL;
save.c:      ch->pcdata->clan_name = STRALLOC( "" );
save.c:      ch->pcdata->clan = NULL;
save.c:      ch->pcdata->council_name = STRALLOC( "" );
save.c:      ch->pcdata->council = NULL;
save.c:      ch->pcdata->deity_name = STRALLOC( "" );
save.c:      ch->pcdata->deity = NULL;
save.c:      ch->pcdata->pet = NULL;
save.c:      ch->pcdata->pwd = str_dup( "" );
save.c:      ch->pcdata->bamfin = str_dup( "" );
save.c:      ch->pcdata->bamfout = str_dup( "" );
save.c:      ch->pcdata->rank = str_dup( "" );
save.c:      ch->pcdata->bestowments = str_dup( "" );
save.c:      ch->pcdata->title = STRALLOC( "" );
save.c:      ch->pcdata->customclass = STRALLOC( "" );
save.c:      ch->pcdata->homepage = str_dup( "" );
save.c:      ch->pcdata->bio = STRALLOC( "" );
save.c:      ch->pcdata->authed_by = STRALLOC( "" );
save.c:      ch->pcdata->prompt = STRALLOC( "" );
save.c:      ch->pcdata->fprompt = STRALLOC( "" );
save.c:      ch->pcdata->r_range_lo = 0;
save.c:      ch->pcdata->r_range_hi = 0;
save.c:      ch->pcdata->m_range_lo = 0;
save.c:      ch->pcdata->m_range_hi = 0;
save.c:      ch->pcdata->o_range_lo = 0;
save.c:      ch->pcdata->o_range_hi = 0;
save.c:      ch->pcdata->wizinvis = 0;
save.c:      ch->pcdata->timezone = -1;
save.c:      if( !ch->name )
save.c:         ch->name = STRALLOC( name );
save.c:      if( !ch->pcdata->clan_name )
save.c:         ch->pcdata->clan_name = STRALLOC( "" );
save.c:         ch->pcdata->clan = NULL;
save.c:      if( !ch->pcdata->council_name )
save.c:         ch->pcdata->council_name = STRALLOC( "" );
save.c:         ch->pcdata->council = NULL;
save.c:      if( !ch->pcdata->deity_name )
save.c:         ch->pcdata->deity_name = STRALLOC( "" );
save.c:         ch->pcdata->deity = NULL;
save.c:      if( !ch->pcdata->bio )
save.c:         ch->pcdata->bio = STRALLOC( "" );
save.c:      if( !ch->pcdata->authed_by )
save.c:         ch->pcdata->authed_by = STRALLOC( "" );
save.c:      if( xIS_SET( ch->act, PLR_FLEE ) )
save.c:         xREMOVE_BIT( ch->act, PLR_FLEE );
save.c:         if( ch->pcdata->wizinvis < 2 )
save.c:            ch->pcdata->wizinvis = ch->level;
save.c:   memcpy( &ch->colors, &default_set, sizeof( default_set ) );
save.c:            KEY( "Act", ch->act, fread_bitvector( fp ) );
save.c:            KEY( "AffectedBy", ch->affected_by, fread_bitvector( fp ) );
save.c:            KEY( "Alignment", ch->alignment, fread_number( fp ) );
save.c:            KEY( "Armor", ch->armor, fread_number( fp ) );
save.c:                     KEY( "Att", ch->pcdata->att, fread_number( fp ) );
save.c:                     KEY( "Attplus", ch->pcdata->attplus, fread_number( fp ) );
save.c:                     KEY( "Attlevel", ch->pcdata->attlevel, fread_number( fp ) );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                     if( ch->level < LEVEL_IMMORTAL )
save.c:                        if( skill_table[sn]->race_level[ch->race] >= LEVEL_IMMORTAL )
save.c:                           ch->pcdata->learned[sn] = 0;
save.c:                           ++ch->practice;
save.c:               LINK( paf, ch->first_affect, ch->last_affect, next, prev );
save.c:                  ch->pcdata->age_bonus = x1;
save.c:                  ch->pcdata->day = x2;
save.c:                  ch->pcdata->month = x3;
save.c:                  ch->pcdata->year = x4;
save.c:               ch->mod_str = x1;
save.c:               ch->mod_int = x2;
save.c:               ch->mod_wis = x3;
save.c:               ch->mod_dex = x4;
save.c:               ch->mod_con = x5;
save.c:               ch->mod_cha = x6;
save.c:               ch->mod_lck = x7;
save.c:                  ch->mod_lck = 0;
save.c:               ch->perm_str = x1;
save.c:               ch->perm_int = x2;
save.c:               ch->perm_wis = x3;
save.c:               ch->perm_dex = x4;
save.c:               ch->perm_con = x5;
save.c:               ch->perm_cha = x6;
save.c:               ch->perm_lck = x7;
save.c:                  ch->perm_lck = 13;
save.c:            KEY( "Ap", ch->pcdata->ap, fread_number( fp ) );
save.c:            KEY( "AuthedBy", ch->pcdata->authed_by, fread_string( fp ) );
save.c:            KEY( "Balance", ch->pcdata->balance, fread_number( fp ) );
save.c:            KEY( "Bamfin", ch->pcdata->bamfin, fread_string_nohash( fp ) );
save.c:            KEY( "Bamfout", ch->pcdata->bamfout, fread_string_nohash( fp ) );
save.c:            KEY( "Bestowments", ch->pcdata->bestowments, fread_string_nohash( fp ) );
save.c:            KEY( "Bio", ch->pcdata->bio, fread_string( fp ) );
save.c:               ch->pcdata->clan_name = fread_string( fp );
save.c:                   && ch->pcdata->clan_name[0] != '\0' && ( ch->pcdata->clan = get_clan( ch->pcdata->clan_name ) ) == NULL )
save.c:                     ch->pcdata->clan_name );
save.c:                  add_loginmsg( ch->name, 18, buf );
save.c:                  STRFREE( ch->pcdata->clan_name );
save.c:                  ch->pcdata->clan_name = STRALLOC( "" );
save.c:            KEY( "Class", ch->Class, fread_number( fp ) );
save.c:            KEY( "Customclass", ch->pcdata->customclass, fread_string( fp ) );
save.c:                  ch->colors[x] = fread_number( fp );
save.c:               ch->pcdata->condition[0] = x1;
save.c:               ch->pcdata->condition[1] = x2;
save.c:               ch->pcdata->condition[2] = x3;
save.c:               ch->pcdata->condition[3] = x4;
save.c:               ch->pcdata->council_name = fread_string( fp );
save.c:                   && ch->pcdata->council_name[0] != '\0'
save.c:                   && ( ch->pcdata->council = get_council( ch->pcdata->council_name ) ) == NULL )
save.c:                     ch->pcdata->council_name );
save.c:                  add_loginmsg( ch->name, 18, buf );
save.c:                  STRFREE( ch->pcdata->council_name );
save.c:                  ch->pcdata->council_name = STRALLOC( "" );
save.c:               ch->pcdata->cpose = fread_string( fp );
save.c:               if( isalpha( ch->pcdata->cpose[0] ) || isdigit( ch->pcdata->cpose[0] ) )
save.c:                  snprintf( buf, MAX_STRING_LENGTH, " %s", ch->pcdata->cpose );
save.c:                  if( ch->pcdata->cpose )
save.c:                     STRFREE( ch->pcdata->cpose );
save.c:                  ch->pcdata->cpose = STRALLOC( buf );
save.c:                     KEY( "Dex", ch->pcdata->dex, fread_number( fp ) );
save.c:                     KEY( "Def", ch->pcdata->def, fread_number( fp ) );
save.c:                     KEY( "Dexplus", ch->pcdata->dexplus, fread_number( fp ) );
save.c:                     KEY( "Defplus", ch->pcdata->defplus, fread_number( fp ) );
save.c:                     KEY( "Deflevel", ch->pcdata->deflevel, fread_number( fp ) );
save.c:            KEY( "Damroll", ch->damroll, fread_number( fp ) );
save.c:            KEY( "Deaf", ch->deaf, fread_number( fp ) );
save.c:               ch->pcdata->deity_name = fread_string( fp );
save.c:                   && ch->pcdata->deity_name[0] != '\0'
save.c:                   && ( ch->pcdata->deity = get_deity( ch->pcdata->deity_name ) ) == NULL )
save.c:                  snprintf( buf, MAX_STRING_LENGTH, "&R\r\nYour deity, %s, has met its demise!\r\n", ch->pcdata->deity_name );
save.c:                  add_loginmsg( ch->name, 18, buf );
save.c:                  STRFREE( ch->pcdata->deity_name );
save.c:                  ch->pcdata->deity_name = STRALLOC( "" );
save.c:                  ch->pcdata->favor = 0;
save.c:            KEY( "Description", ch->description, fread_string( fp ) );
save.c:            KEY( "Favor", ch->pcdata->favor, fread_number( fp ) );
save.c:            KEY( "Flags", ch->pcdata->flags, fread_number( fp ) );
save.c:            KEY( "FPrompt", ch->pcdata->fprompt, fread_string( fp ) );
save.c:            KEY( "Glory", ch->pcdata->quest_curr, fread_number( fp ) );
save.c:            KEY( "Gold", ch->gold, fread_number( fp ) );
save.c:               ch->pcdata->clan_name = fread_string( fp );
save.c:                   && ch->pcdata->clan_name[0] != '\0' && ( ch->pcdata->clan = get_clan( ch->pcdata->clan_name ) ) == NULL )
save.c:                     ch->pcdata->clan_name );
save.c:                  add_loginmsg( ch->name, 18, buf );
save.c:                  STRFREE( ch->pcdata->clan_name );
save.c:                  ch->pcdata->clan_name = STRALLOC( "" );
save.c:            KEY( "Height", ch->height, fread_number( fp ) );
save.c:               ch->pcdata->release_date = fread_number( fp );
save.c:               ch->pcdata->helled_by = fread_string( fp );
save.c:            KEY( "Hitroll", ch->hitroll, fread_number( fp ) );
save.c:            KEY( "Homepage", ch->pcdata->homepage, fread_string_nohash( fp ) );
save.c:               if( ch->in_room && xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
save.c:                        if( tmphome->vnum[i] == ch->in_room->vnum )
save.c:                              ch->in_room = get_room_index( ROOM_VNUM_TEMPLE );
save.c:               ch->pcdata->hometown = fread_string( fp );
save.c:               if( isalpha( ch->pcdata->hometown[0] ) || isdigit( ch->pcdata->hometown[0] ) )
save.c:                  snprintf( buf, MAX_STRING_LENGTH, " %s", ch->pcdata->hometown );
save.c:                  if( ch->pcdata->hometown )
save.c:                     STRFREE( ch->pcdata->hometown );
save.c:                  ch->pcdata->hometown = STRALLOC( buf );
save.c:               ch->hit = fread_number( fp );
save.c:               ch->max_hit = fread_number( fp );
save.c:               ch->mana = fread_number( fp );
save.c:               ch->max_mana = fread_number( fp );
save.c:               ch->move = fread_number( fp );
save.c:               ch->max_move = fread_number( fp );
save.c:               for( ign = 0, inode = ch->pcdata->first_ignored; inode; inode = inode->next )
save.c:                  LINK( inode, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
save.c:            KEY( "IllegalPK", ch->pcdata->illegal_pk, fread_number( fp ) );
save.c:            KEY( "Immune", ch->immune, fread_number( fp ) );
save.c:                   KEY( "Intel", ch->pcdata->intel, fread_number( fp ) );
save.c:                   KEY( "Intplus", ch->pcdata->intplus, fread_number( fp ) );
save.c:                  ch->pcdata->killed[killcnt].vnum = fread_number( fp );
save.c:                  ch->pcdata->killed[killcnt++].count = fread_number( fp );
save.c:                     KEY( "Lck", ch->pcdata->lck, fread_number( fp ) );
save.c:                     KEY( "Lckplus", ch->pcdata->lckplus, fread_number( fp ) );
save.c:            KEY( "Level", ch->level, fread_number( fp ) );
save.c:            KEY( "LongDescr", ch->long_descr, fread_string( fp ) );
save.c:               ch->speaks = fread_number( fp );
save.c:               ch->speaking = fread_number( fp );
save.c:                   KEY( "Matt", ch->pcdata->matt, fread_number( fp ) );
save.c:                   KEY( "Mdef", ch->pcdata->mdef, fread_number( fp ) );
save.c:                   KEY( "Mattplus", ch->pcdata->mattplus, fread_number( fp ) );
save.c:                   KEY( "Mdefplus", ch->pcdata->mdefplus, fread_number( fp ) );
save.c:                   KEY( "Mlevel", ch->pcdata->mlevel, fread_number( fp ) );
save.c:            KEY( "MDeaths", ch->pcdata->mdeaths, fread_number( fp ) );
save.c:            KEY( "Mentalstate", ch->mental_state, fread_number( fp ) );
save.c:            KEY( "MGlory", ch->pcdata->quest_accum, fread_number( fp ) );
save.c:            KEY( "Minsnoop", ch->pcdata->min_snoop, fread_number( fp ) );
save.c:            KEY( "MKills", ch->pcdata->mkills, fread_number( fp ) );
save.c:            KEY( "Mobinvis", ch->mobinvis, fread_number( fp ) );
save.c:               ch->pcdata->m_range_lo = fread_number( fp );
save.c:               ch->pcdata->m_range_hi = fread_number( fp );
save.c:            KEY( "Name", ch->name, fread_string( fp ) );
save.c:            KEY( "NoAffectedBy", ch->no_affected_by, fread_bitvector( fp ) );
save.c:            KEY( "NoImmune", ch->no_immune, fread_number( fp ) );
save.c:            KEY( "NoResistant", ch->no_resistant, fread_number( fp ) );
save.c:            KEY( "NoSusceptible", ch->no_susceptible, fread_number( fp ) );
save.c:               CREATE( ch->pcdata->nuisance, NUISANCE_DATA, 1 );
save.c:               ch->pcdata->nuisance->set_time = fread_number( fp );
save.c:               ch->pcdata->nuisance->max_time = fread_number( fp );
save.c:               ch->pcdata->nuisance->flags = fread_number( fp );
save.c:               ch->pcdata->nuisance->power = 1;
save.c:               CREATE( ch->pcdata->nuisance, NUISANCE_DATA, 1 );
save.c:               ch->pcdata->nuisance->set_time = fread_number( fp );
save.c:               ch->pcdata->nuisance->max_time = fread_number( fp );
save.c:               ch->pcdata->nuisance->flags = fread_number( fp );
save.c:               ch->pcdata->nuisance->power = fread_number( fp );
save.c:            KEY( "Outcast_time", ch->pcdata->outcast_time, fread_number( fp ) );
save.c:               ch->pcdata->o_range_lo = fread_number( fp );
save.c:               ch->pcdata->o_range_hi = fread_number( fp );
save.c:            KEY( "Pagerlen", ch->pcdata->pagerlen, fread_number( fp ) );
save.c:            KEY( "Password", ch->pcdata->pwd, fread_string_nohash( fp ) );
save.c:            KEY( "PDeaths", ch->pcdata->pdeaths, fread_number( fp ) );
save.c:            KEY( "PKills", ch->pcdata->pkills, fread_number( fp ) );
save.c:            KEY( "Played", ch->played, fread_number( fp ) );
save.c:               ch->position = fread_number( fp );
save.c:               if( ch->position < 100 )
save.c:                  switch ( ch->position )
save.c:                        ch->position = 6;
save.c:                        ch->position = 8;
save.c:                        ch->position = 9;
save.c:                        ch->position = 12;
save.c:                        ch->position = 13;
save.c:                        ch->position = 14;
save.c:                        ch->position = 15;
save.c:                  ch->position -= 100;
save.c:            KEY( "Practice", ch->practice, fread_number( fp ) );
save.c:            KEY( "Prompt", ch->pcdata->prompt, fread_string( fp ) );
save.c:            KEY( "Race", ch->race, fread_number( fp ) );
save.c:            KEY( "Rank", ch->pcdata->rank, fread_string_nohash( fp ) );
save.c:            KEY( "Resistant", ch->resistant, fread_number( fp ) );
save.c:            KEY( "Restore_time", ch->pcdata->restore_time, fread_number( fp ) );
save.c:               ch->in_room = get_room_index( fread_number( fp ) );
save.c:               if( !ch->in_room )
save.c:                  ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
save.c:               ch->pcdata->r_range_lo = fread_number( fp );
save.c:               ch->pcdata->r_range_hi = fread_number( fp );
save.c:                   KEY( "Str", ch->pcdata->str, fread_number( fp ) );
save.c:                   KEY( "Strplus", ch->pcdata->strplus, fread_number( fp ) );
save.c:            KEY( "Sex", ch->sex, fread_number( fp ) );
save.c:            KEY( "ShortDescr", ch->short_descr, fread_string( fp ) );
save.c:            KEY( "Style", ch->style, fread_number( fp ) );
save.c:            KEY( "Susceptible", ch->susceptible, fread_number( fp ) );
save.c:               ch->saving_wand = fread_number( fp );
save.c:               ch->saving_poison_death = ch->saving_wand;
save.c:               ch->saving_para_petri = ch->saving_wand;
save.c:               ch->saving_breath = ch->saving_wand;
save.c:               ch->saving_spell_staff = ch->saving_wand;
save.c:               ch->saving_poison_death = fread_number( fp );
save.c:               ch->saving_wand = fread_number( fp );
save.c:               ch->saving_para_petri = fread_number( fp );
save.c:               ch->saving_breath = fread_number( fp );
save.c:               ch->saving_spell_staff = fread_number( fp );
save.c:                  ch->pcdata->prev_site = STRALLOC( fread_word( fp ) );
save.c:                  ch_printf( ch, "Last connected from: %s\r\n", ch->pcdata->prev_site );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                     if( ch->level < LEVEL_IMMORTAL )
save.c:                        if( skill_table[sn]->skill_level[ch->Class] >= LEVEL_IMMORTAL )
save.c:                           ch->pcdata->learned[sn] = 0;
save.c:                           ++ch->practice;
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                     if( ch->level < LEVEL_IMMORTAL )
save.c:                        if( skill_table[sn]->skill_level[ch->Class] >= LEVEL_IMMORTAL )
save.c:                           ch->pcdata->learned[sn] = 0;
save.c:                           ++ch->practice;
save.c:               if( !ch->short_descr )
save.c:                  ch->short_descr = STRALLOC( "" );
save.c:               if( !ch->long_descr )
save.c:                  ch->long_descr = STRALLOC( "" );
save.c:               if( !ch->description )
save.c:                  ch->description = STRALLOC( "" );
save.c:               if( !ch->pcdata->pwd )
save.c:                  ch->pcdata->pwd = str_dup( "" );
save.c:               if( !ch->pcdata->bamfin )
save.c:                  ch->pcdata->bamfin = str_dup( "" );
save.c:               if( !ch->pcdata->bamfout )
save.c:                  ch->pcdata->bamfout = str_dup( "" );
save.c:               if( !ch->pcdata->bio )
save.c:                  ch->pcdata->bio = STRALLOC( "" );
save.c:               if( !ch->pcdata->rank )
save.c:                  ch->pcdata->rank = str_dup( "" );
save.c:               if( !ch->pcdata->bestowments )
save.c:                  ch->pcdata->bestowments = str_dup( "" );
save.c:               if( !ch->pcdata->title )
save.c:                  ch->pcdata->title = STRALLOC( "" );
save.c:               if( !ch->pcdata->customclass )
save.c:                  ch->pcdata->customclass = STRALLOC( "" );
save.c:               if( !ch->pcdata->cpose )
save.c:                  ch->pcdata->cpose = STRALLOC( "" );
save.c:               if( !ch->pcdata->hometown )
save.c:                  ch->pcdata->hometown = STRALLOC( "" );
save.c:               if( !ch->pcdata->homepage )
save.c:                  ch->pcdata->homepage = str_dup( "" );
save.c:               if( !ch->pcdata->authed_by )
save.c:                  ch->pcdata->authed_by = STRALLOC( "" );
save.c:               if( !ch->pcdata->prompt )
save.c:                  ch->pcdata->prompt = STRALLOC( "" );
save.c:               if( !ch->pcdata->fprompt )
save.c:                  ch->pcdata->fprompt = STRALLOC( "" );
save.c:               ch->editor = NULL;
save.c:               killcnt = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
save.c:                  ch->pcdata->killed[killcnt].vnum = 0;
save.c:               if( !IS_IMMORTAL( ch ) && !ch->speaking )
save.c:                  ch->speaking = LANG_COMMON;
save.c:                * ch->speaking = race_table[ch->race]->language; 
save.c:                  ch->speaks = ~0;
save.c:                  if( ch->speaking == 0 )
save.c:                     ch->speaking = ~0;
save.c:                  CREATE( ch->pcdata->tell_history, const char *, 26 );
save.c:                     ch->pcdata->tell_history[i] = NULL;
save.c:               if( !ch->pcdata->prompt )
save.c:                  ch->pcdata->prompt = STRALLOC( "" );
save.c:               if( ch->height == 72 )
save.c:                  ch->height =
save.c:                     number_range( ( int )( race_table[ch->race]->height * .9 ),
save.c:                                   ( int )( race_table[ch->race]->height * 1.1 ) );
save.c:               if( ch->weight == 180 )
save.c:                  ch->weight =
save.c:                     number_range( ( int )( race_table[ch->race]->weight * .9 ),
save.c:                                   ( int )( race_table[ch->race]->weight * 1.1 ) );
save.c:               if( ch->pcdata->clan )
save.c:            KEY( "Exp", ch->exp, fread_number( fp ) );
save.c:                     KEY( "Tier", ch->pcdata->tier, fread_number( fp ) );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                     if( ch->level < LEVEL_IMMORTAL )
save.c:                        if( skill_table[sn]->skill_level[ch->Class] >= LEVEL_IMMORTAL )
save.c:                           ch->pcdata->learned[sn] = 0;
save.c:                           ch->practice++;
save.c:            KEY( "Trust", ch->trust, fread_number( fp ) );
save.c:            KEY( "Timezone", ch->pcdata->timezone, fread_number( fp )); 
save.c:            ch->trust = UMIN( ch->trust, MAX_LEVEL - 1 );
save.c:               ch->pcdata->title = fread_string( fp );
save.c:               if( isalpha( ch->pcdata->title[0] ) || isdigit( ch->pcdata->title[0] ) )
save.c:                  snprintf( buf, MAX_STRING_LENGTH, " %s", ch->pcdata->title );
save.c:                  if( ch->pcdata->title )
save.c:                     STRFREE( ch->pcdata->title );
save.c:                  ch->pcdata->title = STRALLOC( buf );
save.c:            KEY( "Weight", ch->weight, fread_number( fp ) );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                     if( ch->level < LEVEL_IMMORTAL )
save.c:                        if( skill_table[sn]->skill_level[ch->Class] >= LEVEL_IMMORTAL )
save.c:                           ch->pcdata->learned[sn] = 0;
save.c:                           ++ch->practice;
save.c:            KEY( "Wimpy", ch->wimpy, fread_number( fp ) );
save.c:            KEY( "WizInvis", ch->pcdata->wizinvis, fread_number( fp ) );
save.c:      room = ch->in_room;
save.c:      if( ch->tempnum == -9999 )
save.c:                     obj->owner = QUICKLINK( ch->name );
save.c:      name = ch->name;
save.c:   if( IS_NPC( ch ) || !ch->pcdata->pet )
save.c:   mob = ch->pcdata->pet;
shops.c:   for( keeper = ch->in_room->first_person; keeper; keeper = keeper->next_in_room )
shops.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_KILLER ) )
shops.c:      snprintf( buf, MAX_STRING_LENGTH, "%s the KILLER is over here!\r\n", ch->name );
shops.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_THIEF ) )
shops.c:      snprintf( buf, MAX_STRING_LENGTH, "%s the THIEF is over here!\r\n", ch->name );
shops.c:   speakswell = UMIN( knows_language( keeper, ch->speaking, ch ), knows_language( ch, ch->speaking, keeper ) );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s Could you repeat that?  I didn't quite catch it.", ch->name );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s Could you say that a little more clearly please?", ch->name );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s Sorry... What was that you wanted?", ch->name );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s I can't understand you.", ch->name );
shops.c:   for( keeper = ch->in_room->first_person; keeper; keeper = keeper->next_in_room )
shops.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_KILLER ) )
shops.c:      snprintf( buf, MAX_STRING_LENGTH, "%s the KILLER is over here!\r\n", ch->name );
shops.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_THIEF ) )
shops.c:      snprintf( buf, MAX_STRING_LENGTH, "%s the THIEF is over here!\r\n", ch->name );
shops.c:   speakswell = UMIN( knows_language( keeper, ch->speaking, ch ), knows_language( ch, ch->speaking, keeper ) );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s Could you repeat that?  I didn't quite catch it.", ch->name );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s Could you say that a little more clearly please?", ch->name );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s Sorry... What was that you wanted?", ch->name );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s I can't understand you.", ch->name );
shops.c:   if( ch->gold > ( ch->level * ch->level * 100000 ) )
shops.c:         + ( ( URANGE( 5, ch->level, LEVEL_AVATAR ) - 20 ) / 2 );
shops.c:      cost = ( int )( cost * ( 80 + UMIN( ch->level, LEVEL_AVATAR ) ) ) / 100;
shops.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_PET_SHOP ) )
shops.c:      pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
shops.c:         bug( "%s: bad pet shop at vnum %d.", __func__, ch->in_room->vnum );
shops.c:      in_room = ch->in_room;
shops.c:      ch->in_room = pRoomIndexNext;
shops.c:      ch->in_room = in_room;
shops.c:      if( xIS_SET( ch->act, PLR_BOUGHT_PET ) )
shops.c:      if( ch->gold < 10 * pet->level * pet->level )
shops.c:      if( ch->level < pet->level )
shops.c:      ch->gold -= maxgold;
shops.c:      boost_economy( ch->in_room->area, maxgold );
shops.c:      xSET_BIT( ch->act, PLR_BOUGHT_PET );
shops.c:      snprintf( buf, MAX_STRING_LENGTH, "%sA neck tag says 'I belong to %s'.\r\n", pet->description, ch->name );
shops.c:      char_to_room( pet, ch->in_room );
shops.c:            ch->reply = keeper;
shops.c:         ch->reply = keeper;
shops.c:         ch->reply = keeper;
shops.c:      if( ch->gold < cost )
shops.c:         ch->reply = keeper;
shops.c:      if( obj->level > ch->level )
shops.c:         ch->reply = keeper;
shops.c:         ch->reply = keeper;
shops.c:      if( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
shops.c:      if( ch->carry_weight + ( get_obj_weight( obj ) * noi ) + ( noi > 1 ? 2 : 0 ) > can_carry_w( ch ) )
shops.c:      ch->gold -= cost;
shops.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_PET_SHOP ) )
shops.c:      pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
shops.c:         bug( "Do_list: bad pet shop at vnum %d.", ch->in_room->vnum );
shops.c:      ch->reply = keeper;
shops.c:   ch->gold += cost;
shops.c:      ch->reply = keeper;
shops.c:   ch->reply = keeper;
shops.c:   else if( ( cost = strcmp( "all", arg ) ? cost : 11 * cost / 10 ) > ch->gold )
shops.c:      ch->gold -= cost;
shops.c:      for( obj = ch->first_carrying; obj; obj = obj->next_content )
shops.c:      ch->reply = keeper;
shops.c:   for( obj = ch->first_carrying; obj != NULL; obj = obj->next_content )
shops.c:      ch->reply = keeper;
shops.c:   if( cost > ch->gold )
skills.c:   if( ch->pcdata->clan && ch->pcdata->clan == vch->pcdata->clan )
skills.c:                                  100 / ( 2 + ch->level - skill_table[sn]->race_level[ch->race] ) );
skills.c:         if( ch->pcdata->condition[COND_BLOODTHIRST] < blood )
skills.c:      else if( !IS_NPC( ch ) && ch->mana < mana )
skills.c:                  if( xIS_SET( ch->act, PLR_NICE ) )
skills.c:               if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
skills.c:               ch->mana -= mana / 2;
skills.c:            ch->mana -= mana;
skills.c:      retcode = ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, vo );
skills.c:         for( vch = ch->in_room->first_person; vch; vch = vch_next )
skills.c:            vch_next = vch->next_in_room;
skills.c:         ch->mana -= mana;
skills.c:   ch->prev_cmd = ch->last_cmd;  /* haus, for automapping */
skills.c:   ch->last_cmd = skill_table[sn]->skill_fun;
skills.c:                                      100 / ( 2 + ch->level - skill_table[sn]->skill_level[ch->Class] ) );
skills.c:         if( ch->pcdata->condition[COND_BLOODTHIRST] < blood )
skills.c:      else if( !IS_NPC( ch ) && ch->mana < mana )
skills.c:               if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
skills.c:               ch->mana -= mana / 2;
skills.c:            ch->mana -= mana;
skills.c:      retcode = ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, vo );
skills.c:         for( vch = ch->in_room->first_person; vch; vch = vch_next )
skills.c:            vch_next = vch->next_in_room;
skills.c:         ch->mana -= mana;
skills.c:   ch->prev_cmd = ch->last_cmd;  /* haus, for automapping */
skills.c:   ch->last_cmd = skill_table[sn]->skill_fun;
skills.c:   if( IS_NPC( ch ) || ch->pcdata->learned[sn] <= 0 )
skills.c:   adept = skill_table[sn]->race_adept[ch->race];
skills.c:   sklvl = skill_table[sn]->race_level[ch->race];
skills.c:      sklvl = ch->level;
skills.c:   if( ch->pcdata->learned[sn] < adept )
skills.c:      schance = ch->pcdata->learned[sn] + ( 5 * skill_table[sn]->difficulty );
skills.c:      ch->pcdata->learned[sn] = UMIN( adept, ch->pcdata->learned[sn] + learn );
skills.c:      if( ch->pcdata->learned[sn] == adept ) /* fully learned! */
skills.c:         if( !ch->fighting && sn != gsn_hide && sn != gsn_sneak )
skills.c:   if( IS_NPC( ch ) || ch->pcdata->learned[sn] <= 0 )
skills.c:   sklvl = skill_table[sn]->skill_level[ch->Class];
skills.c:      sklvl = ch->level;
skills.c:   if( ch->pcdata->learned[sn] < adept )
skills.c:      schance = ch->pcdata->learned[sn] + ( 5 * skill_table[sn]->difficulty );
skills.c:      ch->pcdata->learned[sn] = UMIN( adept, ch->pcdata->learned[sn] + learn );
skills.c:      if( ch->pcdata->learned[sn] == adept ) /* fully learned! */
skills.c:         if( ch->Class == CLASS_MAGE )
skills.c:         if( ch->Class == CLASS_CLERIC )
skills.c:         if( ch->Class == CLASS_MAGE )
skills.c:         if( ch->Class == CLASS_CLERIC )
skills.c:         if( !ch->fighting && sn != gsn_hide && sn != gsn_sneak )
skills.c:   if( IS_NPC( ch ) || ch->pcdata->learned[sn] <= 0 )
skills.c:   schance = ch->pcdata->learned[sn] + ( 5 * skill_table[sn]->difficulty );
skills.c:   if( ch->pcdata->learned[sn] < ( adept - 1 ) )
skills.c:      ch->pcdata->learned[sn] = UMIN( adept, ch->pcdata->learned[sn] + 1 );
skills.c:   if( ch->mount )
skills.c:   if( !ch->fighting && victim->in_room == ch->in_room )
skills.c:   if( !victim->fighting && ch->in_room == victim->in_room )
skills.c:   if( ch->mount )
skills.c:      dam = number_range( 5, ch->level );
skills.c:               af.duration = ( ch->level + 10 ) / get_curr_con( victim );
skills.c:               af.duration = 3 + ( ch->level / 15 );
skills.c:   switch ( ch->substate )
skills.c:         if( ch->mount )
skills.c:         if( !ch->in_room->first_content )
skills.c:         for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
skills.c:         ch->alloc_ptr = str_dup( obj->name );
skills.c:         if( !ch->alloc_ptr )
skills.c:            bug( "%s", "do_detrap: ch->alloc_ptr NULL!" );
skills.c:         mudstrlcpy( arg, ch->alloc_ptr, MAX_INPUT_LENGTH );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->alloc_ptr = NULL;
skills.c:         ch->substate = SUB_NONE;
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->substate = SUB_NONE;
skills.c:   if( !ch->in_room->first_content )
skills.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
skills.c:   percent = number_percent(  ) - ( ch->level / 15 ) - ( get_curr_lck( ch ) - 16 );
skills.c:   switch ( ch->substate )
skills.c:         if( ch->mount )
skills.c:            switch ( ch->in_room->sector_type )
skills.c:         ch->alloc_ptr = str_dup( arg );
skills.c:         if( !ch->alloc_ptr )
skills.c:         mudstrlcpy( arg, ch->alloc_ptr, MAX_INPUT_LENGTH );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->substate = SUB_NONE;
skills.c:   ch->substate = SUB_NONE;
skills.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
skills.c:   startobj = ch->in_room->first_content;
skills.c:	    (IS_NPC(ch) ? 80 : ch->pcdata->learned[gsn_dig]) )
skills.c:   switch ( ch->substate )
skills.c:         if( ch->mount )
skills.c:         ch->alloc_ptr = str_dup( arg );
skills.c:         if( !ch->alloc_ptr )
skills.c:         mudstrlcpy( arg, ch->alloc_ptr, MAX_INPUT_LENGTH );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->substate = SUB_NONE;
skills.c:   ch->substate = SUB_NONE;
skills.c:      startobj = ch->in_room->first_content;
skills.c:   percent = number_percent(  ) + number_percent(  ) - ( ch->level / 10 );
skills.c:      if( ( pexit = get_exit( ch->in_room, door ) ) != NULL
skills.c:   if( ch->mount )
skills.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:   if( ch->level + 10 < victim->level )
skills.c:      snprintf( buf, MAX_STRING_LENGTH, "%s is a bloody thief!", ch->name );
skills.c:               if( ( mst = ch->master ) == NULL )
skills.c:      ch->gold += amount;
skills.c:       || IS_OBJ_STAT( obj, ITEM_INVENTORY ) || IS_OBJ_STAT( obj, ITEM_PROTOTYPE ) || obj->level > ch->level )
skills.c:   if( ch->carry_number + ( get_obj_number( obj ) / obj->count ) > can_carry_n( ch ) )
skills.c:   if( ch->carry_weight + ( get_obj_weight( obj ) / obj->count ) > can_carry_w( ch ) )
skills.c:   if( ch->mount )
skills.c:   if( ch->mount )
skills.c:   if( !IS_NPC( ch ) && !IS_NPC( victim ) && xIS_SET( ch->act, PLR_NICE ) )
skills.c:   if( ch->mount )
skills.c:   if( !ch->fighting )
skills.c:   if( ch->fighting )
skills.c:   int managain = ( ch->Class == CLASS_DRUID ? 0 : 22 );
skills.c:   switch ( ch->substate )
skills.c:         ch->alloc_ptr = str_dup( argument );
skills.c:         if( !ch->alloc_ptr )
skills.c:         arg = str_dup( ch->alloc_ptr );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->substate = SUB_NONE;
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:   switch ( ch->in_room->sector_type )
skills.c:         if( ch->Class == CLASS_DRUID )
skills.c:         if( ch->race == RACE_SEA_ELF )
skills.c:         if( ch->race == RACE_PIXIE )
skills.c:      ch->mana = UMIN( ch->max_mana, ch->mana + managain );
skills.c:   if( ch->mana < ch->max_mana )
skills.c:      ch->alloc_ptr = str_dup( arg );
skills.c:      ch->substate = SUB_NONE;
skills.c:   int managain = ( ch->Class == CLASS_DRUID ? 0 : 50 );
skills.c:   switch ( ch->substate )
skills.c:         ch->alloc_ptr = str_dup( argument );
skills.c:         if( !ch->alloc_ptr )
skills.c:         arg = str_dup( ch->alloc_ptr );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->substate = SUB_NONE;
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:   switch ( ch->in_room->sector_type )
skills.c:         if( ch->Class == CLASS_DRUID )
skills.c:         if( ch->race == RACE_SEA_ELF )
skills.c:         if( ch->race == RACE_PIXIE )
skills.c:      ch->mana = UMIN( ch->max_mana, ch->mana + managain );
skills.c:   if( ch->mana < ch->max_mana )
skills.c:      ch->alloc_ptr = str_dup( arg );
skills.c:      ch->substate = SUB_NONE;
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_kick]->skill_level[ch->Class] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_kick );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_punch]->skill_level[ch->Class] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_punch );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_bite]->skill_level[ch->Class] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_bite );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_claw]->skill_level[ch->Class] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_claw );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_sting]->skill_level[ch->Class] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_sting );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_tail]->skill_level[ch->Class] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_tail );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_bash]->skill_level[ch->Class] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_bash );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_stun]->skill_level[ch->Class] )
skills.c:   if( !IS_NPC( ch ) && ch->move < ch->max_move / 10 )
skills.c:   schance = ris_save( victim, ch->level, RIS_PARALYSIS );
skills.c:         ch->move -= ch->max_move / 10;
skills.c:         ch->move -= ch->max_move / 15;
skills.c:   if( ch->fighting )
skills.c:   if( ch->pcdata->condition[COND_BLOODTHIRST] < 10 )
skills.c:      obj_to_room( obj, ch->in_room );
skills.c:      damage( ch, ch, ch->level / 5, gsn_bloodlet );
skills.c:   if( ch->mount )
skills.c:      dam = number_range( 1, ch->level );
skills.c:          && ch->fighting && ch->pcdata->condition[COND_BLOODTHIRST] < ( 10 + ch->level ) )
skills.c:                         UMIN( number_range( 1, ( ch->level + victim->level / 20 ) + 3 ),
skills.c:                               ( 10 + ch->level ) - ch->pcdata->condition[COND_BLOODTHIRST] ) );
skills.c:         if( ch->pcdata->condition[COND_FULL] <= 37 )
skills.c:         temphit = ch->hit;
skills.c:         ch->hit += 1 + ch->level / 5;
skills.c:         if( ch->hit > ch->max_hit )
skills.c:            ch->hit = ch->max_hit;
skills.c:         if( ch->hit < temphit )
skills.c:            ch->hit = temphit;
skills.c:          && ch->fighting && ch->pcdata->condition[COND_BLOODTHIRST] < ( 10 + ch->level ) )
skills.c:      snprintf( buf, MAX_STRING_LENGTH, "%s %s", ch->name, victim->name );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_disarm]->skill_level[ch->Class] )
skills.c:   percent = number_percent(  ) + victim->level - ch->level - ( get_curr_lck( ch ) - 15 ) + ( get_curr_lck( victim ) - 15 );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_cleave]->skill_level[ch->Class] )
skills.c:   if( ch->mount )
skills.c:   if( IS_PKILL( ch ) && ch->pcdata->condition[COND_BLOODTHIRST] > 22 )
skills.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
skills.c:       || victim->level >= ch->level + 15
skills.c:       || ( IS_NPC( victim ) && saves_spell_staff( ch->level, victim ) )
skills.c:   if( ch->mount )
skills.c:      if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
skills.c:   if( ch->mount )
skills.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
skills.c:      if( IS_NPC( gch ) && IS_AWAKE( gch ) && ch->level + 5 < gch->level )
skills.c:/*        for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
skills.c:          if ( IS_NPC(gch) && IS_AWAKE(gch) && xIS_SET(gch->act, ACT_GUARDIAN ) )
skills.c:      if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
skills.c:   if( ch->mount )
skills.c:      af.duration = ( int )( ch->level * DUR_CONV );
skills.c:   if( ch->mount )
skills.c:      xREMOVE_BIT( ch->affected_by, AFF_HIDE );
skills.c:      xSET_BIT( ch->affected_by, AFF_HIDE );
skills.c:   xREMOVE_BIT( ch->affected_by, AFF_HIDE );
skills.c:   xREMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
skills.c:   xREMOVE_BIT( ch->affected_by, AFF_SNEAK );
skills.c:   if( !IS_NPC( ch ) && ch->pcdata->clan )
skills.c:      location = get_room_index( ch->pcdata->clan->recall );
skills.c:   if( !IS_NPC( ch ) && !location && ch->level >= 5 && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
skills.c:      location = get_room_index( race_table[ch->race]->race_recall );
skills.c:   if( ch->in_room == location )
skills.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL ) )
skills.c:         lose = ( int )( ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.1 );
skills.c:         if( ch->desc )
skills.c:      lose = ( int )( ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.2 );
skills.c:      if( ch->desc )
skills.c:   if( ch->mount )
skills.c:      char_from_room( ch->mount );
skills.c:      char_to_room( ch->mount, location );
skills.c:   if( ch->mount )
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_mount]->skill_level[ch->Class] )
skills.c:   if( ch->mount )
skills.c:      ch->mount = victim;
skills.c:      ch->position = POS_MOUNTED;
skills.c:   if( ( victim = ch->mount ) == NULL )
skills.c:      ch->mount = NULL;
skills.c:      ch->position = POS_STANDING;
skills.c:      ch->mount = NULL;
skills.c:      ch->position = POS_SITTING;
skills.c:   if( !chance( victim, chances + victim->level - ch->level ) )
skills.c:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) )   /* SB */
skills.c:   if( !chance( victim, chances + victim->level - ch->level ) )
skills.c:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) )
skills.c:   if( !chance( victim, chances + victim->level - ch->level ) )
skills.c:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) )
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_poison_weapon]->skill_level[ch->Class] )
skills.c:   if( ch->fighting )
skills.c:   for( pobj = ch->first_carrying; pobj; pobj = pobj->next_content )
skills.c:   for( wobj = ch->first_carrying; wobj; wobj = wobj->next_content )
skills.c:   if( !IS_NPC( ch ) && ( ( get_curr_dex( ch ) < 17 ) || ch->pcdata->condition[COND_DRUNK] > 0 ) )
skills.c:      damage( ch, ch, ch->level, gsn_poison_weapon );
skills.c:   obj->timer = UMIN( obj->level, ch->level );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_scribe]->skill_level[ch->Class] )
skills.c:                                   100 / ( 2 + ch->level - skill_table[sn]->skill_level[ch->Class] ) );
skills.c:   if( !IS_NPC( ch ) && ch->mana < mana )
skills.c:      ch->mana -= ( mana / 2 );
skills.c:      ch->mana -= ( mana / 2 );
skills.c:   scroll->value[0] = ch->level;
skills.c:   ch->mana -= mana;
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_brew]->skill_level[ch->Class] )
skills.c:                                   100 / ( 2 + ch->level - skill_table[sn]->skill_level[ch->Class] ) );
skills.c:   if( !IS_NPC( ch ) && ch->mana < mana )
skills.c:   for( fire = ch->in_room->first_content; fire; fire = fire->next_content )
skills.c:      ch->mana -= ( mana / 2 );
skills.c:      ch->mana -= ( mana / 2 );
skills.c:   potion->value[0] = ch->level;
skills.c:   ch->mana -= mana;
skills.c:   if( number_percent(  ) >= schance + victim->level - ch->level )
skills.c:   if( ch->mount )
skills.c:   if( !ch->fighting )
skills.c:   if( !ch->fighting )
skills.c:   af.duration = number_range( ch->level / 5, ch->level * 2 / 5 );
skills.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:   if( !ch->in_room->first_person )
skills.c:   for( vch = ch->in_room->first_person; vch; vch = vch_next )
skills.c:      vch_next = vch->next_in_room;
skills.c:      if( ++nvict > ch->level / 5 )
skills.c:   ch->move = UMAX( 0, ch->move - nvict * 3 + nhit );
skills.c:            || ch->level - victim->level > 10
skills.c:            || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
skills.c:          && ( ch->in_room->vnum < 29 || ch->in_room->vnum > 43 ) && ch != victim )
skills.c:          * (IS_NPC(ch) ? ch->short_descr : ch->name),
skills.c:                                         ( !IS_NPC( ch ) && !xIS_SET( ch->act, PLR_HOLYLIGHT ) ) ) )
skills.c:   was_in_room = ch->in_room;
skills.c:   if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:   if( ch->level < 50 )
skills.c:   if( ch->level < 40 )
skills.c:   if( ch->level < 30 )
skills.c:      if( room_is_private( pexit->to_room ) && ch->level < LEVEL_GREATER )
skills.c:      send_to_char( ch->in_room->name, ch );
skills.c:      show_list_to_char( ch->in_room->first_content, ch, FALSE, FALSE );
skills.c:      show_char_to_char( ch->in_room->first_person, ch );
skills.c:      switch ( ch->in_room->sector_type )
skills.c:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:   was_in_room = ch->in_room;
skills.c:   if( ch->level < 50 )
skills.c:   if( ch->level < 40 )
skills.c:   if( ch->level < 30 )
skills.c:      if( room_is_private( pexit->to_room ) && ch->level < LEVEL_GREATER )
skills.c:      switch ( ch->in_room->sector_type )
skills.c:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
skills.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:   if( IS_NPC( victim ) && xIS_SET( victim->act, ACT_SENTINEL ) && ch->in_room != victim->in_room )
skills.c:         global_retcode = spell_attack( dt, ch->level, ch, victim );
skills.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_PRIVATE ) || xIS_SET( ch->in_room->room_flags, ROOM_SOLITARY ) )
skills.c:      if( ch->in_room->tunnel > 0 )
skills.c:         for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
skills.c:         if( count >= ch->in_room->tunnel )
skills.c:       * if ( IS_NPC(vch) && xIS_SET(vch->act, ACT_STAY_AREA)
skills.c:       * &&   ch->in_room->area != vch->in_room->area) )
skills.c:      if( xIS_SET( vch->in_room->room_flags, ROOM_NOMISSILE ) )
skills.c:      if( vch->num_fighting > MAX_FIGHT )
skills.c:      if( !IS_NPC( vch ) && !IS_NPC( ch ) && xIS_SET( ch->act, PLR_NICE ) )
skills.c:   was_in_room = ch->in_room;
skills.c:         for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
skills.c:      if( victim && ch->in_room == victim->in_room )
skills.c:            obj_to_room( projectile, ch->in_room );
skills.c:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:            obj_to_room( projectile, ch->in_room );
skills.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:  for ( throw_obj = ch->last_carrying; throw_obj;
skills.c:  if ( ch->fighting )
skills.c:    victim = ch->fighting;
skills.c:   if( !IS_NPC( ch ) && !IS_IMMORTAL( ch ) && ch->level < skill_table[gsn_slice]->skill_level[ch->Class] )
skills.c:         damage( ch, ch, ch->level, gsn_slice );
skills.c:                       ch->style == STYLE_BERSERK ? "&Rberserk" :
skills.c:                       ch->style == STYLE_AGGRESSIVE ? "&Raggressive" :
skills.c:                       ch->style == STYLE_DEFENSIVE ? "&Ydefensive" :
skills.c:                       ch->style == STYLE_EVASIVE ? "&Yevasive" : "standard" );
skills.c:      if( ch->level < skill_table[gsn_style_evasive]->skill_level[ch->Class] )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_EVASIVE;
skills.c:         ch->style = STYLE_EVASIVE;
skills.c:      if( ch->level < skill_table[gsn_style_defensive]->skill_level[ch->Class] )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_DEFENSIVE;
skills.c:         ch->style = STYLE_DEFENSIVE;
skills.c:      if( ch->level < skill_table[gsn_style_standard]->skill_level[ch->Class] )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_FIGHTING;
skills.c:         ch->style = STYLE_FIGHTING;
skills.c:      if( ch->level < skill_table[gsn_style_aggressive]->skill_level[ch->Class] )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_AGGRESSIVE;
skills.c:         ch->style = STYLE_AGGRESSIVE;
skills.c:      if( ch->level < skill_table[gsn_style_berserk]->skill_level[ch->Class] )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_BERSERK;
skills.c:         ch->style = STYLE_BERSERK;
skills.c:   else if( ch->morph && ch->morph->morph && ch->morph->morph->skills &&
skills.c:            ch->morph->morph->skills[0] != '\0' &&
skills.c:            is_name( skill_table[gsn]->name, ch->morph->morph->skills ) && percent < 85 )
skills.c:   if( ch->morph && ch->morph->morph && ch->morph->morph->no_skills &&
skills.c:       ch->morph->morph->no_skills[0] != '\0' && is_name( skill_table[gsn]->name, ch->morph->morph->no_skills ) )
skills.c:   if( skill_table[gsn]->guild == 99 && !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
skills.c:   if( IS_NPC( ch ) || ch->level < skill_table[gsn_cook]->skill_level[ch->Class] )
skills.c:   for( fire = ch->in_room->first_content; fire; fire = fire->next_content )
Binary file smaug.exe matches
special.c:   if( ch->position <= POS_SLEEPING )
special.c:   if( ch->fighting || ch->fearing || !ch->hating || xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
special.c:   if( ch->hunting )
special.c:   one_argument( ch->hating->name, name );
special.c:      if( !str_cmp( ch->hating->name, victim->name ) )
special.c:   if( ch->in_room == victim->in_room )
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, victim );
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, NULL );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:         spell_smaug( skill_lookup( "armor" ), ch->level, ch, victim );
special.c:         spell_smaug( skill_lookup( "bless" ), ch->level, ch, victim );
special.c:         spell_cure_blindness( skill_lookup( "cure blindness" ), ch->level, ch, victim );
special.c:         spell_smaug( skill_lookup( "cure light" ), ch->level, ch, victim );
special.c:         spell_cure_poison( skill_lookup( "cure poison" ), ch->level, ch, victim );
special.c:         spell_smaug( skill_lookup( "refresh" ), ch->level, ch, victim );
special.c:         spell_smaug( skill_lookup( "cure serious" ), ch->level, ch, victim );
special.c:         spell_remove_curse( skill_lookup( "remove curse" ), ch->level, ch, victim );
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      if( ch->level >= min_level )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, victim );
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      if( ch->level >= min_level )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, victim );
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      if( ch->level >= min_level )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, victim );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
special.c:   char_to_room( create_mobile( cityguard ), ch->in_room );
special.c:   char_to_room( create_mobile( cityguard ), ch->in_room );
special.c:   for( corpse = ch->in_room->first_content; corpse; corpse = c_next )
special.c:         obj_to_room( obj, ch->in_room );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:   if( victim && xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
special.c:   for( trash = ch->in_room->first_content; trash; trash = trash_next )
special.c:      if( IS_OBJ_STAT( trash, ITEM_PROTOTYPE ) && !xIS_SET( ch->act, ACT_PROTOTYPE ) )
special.c:   if( ch->fighting )
special.c:   if( !move || ch->position < POS_SLEEPING )
special.c:         move_char( ch, get_exit( ch->in_room, path[pos] - '0' ), 0 );
special.c:         ch->position = POS_STANDING;
special.c:         ch->position = POS_SLEEPING;
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   if( ( victim = who_fighting( ch ) ) == NULL || number_percent(  ) > 2 * ch->level )
special.c:   spell_poison( gsn_poison, ch->level, ch, victim );
special.c:   if( ch->position != POS_STANDING )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      if( IS_AWAKE( victim ) && number_range( 0, ch->level ) == 0 )
special.c:         maxgold = ch->level * ch->level * 1000;
special.c:         gold = victim->gold * number_range( 1, URANGE( 2, ch->level / 4, 10 ) ) / 100;
special.c:         ch->gold += 9 * gold / 10;
special.c:         if( ch->gold > maxgold )
special.c:            boost_economy( ch->in_room->area, ch->gold - maxgold / 2 );
special.c:            ch->gold = maxgold / 2;
special.c:   was_in_room = ch->in_room;
special.c:   if( ( pexit = ch->in_room->first_exit ) != NULL )
special.c:      for( trash = ch->in_room->first_content; trash; trash = trash_next )
special.c:            if( ch->level < trash->level )
special.c:               for( obj2 = ch->first_carrying; obj2; obj2 = obj2->next_content )
special.c:                  if( ( pexit = get_exit( ch->in_room, door ) ) != NULL
special.c:                        for( vch = pexit->to_room->first_person; vch; vch = vch->next_in_room )
special.c:                           if( !str_cmp( vch->spec_funname, "spec_wanderer" ) )
track.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_track] <= 0 )
track.c:   maxdist = 100 + ch->level * 30;
track.c:   dir = find_first_step( ch->in_room, vict->in_room, maxdist );
track.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
track.c:   if( !ch || !ch->hunting || ch->position < 5 )
track.c:      if( ch->hunting->who == tmp )
track.c:   if( ch->in_room == ch->hunting->who->in_room )
track.c:      if( ch->fighting )
track.c:      found_prey( ch, ch->hunting->who );
track.c:   ret = find_first_step( ch->in_room, ch->hunting->who->in_room, 500 + ch->level * 25 );
track.c:      if( ( pexit = get_exit( ch->in_room, ret ) ) == NULL )
track.c:      if( !ch->hunting )
track.c:         if( !ch->in_room )
track.c:            bug( "Hunt_victim: no ch->in_room!  Mob #%d, name: %s.  Placing mob in limbo.", ch->pIndexData->vnum, ch->name );
track.c:      if( ch->in_room == ch->hunting->who->in_room )
track.c:         found_prey( ch, ch->hunting->who );
track.c:         if( ( vch = scan_for_victim( ch, pexit, ch->hunting->name ) ) != NULL )
track.c:            if( !mob_fire( ch, ch->hunting->who->name ) )
update.c:   snprintf( buf, MAX_STRING_LENGTH, "the %s", title_table[ch->Class][ch->level][ch->sex == SEX_FEMALE ? 1 : 0] );
update.c:   add_hp = con_app[get_curr_con( ch )].hitp + number_range( class_table[ch->Class]->hp_min, class_table[ch->Class]->hp_max );
update.c:   add_mana = class_table[ch->Class]->fMana ? number_range( 2, ( 2 * get_curr_int( ch ) + get_curr_wis( ch ) ) / 8 ) : 0;
update.c:   add_hp = UMAX( 1, add_hp ) + ( ch->pcdata->lck * .3 );
update.c:   add_mana = UMAX( 0, add_mana ) + ( (ch->pcdata->lck * .4) + ch->pcdata->intel );
update.c:   add_move = UMAX( 10, add_move ) + (( ch->pcdata->lck * .5 ) + ch->pcdata->dex );
update.c:   ch->max_hit += add_hp;
update.c:   ch->max_mana += add_mana;
update.c:   ch->max_move += add_move;
update.c:   ch->practice += add_prac;
update.c:   ch->pcdata->str += 1;
update.c:   ch->pcdata->intel += 1;
update.c:   ch->pcdata->dex += 1;
update.c:   ch->pcdata->lck += 1;
update.c:   ch->pcdata->def += 1;
update.c:   ch->pcdata->mdef += 1;
update.c:   ch->pcdata->att += 1;
update.c:      xREMOVE_BIT( ch->act, PLR_BOUGHT_PET );
update.c:   if( ch->level == LEVEL_AVATAR )
update.c:            ch_printf( d->character, "%s has attained the rank of Avatar!\r\n", ch->name );
update.c:   ch->hit = ch->max_hit;
update.c:   ch->mana = ch->max_mana;
update.c:   ch->move = ch->max_move;
update.c:   if( ch->level < LEVEL_IMMORTAL )
update.c:                   add_hp, ch->max_hit, add_mana, ch->max_mana, add_move, ch->max_move, add_prac, ch->practice );
update.c:   if( IS_NPC( ch ) || ch->level >= LEVEL_AVATAR )
update.c:   if( modgain > 0 && IS_PKILL( ch ) && ch->level < 17 )
update.c:      if( ch->level <= 6 )
update.c:      if( ch->level <= 10 && ch->level >= 7 )
update.c:      if( ch->level <= 13 && ch->level >= 11 )
update.c:      if( ch->level <= 16 && ch->level >= 14 )
update.c:   modgain *= ( race_table[ch->race]->exp_multiplier / 100.0 );
update.c:      if( ch->exp + modgain < exp_level( ch, ch->level ) )
update.c:         modgain = exp_level( ch, ch->level ) - ch->exp;
update.c:   modgain = UMIN( (int)modgain, exp_level( ch, ch->level + 2 ) - exp_level( ch, ch->level + 1 ) );
update.c:   ch->exp = UMAX( 0, ch->exp + ( int )modgain );
update.c:   if( NOT_AUTHED( ch ) && ch->exp >= exp_level( ch, ch->level + 1 ) )
update.c:      ch->exp = ( exp_level( ch, ( ch->level + 1 ) ) - 1 );
update.c:   while( ch->level < LEVEL_AVATAR && ch->exp >= exp_level( ch, ch->level + 1 ) )
update.c:      ch->level += 1;
update.c:      ch_printf( ch, "You have now obtained experience level %d!\r\n", ch->level );
update.c:      gain = ch->level * 3 / 2;
update.c:      gain = UMIN( 5, ch->level );
update.c:      switch ( ch->position )
update.c:         if( ch->pcdata->condition[COND_BLOODTHIRST] <= 1 )
update.c:         else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( 8 + ch->level ) )
update.c:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:   return UMIN( gain, ch->max_hit - ch->hit );
update.c:      gain = ch->level;
update.c:      gain = UMIN( 5, ch->level / 2 );
update.c:      if( ch->position < POS_SLEEPING )
update.c:      switch ( ch->position )
update.c:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:   return UMIN( gain, ch->max_mana - ch->mana );
update.c:      gain = ch->level;
update.c:      gain = UMAX( 15, 2 * ch->level );
update.c:      switch ( ch->position )
update.c:         if( ch->pcdata->condition[COND_BLOODTHIRST] <= 1 )
update.c:         else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( 8 + ch->level ) )
update.c:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:   return UMIN( gain, ch->max_move - ch->move );
update.c:   if( value == 0 || IS_NPC( ch ) || ch->level >= LEVEL_IMMORTAL || NOT_AUTHED( ch ) )
update.c:   condition = ch->pcdata->condition[iCond];
update.c:      ch->pcdata->condition[iCond] = URANGE( 0, condition + value, 10 + ch->level );
update.c:      ch->pcdata->condition[iCond] = URANGE( 0, condition + value, 48 );
update.c:   if( ch->pcdata->condition[iCond] == 0 )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR )
update.c:               retcode = damage( ch, ch, ch->max_hit / 20, TYPE_UNDEFINED );
update.c:   if( ch->pcdata->condition[iCond] == 1 )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR )
update.c:   if( ch->pcdata->condition[iCond] == 2 )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR )
update.c:   if( ch->pcdata->condition[iCond] == 3 )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR )
update.c:   if( ch->alignment < race_table[ch->race]->minalign )
update.c:   if( ch->alignment > race_table[ch->race]->maxalign )
update.c:   if( ch->Class == CLASS_PALADIN )
update.c:      if( ch->alignment < 250 )
update.c:      if( ch->alignment < 500 )
update.c:      if( !ch->in_room || IS_AFFECTED( ch, AFF_CHARM ) || IS_AFFECTED( ch, AFF_PARALYSIS ) || IS_AFFECTED( ch, AFF_POSSESS ) )
update.c:      if( ch->pIndexData->vnum == MOB_VNUM_ANIMATED_CORPSE && !IS_AFFECTED( ch, AFF_CHARM ) )
update.c:         if( ch->in_room->first_person )
update.c:      if( !xIS_SET( ch->act, ACT_RUNNING ) && !xIS_SET( ch->act, ACT_SENTINEL ) && !ch->fighting && ch->hunting )
update.c:      if( !xIS_SET( ch->act, ACT_RUNNING ) && ch->spec_fun && !IS_AFFECTED( ch, AFF_POSSESS ) )
update.c:         if( ( *ch->spec_fun ) ( ch ) )
update.c:      if( HAS_PROG( ch->pIndexData, SCRIPT_PROG ) && !xIS_SET( ch->act, ACT_STOP_SCRIPT ) )
update.c:      if( ch->position != POS_STANDING )
update.c:      if( xIS_SET( ch->act, ACT_MOUNTED ) )
update.c:         if( xIS_SET( ch->act, ACT_AGGRESSIVE ) || xIS_SET( ch->act, ACT_META_AGGR ) )
update.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE )
update.c:          && ( xIS_SET( ch->act, ACT_AGGRESSIVE ) || xIS_SET( ch->act, ACT_META_AGGR ) ) )
update.c:      if( ch->in_room->area->nplayer > 0 )
update.c:         if( ch->position < POS_STANDING )
update.c:      if( ch->position < POS_STANDING )
update.c:      if( xIS_SET( ch->act, ACT_SCAVENGER ) && ch->in_room->first_content && number_bits( 2 ) == 0 )
update.c:         for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
update.c:            if( IS_OBJ_STAT( obj, ITEM_PROTOTYPE ) && !xIS_SET( ch->act, ACT_PROTOTYPE ) )
update.c:      if( !xIS_SET( ch->act, ACT_RUNNING )
update.c:          && !xIS_SET( ch->act, ACT_SENTINEL )
update.c:          && !xIS_SET( ch->act, ACT_PROTOTYPE )
update.c:          && ( pexit = get_exit( ch->in_room, door ) ) != NULL
update.c:          && ( !xIS_SET( ch->act, ACT_STAY_AREA ) || pexit->to_room->area == ch->in_room->area ) )
update.c:         if( retcode != rNONE || xIS_SET( ch->act, ACT_SENTINEL ) || ch->position < POS_STANDING )
update.c:      if( ch->hit < ch->max_hit / 2
update.c:          && ( pexit = get_exit( ch->in_room, door ) ) != NULL
update.c:          && ( !xIS_SET( ch->act, ACT_STAY_AREA ) || pexit->to_room->area == ch->in_room->area ) )
update.c:         for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
update.c:                     snprintf( buf, MAX_STRING_LENGTH, "Get away from me, %s!", rch->name );
update.c:                     snprintf( buf, MAX_STRING_LENGTH, "Leave me be, %s!", rch->name );
update.c:                     snprintf( buf, MAX_STRING_LENGTH, "%s is trying to kill me!  Help!", rch->name );
update.c:                     snprintf( buf, MAX_STRING_LENGTH, "Someone save me from %s!", rch->name );
update.c:         if( ch->in_room && ch->level > 3 )
update.c:            gain_condition( ch, COND_FULL, -1 + race_table[ch->race]->hunger_mod );
update.c:         if( ch->in_room && ch->level > 3 )
update.c:            sector = ch->in_room->sector_type;
update.c:                  gain_condition( ch, COND_THIRST, -1 + race_table[ch->race]->thirst_mod );
update.c:                  gain_condition( ch, COND_THIRST, -3 + race_table[ch->race]->thirst_mod );
update.c:                     gain_condition( ch, COND_THIRST, -1 + race_table[ch->race]->thirst_mod );
update.c:          && ( !ch->desc || ch->desc->connected == CON_PLAYING )
update.c:          && ch->level >= 2 && current_time - ch->save_time > ( sysdata.save_frequency * 60 ) )
update.c:      if( ch->position >= POS_STUNNED )
update.c:         if( ch->hit < ch->max_hit )
update.c:            ch->hit += hit_gain( ch );
update.c:         if( ch->mana < ch->max_mana )
update.c:            ch->mana += mana_gain( ch );
update.c:         if( ch->move < ch->max_move )
update.c:            ch->move += move_gain( ch );
update.c:      if( ch->position == POS_STUNNED )
update.c:      if( ch->variables )
update.c:         for( vd = ch->variables; vd; vd = vd_next )
update.c:               if( vd == ch->variables )
update.c:                  ch->variables = vd_next;
update.c:      if( ch->morph )
update.c:         if( ch->morph->timer > 0 )
update.c:            --ch->morph->timer;
update.c:            if( ch->morph->timer == 0 )
update.c:      if( !IS_NPC( ch ) && ch->pcdata->nuisance )
update.c:         if( ch->pcdata->nuisance->flags < MAX_NUISANCE_STAGE )
update.c:            temp = ch->pcdata->nuisance->max_time - ch->pcdata->nuisance->set_time;
update.c:            temp *= ch->pcdata->nuisance->flags;
update.c:            temp += ch->pcdata->nuisance->set_time;
update.c:               ++ch->pcdata->nuisance->flags;
update.c:      if( !IS_NPC( ch ) && ch->level < LEVEL_IMMORTAL )
update.c:         if( ++ch->timer >= 12 )
update.c:                * ch->was_in_room = ch->in_room;
update.c:               if( ch->fighting )
update.c:               SET_BIT( ch->pcdata->flags, PCFLAG_IDLE );
update.c:         if( ch->pcdata->condition[COND_DRUNK] > 8 )
update.c:            worsen_mental_state( ch, ch->pcdata->condition[COND_DRUNK] / 8 );
update.c:         if( ch->pcdata->condition[COND_FULL] > 1 )
update.c:            switch ( ch->position )
update.c:         if( ch->pcdata->condition[COND_THIRST] > 1 )
update.c:            switch ( ch->position )
update.c:         gain_condition( ch, COND_FULL, -1 + race_table[ch->race]->hunger_mod );
update.c:         if( ch->Class == CLASS_VAMPIRE && ch->level >= 10 )
update.c:         if( CAN_PKILL( ch ) && ch->pcdata->condition[COND_THIRST] - 9 > 10 )
update.c:         if( !IS_NPC( ch ) && ch->pcdata->nuisance )
update.c:            value = ( ( 0 - ch->pcdata->nuisance->flags ) * ch->pcdata->nuisance->power );
update.c:      if( !IS_NPC( ch ) && !IS_IMMORTAL( ch ) && ch->pcdata->release_date > 0 && ch->pcdata->release_date <= current_time )
update.c:         if( ch->pcdata->clan )
update.c:            location = get_room_index( ch->pcdata->clan->recall );
update.c:            location = ch->in_room;
update.c:         STRFREE( ch->pcdata->helled_by );
update.c:         ch->pcdata->helled_by = NULL;
update.c:         ch->pcdata->release_date = 0;
update.c:            ch->mental_state = URANGE( 20, ch->mental_state + ( IS_NPC( ch ) ? 2 : IS_PKILL( ch ) ? 3 : 4 ), 100 );
update.c:         else if( ch->position == POS_INCAP )
update.c:         else if( ch->position == POS_MORTAL )
update.c:            for( paf = ch->first_affect; paf; paf = paf_next )
update.c:                     if( ( *skill->spell_fun ) ( paf->modifier, ch->level, ch, ch ) == rCHAR_DIED || char_died( ch ) )
update.c:               xREMOVE_BIT( ch->affected_by, AFF_RECURRINGSPELL );
update.c:         if( ch->mental_state >= 30 )
update.c:            switch ( ( ch->mental_state + 5 ) / 10 )
update.c:         if( ch->mental_state <= -30 )
update.c:            switch ( ( abs( ch->mental_state ) + 5 ) / 10 )
update.c:                  if( ch->position > POS_SLEEPING )
update.c:                     if( ( ch->position == POS_STANDING
update.c:                           || ch->position < POS_FIGHTING ) && number_percent(  ) + 10 < abs( ch->mental_state ) )
update.c:                  if( ch->position > POS_SLEEPING )
update.c:                     if( ( ch->position == POS_STANDING
update.c:                           || ch->position < POS_FIGHTING ) && ( number_percent(  ) + 20 ) < abs( ch->mental_state ) )
update.c:                  if( ch->position > POS_SLEEPING )
update.c:                     if( ch->position < POS_SITTING && ( number_percent(  ) + 30 ) < abs( ch->mental_state ) )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:         if( ch->timer > 24 )
update.c:            if( !IS_NPC( tch )   /* && ( tch->level < LEVEL_IMMORTAL ) */
update.c:               if( --obj->value[2] == 0 && tch->in_room )
update.c:                  tch->in_room->light -= obj->count;
update.c:                  if( tch->in_room->light < 0 )
update.c:                     tch->in_room->light = 0;
update.c:         if( xIS_SET( ch->act, ACT_RUNNING ) )
update.c:            if( !xIS_SET( ch->act, ACT_SENTINEL )
update.c:                && ch->position == POS_STANDING && !xIS_SET( ch->act, ACT_MOUNTED ) && !ch->fighting && ch->hunting )
update.c:            if( ch->spec_fun )
update.c:               if( ( *ch->spec_fun ) ( ch ) )
update.c:            if( !xIS_SET( ch->act, ACT_SENTINEL )
update.c:                && ch->position == POS_STANDING
update.c:                && !xIS_SET( ch->act, ACT_MOUNTED )
update.c:                && !xIS_SET( ch->act, ACT_PROTOTYPE )
update.c:                && ( pexit = get_exit( ch->in_room, door ) ) != NULL
update.c:                && ( !xIS_SET( ch->act, ACT_STAY_AREA ) || pexit->to_room->area == ch->in_room->area ) )
update.c:               if( retcode != rNONE || xIS_SET( ch->act, ACT_SENTINEL ) || ch->position < POS_STANDING )
update.c:         if( ch->mount && ch->in_room != ch->mount->in_room )
update.c:            xREMOVE_BIT( ch->mount->act, ACT_MOUNTED );
update.c:            ch->mount = NULL;
update.c:            ch->position = POS_STANDING;
update.c:         if( ( ch->in_room && ch->in_room->sector_type == SECT_UNDERWATER )
update.c:             || ( ch->in_room && ch->in_room->sector_type == SECT_OCEANFLOOR ) )
update.c:               if( ch->level < LEVEL_IMMORTAL )
update.c:                  dam = number_range( ch->max_hit / 100, ch->max_hit / 50 );
update.c:         if( ch->in_room
update.c:             && ( ( ch->in_room->sector_type == SECT_WATER_NOSWIM ) || ( ch->in_room->sector_type == SECT_WATER_SWIM ) ) )
update.c:                && !IS_AFFECTED( ch, AFF_FLOATING ) && !IS_AFFECTED( ch, AFF_AQUA_BREATH ) && !ch->mount )
update.c:               for( obj = ch->first_carrying; obj; obj = obj->next_content )
update.c:                  if( ch->level < LEVEL_IMMORTAL )
update.c:                     if( ch->move > 0 )
update.c:                        mov = number_range( ch->max_move / 20, ch->max_move / 5 );
update.c:                        if( ch->move - mov < 0 )
update.c:                           ch->move = 0;
update.c:                           ch->move -= mov;
update.c:                        dam = number_range( ch->max_hit / 20, ch->max_hit / 5 );
update.c:         if( !ch->desc )
update.c:            for( wch = ch->in_room->first_person; wch; wch = trvch_next( lc2 ) )
update.c:                   || wch->fighting
update.c:                   || !IS_AWAKE( wch ) || ( xIS_SET( wch->act, ACT_WIMPY ) && IS_AWAKE( ch ) ) || !can_see( wch, ch ) )
update.c:               if( ( !xIS_SET( wch->act, ACT_AGGRESSIVE )
update.c:                     && !xIS_SET( wch->act, ACT_META_AGGR ) )
update.c:                   || xIS_SET( wch->act, ACT_MOUNTED ) || xIS_SET( wch->in_room->room_flags, ROOM_SAFE ) )
update.c:      if( !char_died( wch ) && wch->mpactnum > 0 )
update.c:         while( ( tmp_act = wch->mpact ) != NULL )
update.c:            wch->mpact = tmp_act->next;
update.c:         wch->mpactnum = 0;
update.c:         wch->mpact = NULL;
update.c:      if( char_died( wch ) || IS_NPC( wch ) || wch->level >= LEVEL_IMMORTAL || !wch->in_room )
update.c:      for( ch = wch->in_room->first_person; ch; ch = trvch_next( lc ) )
update.c:             || ch->fighting
update.c:             || !IS_AWAKE( ch ) || ( xIS_SET( ch->act, ACT_WIMPY ) && IS_AWAKE( wch ) ) || !can_see( ch, wch ) )
update.c:         if( ( !xIS_SET( ch->act, ACT_AGGRESSIVE )
update.c:               && !xIS_SET( ch->act, ACT_META_AGGR ) )
update.c:             || xIS_SET( ch->act, ACT_MOUNTED ) || xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
update.c:         for( vch = wch->in_room->first_person; vch; vch = vch->next_in_room )
update.c:            if( ( !IS_NPC( vch ) || xIS_SET( ch->act, ACT_META_AGGR )
update.c:                  || xIS_SET( vch->act, ACT_ANNOYING ) )
update.c:                && vch->level < LEVEL_IMMORTAL
update.c:                && ( !xIS_SET( ch->act, ACT_WIMPY ) || !IS_AWAKE( vch ) ) && can_see( ch, vch ) )
update.c:         if( IS_NPC( ch ) && xIS_SET( ch->attacks, ATCK_BACKSTAB ) )
update.c:            if( !ch->mount
update.c:               if( !IS_AWAKE( victim ) || number_percent(  ) + 5 < ch->level )
update.c:         else if( IS_NPC( ch ) && xIS_SET( ch->attacks, ATCK_POUNCE ) )
update.c:            if( !ch->mount && !victim->fighting )
update.c:               if( !IS_AWAKE( victim ) || number_percent(  ) + 5 < ch->level )
update.c:   if( IS_NPC( ch ) || ch->pcdata->condition[COND_DRUNK] <= 0 )
update.c:   drunk = ch->pcdata->condition[COND_DRUNK];
update.c:   position = ch->position;
update.c:   ch->position = POS_STANDING;
update.c:      for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
update.c:      check_social( ch, "puke", ( rvch ? rvch->name : ( char * )"" ) );
update.c:   ch->position = position;
update.c:   if( ch->mental_state >= 30 && number_bits( 5 - ( ch->mental_state >= 50 ) - ( ch->mental_state >= 75 ) ) == 0 )
update.c:      switch ( number_range( 1, UMIN( 21, ( ch->mental_state + 5 ) / 5 ) ) )
update.c:      for( vch = first_char; vch; vch = vch->next )
variables.c:   for( vd = ch->variables; vd; vd = vd->next )
variables.c:   VARIABLE_DATA *vd_next, *vd = ch->variables;
variables.c:      ch->variables = vd->next;
variables.c:   pvd = vd = ch->variables;
variables.c:      if( vd == ch->variables )
variables.c:         ch->variables = var;
variables.c:   var->next = ch->variables;
variables.c:   ch->variables = var;
variables.c:      exp = ch->level * get_curr_int( ch );
variables.c:      vnum = ch->pIndexData ? ch->pIndexData->vnum : 0;
variables.c:      vnum = ch->pIndexData ? ch->pIndexData->vnum : 0;
variables.c:      exp = ch->level * get_curr_int( ch );
variables.c:      vnum = ch->pIndexData ? ch->pIndexData->vnum : 0;
variables.c:      vnum = ch->pIndexData ? ch->pIndexData->vnum : 0;
variables.c:   for( vd = ch->variables; vd; vd = vd->next )
weather.c:   if( !ch->desc )
weather.c:   if( !ch->desc )
weather.c:   struct WeatherCell *cell = getWeatherCell( ch->in_room->area );
weather.c:   if( !ch->desc )
weather.c:   if( !IS_OUTSIDE( ch ) && NO_WEATHER_SECT( ch->in_room->sector_type ) )
act_comm.c:   if( IS_NPC( ch ) || !ch->pcdata )
act_comm.c:   drunk = ch->pcdata->condition[COND_DRUNK];
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:   if( channel == CHANNEL_YELL && xIS_SET( ch->in_room->room_flags, ROOM_NOYELL ) )
act_comm.c:      if( ch->master )
act_comm.c:         send_to_char( "I don't think so...\r\n", ch->master );
act_comm.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_SILENCE ) )
act_comm.c:   if( IS_SET( ch->deaf, channel ) && channel != CHANNEL_WARTALK && channel != CHANNEL_YELL )
act_comm.c:   REMOVE_BIT( ch->deaf, channel );
act_comm.c:   if( IS_IMMORTAL(ch) && xIS_SET( ch->act, PLR_WIZINVIS ) )
act_comm.c:            ch_printf( ch, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
act_comm.c:            ch_printf( ch, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
act_comm.c:            ch_printf( ch, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
act_comm.c:            ch_printf( ch, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
act_comm.c:            ch_printf( ch, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
act_comm.c:            ch_printf( ch, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
act_comm.c:         position = ch->position;
act_comm.c:         ch->position = POS_STANDING;
act_comm.c:         ch->position = position;
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:      snprintf( buf2, MAX_STRING_LENGTH, "%s: %s (%s)", IS_NPC( ch ) ? ch->short_descr : ch->name, argument, verb );
act_comm.c:      if( d->connected == CON_PLAYING && vch != ch && !IS_SET( och->deaf, channel ) )
act_comm.c:             ( !IS_NPC( och ) && !IS_SET( och->pcdata->flags, PCFLAG_RETIRED ) ) )
act_comm.c:               && !( och->pcdata->council && !str_cmp( och->pcdata->council->name, "Newbie Council" ) ) ) )
act_comm.c:         if( xIS_SET( vch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( vch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:            && ( vch->in_room->area != ch->in_room->area || xIS_SET( vch->in_room->room_flags, ROOM_NOYELL )
act_comm.c:            || ( ( xIS_SET( vch->in_room->room_flags, ROOM_HOUSE ) || xIS_SET( och->in_room->room_flags, ROOM_HOUSE ) )
act_comm.c:            if( vch->pcdata->clan != ch->pcdata->clan )
act_comm.c:            if( vch->pcdata->council != ch->pcdata->council )
act_comm.c:            if( vch->race != ch->race )
act_comm.c:         if( xIS_SET( ch->act, PLR_WIZINVIS ) && can_see( vch, ch ) && IS_IMMORTAL( vch ) )
act_comm.c:            snprintf( lbuf, MAX_INPUT_LENGTH + 4, "(%d) ", ( !IS_NPC( ch ) ) ? ch->pcdata->wizinvis : ch->mobinvis );
act_comm.c:         position = vch->position;
act_comm.c:            vch->position = POS_STANDING;
act_comm.c:         if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:            int speakswell = UMIN( knows_language( vch, ch->speaking, ch ),
act_comm.c:                                   knows_language( ch, ch->speaking, vch ) );
act_comm.c:         if( !knows_language( vch, ch->speaking, ch ) && ( !IS_NPC( ch ) || ch->speaking != 0 ) )
act_comm.c:            sbuf = scramble( argument, ch->speaking );
act_comm.c:         if( !IS_NPC( ch ) && ch->pcdata->nuisance
act_comm.c:             && ch->pcdata->nuisance->flags > 7
act_comm.c:             && ( number_percent(  ) < ( ( ch->pcdata->nuisance->flags - 7 ) * 10 * ch->pcdata->nuisance->power ) ) )
act_comm.c:         if( !IS_NPC( vch ) && vch->pcdata->nuisance &&
act_comm.c:             vch->pcdata->nuisance->flags > 7
act_comm.c:             && ( number_percent(  ) < ( ( vch->pcdata->nuisance->flags - 7 ) * 10 * vch->pcdata->nuisance->power ) ) )
act_comm.c:         vch->position = position;
act_comm.c:      if( d->connected == CON_PLAYING && !IS_SET( och->deaf, channel ) && get_trust( vch ) >= level )
act_comm.c:   if( IS_NPC( ch ) || !ch->pcdata->clan
act_comm.c:       || ch->pcdata->clan->clan_type == CLAN_ORDER || ch->pcdata->clan->clan_type == CLAN_GUILD )
act_comm.c:            && !( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, "Newbie Council" ) ) ) )
act_comm.c:   if( IS_NPC( ch ) || !ch->pcdata->clan || ch->pcdata->clan->clan_type != CLAN_ORDER )
act_comm.c:   if( IS_NPC( ch ) || !ch->pcdata->council )
act_comm.c:   if( IS_NPC( ch ) || !ch->pcdata->clan || ch->pcdata->clan->clan_type != CLAN_GUILD )
act_comm.c:   if( !IS_IMMORTAL( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_RETIRED ) )
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:         ch_printf( victim, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see( victim, ch ) ? "Someone" : ch->name );
act_comm.c:   actflags = ch->act;
act_comm.c:      xREMOVE_BIT( ch->act, ACT_SECRETIVE );
act_comm.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
act_comm.c:            ch_printf( vch, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see(vch, ch) ? "Someone" : ch->name );
act_comm.c:      if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:         int speakswell = UMIN( knows_language( vch, ch->speaking, ch ), knows_language( ch, ch->speaking, vch ) );
act_comm.c:      if( !knows_language( vch, ch->speaking, ch ) && ( !IS_NPC( ch ) || ch->speaking != 0 ) )
act_comm.c:         sbuf = scramble( argument, ch->speaking );
act_comm.c:   ch->act = actflags;
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:      snprintf( buf, MAX_STRING_LENGTH, "%s: %s", IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:   actflags = ch->act;
act_comm.c:      xREMOVE_BIT( ch->act, ACT_SECRETIVE );
act_comm.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
act_comm.c:            ch_printf( vch, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see( vch, ch ) ? "Someone" : ch->name );
act_comm.c:      if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:         int speakswell = UMIN( knows_language( vch, ch->speaking, ch ),
act_comm.c:                                knows_language( ch, ch->speaking, vch ) );
act_comm.c:      if( !knows_language( vch, ch->speaking, ch ) && ( !IS_NPC( ch ) || ch->speaking != 0 ) )
act_comm.c:         sbuf = scramble( argument, ch->speaking );
act_comm.c:   ch->act = actflags;
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:      snprintf( buf, MAX_STRING_LENGTH, "%s: %s", IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:   REMOVE_BIT( ch->deaf, CHANNEL_WHISPER );
act_comm.c:         ch_printf( victim, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see( victim, ch ) ? "Someone" : ch->name );
act_comm.c:   if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:      int speakswell = UMIN( knows_language( victim, ch->speaking, ch ),
act_comm.c:                             knows_language( ch, ch->speaking, victim ) );
act_comm.c:   if( !knows_language( vch, ch->speaking, ch ) && ( !IS_NPC( ch ) || ch->speaking != 0 ) )
act_comm.c:   if( !xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) && !IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:                IS_NPC( ch ) ? ch->short_descr : ch->name, argument, IS_NPC( victim ) ? victim->short_descr : victim->name );
act_comm.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOBECKON ) )
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:   if( !IS_NPC( ch ) && ( xIS_SET( ch->act, PLR_SILENCE ) || xIS_SET( ch->act, PLR_NO_TELL ) ) )
act_comm.c:       || ( IS_NPC( victim ) && victim->in_room != ch->in_room )
act_comm.c:         ch_printf( victim, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see( victim, ch ) ? "Someone" : ch->name );
act_comm.c:   ch->retell = victim;
act_comm.c:   REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
act_comm.c:       isalpha( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) )
act_comm.c:      snprintf( buf, MAX_INPUT_LENGTH, "%s told you '%s'\r\n", capitalize( IS_NPC( ch ) ? ch->short_descr : ch->name ), argument );
act_comm.c:      victim->pcdata->lt_index = tolower( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) - 'a';
act_comm.c:   if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:      int speakswell = UMIN( knows_language( victim, ch->speaking, ch ),
act_comm.c:                             knows_language( ch, ch->speaking, victim ) );
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:                IS_NPC( ch ) ? ch->short_descr : ch->name, argument, IS_NPC( victim ) ? victim->short_descr : victim->name );
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_SILENCE ) )
act_comm.c:   if( ( victim = ch->reply ) == NULL )
act_comm.c:         ch_printf( victim, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see( victim, ch ) ? "Someone" : ch->name );
act_comm.c:   REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
act_comm.c:   if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:      int speakswell = UMIN( knows_language( victim, ch->speaking, ch ),
act_comm.c:                             knows_language( ch, ch->speaking, victim ) );
act_comm.c:   if( knows_language( victim, ch->speaking, ch ) || ( IS_NPC( ch ) && !ch->speaking ) )
act_comm.c:      act( AT_TELL, "$n tells you '$t'", ch, scramble( argument, ch->speaking ), victim, TO_VICT );
act_comm.c:   ch->retell = victim;
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:                IS_NPC( ch ) ? ch->short_descr : ch->name, argument, IS_NPC( victim ) ? victim->short_descr : victim->name );
act_comm.c:       isalpha( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) )
act_comm.c:      snprintf( buf, MAX_STRING_LENGTH, "%s told you '%s'\r\n", capitalize( IS_NPC( ch ) ? ch->short_descr : ch->name ),
act_comm.c:      victim->pcdata->lt_index = tolower( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) - 'a';
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SILENCE ) || IS_SET( ch->in_room->area->flags, AFLAG_SILENCE ) )
act_comm.c:   if( !IS_NPC( ch ) && ( xIS_SET( ch->act, PLR_SILENCE ) || xIS_SET( ch->act, PLR_NO_TELL ) ) )
act_comm.c:   victim = ch->retell;
act_comm.c:         ch_printf( victim, "You attempy to ignore %s, but are unable to do so.\r\n", !can_see( victim, ch ) ? "Someone" : ch->name );
act_comm.c:       isalpha( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) )
act_comm.c:      snprintf( buf, MAX_INPUT_LENGTH, "%s told you '%s'\r\n", capitalize( IS_NPC( ch ) ? ch->short_descr : ch->name ),
act_comm.c:      victim->pcdata->lt_index = tolower( IS_NPC( ch ) ? ch->short_descr[0] : ch->name[0] ) - 'a';
act_comm.c:   REMOVE_BIT( ch->deaf, CHANNEL_TELLS );
act_comm.c:   if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:      int speakswell = UMIN( knows_language( victim, ch->speaking, ch ),
act_comm.c:                             knows_language( ch, ch->speaking, victim ) );
act_comm.c:   if( knows_language( victim, ch->speaking, ch ) || ( IS_NPC( ch ) && !ch->speaking ) )
act_comm.c:      act( AT_TELL, "$n tells you '$t'", ch, scramble( argument, ch->speaking ), victim, TO_VICT );
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:                IS_NPC( ch ) ? ch->short_descr : ch->name, argument, IS_NPC( victim ) ? victim->short_descr : victim->name );
act_comm.c:   if( IS_NPC( ch ) || !IS_IMMORTAL( ch ) || !ch->pcdata->tell_history )
act_comm.c:      tindex = ch->pcdata->lt_index;
act_comm.c:   if( ch->pcdata->tell_history[tindex] )
act_comm.c:      send_to_char( ch->pcdata->tell_history[tindex], ch );
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_NO_EMOTE ) )
act_comm.c:   actflags = ch->act;
act_comm.c:      xREMOVE_BIT( ch->act, ACT_SECRETIVE );
act_comm.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
act_comm.c:            ch_printf( vch, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see( vch, ch ) ? "Someone" : ch->name );
act_comm.c:      if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:         int speakswell = UMIN( knows_language( vch, ch->speaking, ch ),
act_comm.c:                                knows_language( ch, ch->speaking, vch ) );
act_comm.c:      if( !knows_language( vch, ch->speaking, ch ) && ( !IS_NPC( ch ) && ch->speaking != 0 ) )
act_comm.c:         sbuf = scramble( buf, ch->speaking );
act_comm.c:   ch->act = actflags;
act_comm.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_LOGSPEECH ) )
act_comm.c:      snprintf( buf, MAX_STRING_LENGTH, "%s %s (emote)", IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
act_comm.c:   if( get_trust( ch ) >= LEVEL_ASCENDANT || is_name( "bug", ch->pcdata->bestowments ) )
act_comm.c:   if( ch->position == POS_FIGHTING
act_comm.c:       || ch->position == POS_EVASIVE
act_comm.c:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
act_comm.c:   if( ch->position < POS_STUNNED )
act_comm.c:   if( !IS_IMMORTAL( ch ) && xIS_SET( ch->in_room->room_flags, ROOM_NOQUIT ) )
act_comm.c:   if( IS_PKILL( ch ) && ch->wimpy > ( int )ch->max_hit / 2.25 )
act_comm.c:   if( ch->position == POS_MOUNTED )
act_comm.c:   snprintf( log_buf, MAX_STRING_LENGTH, "%s has quit (Room %d).", ch->name, ( ch->in_room ? ch->in_room->vnum : -1 ) );
act_comm.c:   if( ch->level >= LEVEL_HERO && !ch->pcdata->pet ) /* Pet crash fix */
act_comm.c:      xREMOVE_BIT( ch->act, PLR_BOUGHT_PET );
act_comm.c:   if( sysdata.save_pets && ch->pcdata->pet )
act_comm.c:      act( AT_BYE, "$N follows $S master into the Void.", ch, NULL, ch->pcdata->pet, TO_ROOM );
act_comm.c:      extract_char( ch->pcdata->pet, TRUE );
act_comm.c:   if( ch->pcdata->clan )
act_comm.c:      save_clan( ch->pcdata->clan );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      write_to_buffer( ch->desc, BUFF, num );
act_comm.c:      xSET_BIT( ch->act, PLR_RIP );
act_comm.c:      xSET_BIT( ch->act, PLR_ANSI );
act_comm.c:      xREMOVE_BIT( ch->act, PLR_RIP );
act_comm.c:      xSET_BIT( ch->act, PLR_ANSI );
act_comm.c:      xREMOVE_BIT( ch->act, PLR_ANSI );
act_comm.c:   if( ch->level < 2 )
act_comm.c:   if( !ch->pcdata->council )
act_comm.c:   if( str_cmp( ch->pcdata->council->name, "Newbie Council" ) )
act_comm.c:      for( gch = first_char; gch; gch = gch->next )
act_comm.c:         if( gch->master == ch && gch != ch )
act_comm.c:   ch_printf( victim, "%s beckons to you...\r\n", ch->name );
act_comm.c:   if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master )
act_comm.c:      act( AT_PLAIN, "But you'd rather follow $N!", ch, NULL, ch->master, TO_CHAR );
act_comm.c:      if( !ch->master )
act_comm.c:   if( ( ch->level - victim->level < -10 || ch->level - victim->level > 10 )
act_comm.c:       && !IS_HERO( ch ) && !( ch->level < 15 && !IS_NPC( victim )
act_comm.c:   if( ch->master )
act_comm.c:   if( ch->master )
act_comm.c:   ch->master = master;
act_comm.c:   ch->leader = NULL;
act_comm.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_PET ) && !IS_NPC( master ) )
act_comm.c:   if( !ch->master )
act_comm.c:   if( IS_NPC( ch ) && !IS_NPC( ch->master ) && ch->master->pcdata->pet == ch )
act_comm.c:      ch->master->pcdata->pet = NULL;
act_comm.c:      xREMOVE_BIT( ch->affected_by, AFF_CHARM );
act_comm.c:      if( !IS_NPC( ch->master ) )
act_comm.c:         ch->master->pcdata->charmies--;
act_comm.c:   if( can_see( ch->master, ch ) )
act_comm.c:      if( !( !IS_NPC( ch->master ) && IS_IMMORTAL( ch ) && !IS_IMMORTAL( ch->master ) ) )
act_comm.c:         act( AT_ACTION, "$n stops following you.", ch, NULL, ch->master, TO_VICT );
act_comm.c:   act( AT_ACTION, "You stop following $N.", ch, NULL, ch->master, TO_CHAR );
act_comm.c:   ch->master = NULL;
act_comm.c:   ch->leader = NULL;
act_comm.c:   if( ch->master )
act_comm.c:   ch->leader = NULL;
act_comm.c:   for( fch = first_char; fch; fch = fch->next )
act_comm.c:      if( fch->master == ch )
act_comm.c:      if( fch->leader == ch )
act_comm.c:         fch->leader = fch;
act_comm.c:   for( och = ch->in_room->first_person; och; och = och_next )
act_comm.c:      och_next = och->next_in_room;
act_comm.c:      if( IS_AFFECTED( och, AFF_CHARM ) && och->master == ch && ( fAll || och == victim ) && !IS_IMMORTAL( och ) )
act_comm.c:      snprintf( log_buf, MAX_STRING_LENGTH, "%s: order %s.", ch->name, argbuf );
act_comm.c:      log_string_plus( log_buf, LOG_NORMAL, ch->level );
act_comm.c:      leader = ch->leader ? ch->leader : ch;
act_comm.c:                 PERS( leader, ch ), ch->level < LEVEL_AVATAR ? " [to lvl]" : "" );
act_comm.c:      for( gch = first_char; gch; gch = gch->next )
act_comm.c:                          gch->level,
act_comm.c:                          IS_NPC( gch ) ? "Mob" : class_table[gch->Class]->who_name,
act_comm.c:            else if( gch->alignment > 750 )
act_comm.c:            else if( gch->alignment > 350 )
act_comm.c:            else if( gch->alignment > 150 )
act_comm.c:            else if( gch->alignment > -150 )
act_comm.c:            else if( gch->alignment > -350 )
act_comm.c:            else if( gch->alignment > -750 )
act_comm.c:            ch_printf( ch, "%-2d %2.2s %3.3s", gch->level, buf, IS_NPC( gch ) ? "Mob" : class_table[gch->Class]->who_name );
act_comm.c:            if( gch->hit < gch->max_hit / 4 )
act_comm.c:            else if( gch->hit < gch->max_hit / 2.5 )
act_comm.c:            ch_printf( ch, "%5d", gch->hit );
act_comm.c:            ch_printf( ch, "/%-5d ", gch->max_hit );
act_comm.c:            if( gch->Class != CLASS_WARRIOR )
act_comm.c:                          IS_VAMPIRE( gch ) ? gch->pcdata->condition[COND_BLOODTHIRST] : gch->mana,
act_comm.c:                          IS_VAMPIRE( gch ) ? 10 + gch->level : gch->max_mana );
act_comm.c:            if( gch->mental_state < -25 || gch->mental_state > 25 )
act_comm.c:                       gch->mental_state > 75 ? "+++" :
act_comm.c:                       gch->mental_state > 50 ? "=++" :
act_comm.c:                       gch->mental_state > 25 ? "==+" :
act_comm.c:                       gch->mental_state > -25 ? "===" :
act_comm.c:                       gch->mental_state > -50 ? "-==" : gch->mental_state > -75 ? "--=" : "---" );
act_comm.c:            ch_printf( ch, "%5d ", gch->move );
act_comm.c:                       gch->race == 0 ? "human" :
act_comm.c:                       gch->race == 1 ? "elf" :
act_comm.c:                       gch->race == 2 ? "dwarf" :
act_comm.c:                       gch->race == 3 ? "hlflng" :
act_comm.c:                       gch->race == 4 ? "pixie" :
act_comm.c:                       gch->race == 6 ? "h-ogre" :
act_comm.c:                       gch->race == 7 ? "h-orc" :
act_comm.c:                       gch->race == 8 ? "h-trol" :
act_comm.c:                       gch->race == 9 ? "h-elf" :
act_comm.c:                       gch->race == 10 ? "gith" :
act_comm.c:                       gch->race == 11 ? "drow" :
act_comm.c:                       gch->race == 12 ? "seaelf" : gch->race == 13 ? "lizard" : gch->race == 14 ? "gnome" : "" );
act_comm.c:            if( gch->level < LEVEL_AVATAR )
act_comm.c:               ch_printf( ch, "%8d ", exp_level( gch, gch->level + 1 ) - gch->exp );
act_comm.c:      if( ch->leader || ch->master )
act_comm.c:      for( gch = first_char; gch; gch = gch->next )
act_comm.c:            gch->leader = NULL;
act_comm.c:            gch->master = NULL;
act_comm.c:      for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
act_comm.c:             && rch->master == ch
act_comm.c:             && !ch->master
act_comm.c:             && !ch->leader
act_comm.c:             && ( ( abs( ch->level - rch->level ) < 9 && IS_PKILL( ch ) == IS_PKILL( rch ) ) || IS_IMMORTAL( ch ) ) )
act_comm.c:            rch->leader = ch;
act_comm.c:   if( ch->master || ( ch->leader && ch->leader != ch ) )
act_comm.c:   if( ( ch->level - victim->level < -8 || ch->level - victim->level > 8 || ( IS_PKILL( ch ) != IS_PKILL( victim ) ) ) && !IS_IMMORTAL( ch ) )
act_comm.c:   if( ch->gold < amount )
act_comm.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
act_comm.c:   if( xIS_SET( ch->act, PLR_AUTOGOLD ) && members < 2 )
act_comm.c:   ch->gold -= amount;
act_comm.c:   ch->gold += share + extra;
act_comm.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
act_comm.c:         gch->gold += share;
act_comm.c:      if( ch->speaking & lang_array[lang] )
act_comm.c:   if( xIS_SET( ch->act, PLR_NO_TELL ) )
act_comm.c:   for( gch = first_char; gch; gch = gch->next )
act_comm.c:         if( speaking != -1 && ( !IS_NPC( ch ) || ch->speaking ) )
act_comm.c:            int speakswell = UMIN( knows_language( gch, ch->speaking, ch ),
act_comm.c:                                   knows_language( ch, ch->speaking, gch ) );
act_comm.c:               ch_printf( gch, "%s tells the group '%s'\r\n", ch->name,
act_comm.c:               ch_printf( gch, "%s tells the group '%s'\r\n", ch->name, argument );
act_comm.c:            ch_printf( gch, "%s tells the group '%s'\r\n", ch->name, argument );
act_comm.c:         if( knows_language( gch, ch->speaking, gch ) || ( IS_NPC( ch ) && !ch->speaking ) )
act_comm.c:            ch_printf( gch, "%s tells the group '%s'\r\n", ch->name, argument );
act_comm.c:            ch_printf( gch, "%s tells the group '%s'\r\n", ch->name, scramble( argument, ch->speaking ) );
act_comm.c:   if( ach->leader )
act_comm.c:      ach = ach->leader;
act_comm.c:   if( bch->leader )
act_comm.c:      bch = bch->leader;
act_comm.c:   if( IS_NPC( ch ) && !ch->speaks )   /* No langs = knows all for npcs */
act_comm.c:   if( IS_NPC( ch ) && IS_SET( ch->speaks, ( language & ~LANG_CLAN ) ) )
act_comm.c:      if( ch->pcdata->clan == cch->pcdata->clan && ch->pcdata->clan != NULL )
act_comm.c:      if( IS_SET( race_table[ch->race]->language, language ) )
act_comm.c:         if( IS_SET( language, lang_array[lang] ) && IS_SET( ch->speaks, lang_array[lang] ) )
act_comm.c:               return ch->pcdata->learned[sn];
act_comm.c:   if( race_table[ch->race]->language & language )
act_comm.c:   if( ch->speaks & language )
act_comm.c:            if( ch->pcdata->learned[sn] >= 99 )
act_comm.c:      ch->speaking = ~LANG_CLAN;
act_comm.c:            if( lang_array[langs] == LANG_CLAN && ( IS_NPC( ch ) || !ch->pcdata->clan ) )
act_comm.c:            ch->speaking = lang_array[langs];
act_comm.c:      if( race_table[ch->race]->language & lang_array[lang] ||
act_comm.c:          lang_array[lang] == LANG_COMMON || ch->pcdata->learned[sn] >= 99 )
act_comm.c:      for( sch = ch->in_room->first_person; sch; sch = sch->next_in_room )
act_comm.c:         if( IS_NPC( sch ) && xIS_SET( sch->act, ACT_SCHOLAR )
act_comm.c:             && knows_language( sch, ch->speaking, ch )
act_comm.c:             && ( !sch->speaking || knows_language( ch, sch->speaking, sch ) ) )
act_comm.c:      if( countlangs( ch->speaks ) >= ( ch->level / 10 ) && ch->pcdata->learned[sn] <= 0 )
act_comm.c:      if( ch->practice < prac )
act_comm.c:      ch->practice -= prac;
act_comm.c:      ch->pcdata->learned[sn] += prct;
act_comm.c:      ch->pcdata->learned[sn] = UMIN( ch->pcdata->learned[sn], 99 );
act_comm.c:      SET_BIT( ch->speaks, lang_array[lang] );
act_comm.c:      if( ch->pcdata->learned[sn] == prct )
act_comm.c:      else if( ch->pcdata->learned[sn] < 60 )
act_comm.c:      else if( ch->pcdata->learned[sn] < 60 + prct )
act_comm.c:      else if( ch->pcdata->learned[sn] < 99 )
act_comm.c:         if( ch->speaking & lang_array[lang] || ( IS_NPC( ch ) && !ch->speaking ) )
act_info.c:   struct WeatherCell *cell = getWeatherCell( ch->in_room->area );
act_info.c:   if( ( IS_AFFECTED( ch, AFF_DETECT_EVIL ) || ch->Class == CLASS_PALADIN ) && IS_OBJ_STAT( obj, ITEM_EVIL ) )
act_info.c:   if( ch->Class == CLASS_PALADIN
act_info.c:   if( ch->Class == CLASS_PALADIN
act_info.c:   if( ch->Class == CLASS_PALADIN
act_info.c:   if( ch->Class == CLASS_PALADIN
act_info.c:   if( ch->Class == CLASS_PALADIN
act_info.c:   if( ch->Class == CLASS_PALADIN
act_info.c:   if( ( IS_AFFECTED( ch, AFF_DETECT_MAGIC ) || xIS_SET( ch->act, PLR_HOLYLIGHT ) ) && IS_OBJ_STAT( obj, ITEM_MAGIC ) )
act_info.c:   if( ( IS_AFFECTED( ch, AFF_DETECTTRAPS ) || xIS_SET( ch->act, PLR_HOLYLIGHT ) ) && is_trapped( obj ) )
act_info.c:      if( glowsee && ( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_HOLYLIGHT ) ) )
act_info.c:      if( glowsee && ( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_HOLYLIGHT ) ) )
act_info.c:   if( !ch->desc )
act_info.c:         if( IS_NPC( ch ) || xIS_SET( ch->act, PLR_COMBINE ) )
act_info.c:   ms = ( ch->mental_state ? ch->mental_state : 1 )
act_info.c:      * ( IS_NPC( ch ) ? 1 : ( ch->pcdata->condition[COND_DRUNK] ? ( ch->pcdata->condition[COND_DRUNK] / 12 ) : 1 ) );
act_info.c:         if( IS_NPC( ch ) || xIS_SET( ch->act, PLR_COMBINE ) )
act_info.c:         if( IS_NPC( ch ) || xIS_SET( ch->act, PLR_COMBINE ) )
act_info.c:/*	if ( IS_NPC(ch) || xIS_SET(ch->act, PLR_COMBINE) ) */
act_info.c:      if( IS_NPC( ch ) || xIS_SET( ch->act, PLR_COMBINE ) )
act_info.c:   if( IS_EVIL( victim ) && ( IS_AFFECTED( ch, AFF_DETECT_EVIL ) || ch->Class == CLASS_PALADIN ) )
act_info.c:   if( IS_NEUTRAL( victim ) && ch->Class == CLASS_PALADIN )
act_info.c:   if( IS_GOOD( victim ) && ch->Class == CLASS_PALADIN )
act_info.c:   if( IS_NPC( victim ) && ch->mount && ch->mount == victim && ch->in_room == ch->mount->in_room )
act_info.c:            if( !IS_NPC( victim ) && !xIS_SET( ch->act, PLR_BRIEF ) )
act_info.c:   if( !IS_NPC( victim ) && !xIS_SET( ch->act, PLR_BRIEF ) )
act_info.c:   if( can_see( victim, ch ) && !IS_NPC( ch ) && !xIS_SET( ch->act, PLR_WIZINVIS ) )
act_info.c:   else if( ch->pcdata->learned[gsn_peek] > 0 )
act_info.c:   for( rch = list; rch; rch = rch->next_in_room )
act_info.c:      else if( room_is_dark( ch->in_room ) && IS_AFFECTED( ch, AFF_INFRARED ) && !( !IS_NPC( rch ) && IS_IMMORTAL( rch ) ) )
act_info.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
act_info.c:   for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c:                    ch->in_room->name,
act_info.c:   if( IS_IMMORTAL( ch ) && xIS_SET( ch->act, PLR_ROOMVNUM ) )
act_info.c:      ch_printf_color( ch, "&w-<---- &YVnum: %6d &w----------------------------->-        ", ch->in_room->vnum );
act_info.c:   if( !xIS_SET( ch->act, PLR_BRIEF ) )
act_info.c:      if( ch->in_room->description && ch->in_room->description[0] != '\0' )
act_info.c:         mudstrlcat( rdesc, ch->in_room->description, MAX_STRING_LENGTH );
act_info.c:   if( !ch->desc )
act_info.c:   if( ch->position < POS_SLEEPING )
act_info.c:   if( ch->position == POS_SLEEPING )
act_info.c:       && !xIS_SET( ch->act, PLR_HOLYLIGHT ) && !IS_AFFECTED( ch, AFF_TRUESIGHT ) && room_is_dark( ch->in_room ) )
act_info.c:         show_char_to_char( ch->in_room->first_person, ch );
act_info.c:      if( xIS_SET( ch->act, PLR_COMPASS ) )
act_info.c:         send_to_char( ch->in_room->name, ch );
act_info.c:      if( arg1[0] == '\0' || ( !IS_NPC( ch ) && !xIS_SET( ch->act, PLR_BRIEF ) ) )
act_info.c:         if( xIS_SET( ch->act, PLR_AUTOMAP ) )
act_info.c:      if( !IS_NPC( ch ) && ( xIS_SET( ch->act, PLR_AUTOEXIT ) && !xIS_SET( ch->act, PLR_AUTOMAP ) ) )
act_info.c:      show_list_to_char( ch->in_room->first_content, ch, FALSE, FALSE );
act_info.c:      show_char_to_char( ch->in_room->first_person, ch );
act_info.c:      if( !IS_OUTSIDE( ch ) || NO_WEATHER_SECT( ch->in_room->sector_type ) )
act_info.c:      if( !CAN_WEAR( obj, ITEM_TAKE ) && ch->level < sysdata.level_getobjnotake )
act_info.c:      if( ch->carry_weight + obj->weight > can_carry_w( ch ) )
act_info.c:            for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c:                  original = ch->in_room;
act_info.c:   if( ( pdesc = get_extra_descr( arg1, ch->in_room->first_extradesc ) ) != NULL )
act_info.c:               || ch->Class == CLASS_THIEF || IS_SET( pexit->exit_info, EX_xLOOK ) || get_trust( ch ) >= LEVEL_IMMORTAL ) )
act_info.c:                  if( ch->Class == CLASS_THIEF )
act_info.c:         original = ch->in_room;
act_info.c:   for( cnt = 0, obj = ch->last_carrying; obj; obj = obj->prev_content )
act_info.c:   for( obj = ch->in_room->last_content; obj; obj = obj->prev_content )
act_info.c:   if( !ch->desc )
act_info.c:   if( ch->position < POS_SLEEPING )
act_info.c:   if( ch->position == POS_SLEEPING )
act_info.c:      if( xIS_SET( ch->act, PLR_BRIEF ) )
act_info.c:      xSET_BIT( ch->act, PLR_BRIEF );
act_info.c:         xREMOVE_BIT( ch->act, PLR_BRIEF );
act_info.c:       && !xIS_SET( ch->act, PLR_HOLYLIGHT )
act_info.c:       && !IS_AFFECTED( ch, AFF_TRUESIGHT ) && !IS_AFFECTED( ch, AFF_INFRARED ) && room_is_dark( ch->in_room ) )
act_info.c:   for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_info.c:      SET_BIT( ch->pcdata->flags, PCFLAG_HELPSTART );
act_info.c:   if( !ch->desc )
act_info.c:   switch ( ch->substate )
act_info.c:         if( ( pHelp = ( HELP_DATA * ) ch->dest_buf ) == NULL )
act_info.c:            bug( "%s", "hedit: sub_help_edit: NULL ch->dest_buf" );
act_info.c:   ch->substate = SUB_HELP_EDIT;
act_info.c:   ch->dest_buf = pHelp;
act_info.c:      if( !wch->leader || wch->leader == wch || !wch->leader->desc ||
act_info.c:          IS_NPC( wch->leader ) || IS_IMMORTAL( wch ) || IS_IMMORTAL( wch->leader ) )
act_info.c:         if( wch->leader && wch->leader != wch && wch->leader->desc &&
act_info.c:             !IS_NPC( wch->leader ) && !IS_IMMORTAL( wch ) &&
act_info.c:             !IS_IMMORTAL( wch->leader ) && ( whogr_t = find_whogr( wch->leader->desc, first_whogr ) ) )
act_info.c:      if( wch->level < iLevelLower || wch->level > iLevelUpper || ( fPkill && !CAN_PKILL( wch ) ) || ( fImmortalOnly && wch->level < LEVEL_IMMORTAL ) || ( fClassRestrict && !rgfClass[wch->Class] ) || ( fRaceRestrict && !rgfRace[wch->race] ) || ( fClanMatch && ( pClan != wch->pcdata->clan ) )  /* SB */
act_info.c:          || ( fCouncilMatch && ( pCouncil != wch->pcdata->council ) )  /* SB */
act_info.c:          || ( fDeityMatch && ( pDeity != wch->pcdata->deity ) ) )
act_info.c:      if( fLeader && !( wch->pcdata->council &&
act_info.c:                        ( ( wch->pcdata->council->head2 &&
act_info.c:                            !str_cmp( wch->pcdata->council->head2, wch->name ) ) ||
act_info.c:                          ( wch->pcdata->council->head &&
act_info.c:                            !str_cmp( wch->pcdata->council->head, wch->name ) ) ) ) &&
act_info.c:          !( wch->pcdata->clan && ( ( wch->pcdata->clan->deity &&
act_info.c:                                      !str_cmp( wch->pcdata->clan->deity, wch->name ) )
act_info.c:                                    || ( wch->pcdata->clan->leader
act_info.c:                                         && !str_cmp( wch->pcdata->clan->leader, wch->name ) )
act_info.c:                                    || ( wch->pcdata->clan->number1
act_info.c:                                         && !str_cmp( wch->pcdata->clan->number1, wch->name ) )
act_info.c:                                    || ( wch->pcdata->clan->number2
act_info.c:                                         && !str_cmp( wch->pcdata->clan->number2, wch->name ) ) ) ) )
act_info.c:      if( fGroup && !wch->leader && !IS_SET( wch->pcdata->flags, PCFLAG_GROUPWHO ) && ( !whogr_p || !whogr_p->indent ) )
act_info.c:      if( fShowHomepage && wch->pcdata->homepage && wch->pcdata->homepage[0] != '\0' )
act_info.c:         snprintf( char_name, MAX_INPUT_LENGTH, "<A HREF=\"%s\">%s</A>", show_tilde( wch->pcdata->homepage ), wch->name );
act_info.c:         mudstrlcpy( char_name, wch->name, MAX_INPUT_LENGTH );
act_info.c:      snprintf( class_text, MAX_INPUT_LENGTH, "%s%2d %s", NOT_AUTHED( wch ) ? "N" : " ", wch->level,
act_info.c:                class_table[wch->Class]->who_name );
act_info.c:      switch ( wch->level )
act_info.c:      if( !str_cmp( wch->name, sysdata.guild_overseer ) )
act_info.c:      else if( !str_cmp( wch->name, sysdata.guild_advisor ) )
act_info.c:      else if( wch->pcdata->clan
act_info.c:               && !str_cmp( wch->name, wch->pcdata->clan->leader ) && wch->pcdata->clan->leadrank[0] != '\0' )
act_info.c:         Class = wch->pcdata->clan->leadrank;
act_info.c:      else if( wch->pcdata->clan
act_info.c:               && !str_cmp( wch->name, wch->pcdata->clan->number1 ) && wch->pcdata->clan->onerank[0] != '\0' )
act_info.c:         Class = wch->pcdata->clan->onerank;
act_info.c:      else if( wch->pcdata->clan
act_info.c:               && !str_cmp( wch->name, wch->pcdata->clan->number2 ) && wch->pcdata->clan->tworank[0] != '\0' )
act_info.c:         Class = wch->pcdata->clan->tworank;
act_info.c:      else if( wch->pcdata->rank && wch->pcdata->rank[0] != '\0' )
act_info.c:         Class = wch->pcdata->rank;
act_info.c:      if( wch->pcdata->clan )
act_info.c:         CLAN_DATA *pclan = wch->pcdata->clan;
act_info.c:            if( !str_cmp( wch->name, pclan->deity ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->leader ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->number1 ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->number2 ) )
act_info.c:            if( !str_cmp( wch->name, pclan->leader ) )
act_info.c:            if( !str_cmp( wch->name, pclan->number1 ) )
act_info.c:            if( !str_cmp( wch->name, pclan->number2 ) )
act_info.c:            if( !str_cmp( wch->name, pclan->deity ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->leader ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->number1 ) )
act_info.c:            else if( !str_cmp( wch->name, pclan->number2 ) )
act_info.c:      if( wch->pcdata->council )
act_info.c:         if( wch->pcdata->council->head2 == NULL )
act_info.c:            if( !str_cmp( wch->name, wch->pcdata->council->head ) )
act_info.c:            if( !str_cmp( wch->name, wch->pcdata->council->head ) || !str_cmp( wch->name, wch->pcdata->council->head2 ) )
act_info.c:         mudstrlcat( council_name, wch->pcdata->council_name, MAX_INPUT_LENGTH );
act_info.c:      if( xIS_SET( wch->act, PLR_WIZINVIS ) )
act_info.c:         snprintf( invis_str, MAX_INPUT_LENGTH, "(%d) ", wch->pcdata->wizinvis );
act_info.c:                wch->pcdata->customclass,
act_info.c:                ( wch->desc && wch->desc->connected ) ? "[WRITING] " : "",
act_info.c:                xIS_SET( wch->act, PLR_AFK ) ? "[AFK] " : "",
act_info.c:                xIS_SET( wch->act, PLR_ATTACKER ) ? "(ATTACKER) " : "",
act_info.c:                xIS_SET( wch->act, PLR_KILLER ) ? "(KILLER) " : "",
act_info.c:                xIS_SET( wch->act, PLR_THIEF ) ? "(THIEF) " : "",
act_info.c:                char_name, wch->pcdata->title, extra_title, clan_name, council_name );
act_info.c:      if( wch->level > LEVEL_AVATAR && IS_IMMORTAL( wch ) )
act_info.c:         if( wch->leader || ( whogr_p && whogr_p->indent ) )
act_info.c:      for( obj2 = ch->first_carrying; obj2; obj2 = obj2->next_content )
act_info.c:      pager_printf( ch, "\r\nPlayers near you in %s:\r\n", ch->in_room->area->name );
act_info.c:             && ( ( victim->in_room->area == ch->in_room->area )
act_info.c:             && ( victim->in_room == ch->in_room
act_info.c:                  || ( !IS_SET( ch->in_room->area->flags, AFLAG_NOWHERE )
act_info.c:             && victim->in_room->area == ch->in_room->area
act_info.c:   diff = victim->level - ch->level;
act_info.c:   diff = ( int )( victim->max_hit - ch->max_hit ) / 6;
act_info.c:   for( mob = ch->in_room->first_person; mob; mob = mob->next_in_room )
act_info.c:   if( argument[0] == '\0' && ch->level > LEVEL_AVATAR)   
act_info.c:             && ( skill->guild != CLASS_NONE && ( !IS_GUILDED( ch ) || ( ch->pcdata->clan->Class != skill->guild ) ) ) )
act_info.c:            if( ch->level >= skill->skill_level[ch->Class] )
act_info.c:            if( ch->level >= skill->race_level[ch->race] )
act_info.c:         if( ch->pcdata->learned[sn] <= 0 && SPELL_FLAG( skill, SF_SECRETSKILL ) )
act_info.c:         if( ch->pcdata->learned[normalSn] > 0 )
act_info.c:         pager_printf( ch, " %3d%% ", ch->pcdata->learned[normalSn] );
act_info.c:      pager_printf( ch, "You have %d practice sessions left.\r\n", ch->practice );
act_info.c:      if( ch->practice <= 0 )
act_info.c:      if( can_prac && ( ( sn == -1 ) || ( !IS_NPC( ch ) && ch->level < skill_table[sn]->skill_level[ch->Class]
act_info.c:                                          && ch->level < skill_table[sn]->race_level[ch->race] ) ) )
act_info.c:	     && ch->pcdata->clan->class != skill_table[sn]->guild )
act_info.c:       if ( mob->level < skill_table[sn]->skill_level[ch->class]
act_info.c:      adept = ( int )( class_table[ch->Class]->skill_adept * 0.2 );
act_info.c:      if( ch->pcdata->learned[sn] >= adept )
act_info.c:         ch->practice--;
act_info.c:         ch->pcdata->learned[sn] += int_app[get_curr_int( ch )].learn;
act_info.c:         if( ch->pcdata->learned[sn] >= adept )
act_info.c:            ch->pcdata->learned[sn] = adept;
act_info.c:         wimpy = ( int )( ch->max_hit / 2.25 );
act_info.c:         wimpy = ( int )( ch->max_hit / 1.2 );
act_info.c:      wimpy = ( int )ch->max_hit / 5;
act_info.c:   if( IS_PKILL( ch ) && wimpy > ( int )ch->max_hit / 2.25 )
act_info.c:   else if( wimpy > ( int )ch->max_hit / 1.2 )
act_info.c:   ch->wimpy = wimpy;
act_info.c:   DISPOSE( ch->pcdata->pwd );
act_info.c:   ch->pcdata->pwd = str_dup( pwdnew );
act_info.c:   if( ch->desc && ch->desc->host[0] != '\0' )
act_info.c:      log_printf( "%s changing password from site %s\n", ch->name, ch->desc->host );
act_info.c:      log_printf( "%s changing thier password with no descriptor!", ch->name );
act_info.c:      if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_SILENCE ) )
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_RACETALK ) ? " &G+RACETALK" : " &g-racetalk" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_CHAT ) ? " &G+CHAT" : " &g-chat" );
act_info.c:         ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_AUCTION ) ? " &G+AUCTION" : " &g-auction" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_TRAFFIC ) ? " &G+TRAFFIC" : " &g-traffic" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_QUEST ) ? " &G+QUEST" : " &g-quest" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_WARTALK ) ? " &G+WARTALK" : " &g-wartalk" );
act_info.c:         ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_AVTALK ) ? " &G+AVATAR" : " &g-avatar" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_MUSIC ) ? " &G+MUSIC" : " &g-music" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_ASK ) ? " &G+ASK" : " &g-ask" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_SHOUT ) ? " &G+SHOUT" : " &g-shout" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_YELL ) ? " &G+YELL" : " &g-yell" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_TELLS ) ? " &G+TELLS" : " &g-tells" );
act_info.c:      ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_WHISPER ) ? " &G+WHISPER" : " &g-whisper" );
act_info.c:      if( !IS_NPC( ch ) && ch->pcdata->clan )
act_info.c:         if( ch->pcdata->clan->clan_type == CLAN_ORDER )
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_ORDER ) ? " &G+ORDER" : " &g-order", ch );
act_info.c:         else if( ch->pcdata->clan->clan_type == CLAN_GUILD )
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_GUILD ) ? " &G+GUILD" : " &g-guild", ch );
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_CLAN ) ? " &G+CLAN" : " &g-clan", ch );
act_info.c:      if( IS_IMMORTAL( ch ) || ( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, "Newbie Council" ) ) )
act_info.c:         ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_NEWBIE ) ? " &G+NEWBIE" : " &g-newbie" );
act_info.c:      if( !IS_NPC( ch ) && ch->pcdata->council )
act_info.c:         ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_COUNCIL ) ? " &G+COUNCIL" : " &g-council" );
act_info.c:      if( !IS_NPC( ch ) && IS_SET( ch->pcdata->flags, PCFLAG_RETIRED ) )
act_info.c:         ch_printf_color( ch, "%s", !IS_SET( ch->deaf, CHANNEL_RETIRED ) ? " &G+RETIRED" : " &g-retired" );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_IMMTALK ) ? " &G+IMMTALK" : " &g-immtalk", ch );
act_info.c:/*          send_to_char_color( !IS_SET( ch->deaf, CHANNEL_PRAY )       ?
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_HIGHGOD ) ? " &G+MUSE" : " &g-muse", ch );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_MONITOR ) ? " &G+MONITOR" : " &g-monitor", ch );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_DEATH ) ? " &G+DEATH" : " &g-death", ch );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_AUTH ) ? " &G+AUTH" : " &g-auth", ch );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_LOG ) ? " &G+LOG" : " &g-log", ch );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_BUILD ) ? " &G+BUILD" : " &g-build", ch );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_COMM ) ? " &G+COMM" : " &g-comm", ch );
act_info.c:         send_to_char_color( !IS_SET( ch->deaf, CHANNEL_WARN ) ? " &G+WARN" : " &g-warn", ch );
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_HIGH ) ? " &G+HIGH" : " &g-high", ch );
act_info.c:            send_to_char_color( !IS_SET( ch->deaf, CHANNEL_BUG ) ? " &G+BUG" : " &g-bug", ch );
act_info.c:      else if( !str_cmp( arg + 1, "clan" ) && !IS_NPC( ch ) && ch->pcdata->clan
act_info.c:               && ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD )
act_info.c:      else if( !str_cmp( arg + 1, "council" ) && !IS_NPC( ch ) && ch->pcdata->council )
act_info.c:      else if( !str_cmp( arg + 1, "guild" ) && !IS_NPC( ch ) && ch->pcdata->clan
act_info.c:               && ch->pcdata->clan->clan_type == CLAN_GUILD )
act_info.c:                                                  || ( ch->pcdata->council
act_info.c:                                                       && !str_cmp( ch->pcdata->council->name, "Newbie Council" ) ) ) )
act_info.c:      else if( !str_cmp( arg + 1, "order" ) && !IS_NPC( ch ) && ch->pcdata->clan
act_info.c:               && ch->pcdata->clan->clan_type == CLAN_ORDER )
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_RACETALK );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_AUCTION );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_CHAT );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_QUEST );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_WARTALK );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_PRAY );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_TRAFFIC );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_MUSIC );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_ASK );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_SHOUT );
act_info.c:         REMOVE_BIT( ch->deaf, CHANNEL_YELL );
act_info.c:          * if (ch->pcdata->clan)
act_info.c:          * REMOVE_BIT (ch->deaf, CHANNEL_CLAN);
act_info.c:          * if (ch->pcdata->council)
act_info.c:          * REMOVE_BIT (ch->deaf, CHANNEL_COUNCIL);
act_info.c:          * if (ch->pcdata->guild)
act_info.c:          * REMOVE_BIT (ch->deaf, CHANNEL_GUILD);
act_info.c:         if( ch->level >= LEVEL_IMMORTAL )
act_info.c:            REMOVE_BIT( ch->deaf, CHANNEL_AVTALK );
act_info.c:          * if (ch->level >= sysdata.log_level )
act_info.c:          * REMOVE_BIT (ch->deaf, CHANNEL_COMM);
act_info.c:         SET_BIT( ch->deaf, CHANNEL_RACETALK );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_AUCTION );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_TRAFFIC );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_CHAT );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_QUEST );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_PRAY );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_MUSIC );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_ASK );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_SHOUT );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_WARTALK );
act_info.c:         SET_BIT( ch->deaf, CHANNEL_YELL );
act_info.c:          * if (ch->pcdata->clan)
act_info.c:          * SET_BIT (ch->deaf, CHANNEL_CLAN);
act_info.c:          * if (ch->pcdata->council)
act_info.c:          * SET_BIT (ch->deaf, CHANNEL_COUNCIL);
act_info.c:          * SET_BIT (ch->deaf, CHANNEL_GUILD);
act_info.c:         if( ch->level >= LEVEL_IMMORTAL )
act_info.c:            SET_BIT( ch->deaf, CHANNEL_AVTALK );
act_info.c:          * if (ch->level >= sysdata.log_level)
act_info.c:          * SET_BIT (ch->deaf, CHANNEL_COMM);
act_info.c:         REMOVE_BIT( ch->deaf, bit );
act_info.c:         SET_BIT( ch->deaf, bit );
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) ? "[+] PAGER"
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_GAG ) ? "[+] GAG"
act_info.c:                 xIS_SET( ch->act, PLR_BRIEF ) ? "[+] BRIEF"
act_info.c:                 xIS_SET( ch->act, PLR_COMBINE ) ? "[+] COMBINE"
act_info.c:                 xIS_SET( ch->act, PLR_BLANK ) ? "[+] BLANK"
act_info.c:                 xIS_SET( ch->act, PLR_PROMPT ) ? "[+] PROMPT"
act_info.c:                 xIS_SET( ch->act, PLR_ANSI ) ? "[+] ANSI"
act_info.c:                 xIS_SET( ch->act, PLR_RIP ) ? "[+] RIP"
act_info.c:                 xIS_SET( ch->act, PLR_COMPASS ) ? "[+] COMPASS"
act_info.c:                 : "[-] compass", xIS_SET( ch->act, PLR_AUTOMAP ) ? "[+] AUTOMAP" : "[-] automap" );
act_info.c:                 xIS_SET( ch->act, PLR_AUTOSAC ) ? "[+] AUTOSAC"
act_info.c:                 xIS_SET( ch->act, PLR_AUTOGOLD ) ? "[+] AUTOGOLD"
act_info.c:                 xIS_SET( ch->act, PLR_AUTOLOOT ) ? "[+] AUTOLOOT"
act_info.c:                 : "[-] autoloot", xIS_SET( ch->act, PLR_AUTOEXIT ) ? "[+] AUTOEXIT" : "[-] autoexit" );
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_NORECALL ) ? "[+] NORECALL"
act_info.c:                 : "[-] norecall", IS_SET( ch->pcdata->flags, PCFLAG_NOSUMMON ) ? "[+] NOSUMMON" : "[-] nosummon" );
act_info.c:      if( !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
act_info.c:                    xIS_SET( ch->act, PLR_SHOVEDRAG ) ? "[+] DRAG"
act_info.c:                    : "[-] drag", xIS_SET( ch->act, PLR_NICE ) ? "[+] NICE" : "[-] nice" );
act_info.c:                 xIS_SET( ch->act, PLR_TELNET_GA ) ? "[+] TELNETGA" : "[-] telnetga",
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_GROUPWHO ) ? "[+] GROUPWHO" : "[-] groupwho",
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO ) ? "[+] NOINTRO" : "[-] nointro",
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_BECKON ) ? "[+] BECKON" : "[-] beckon" );
act_info.c:      ch_printf_color( ch, "Pager Length (%d)    Wimpy (&W%d&w)", ch->pcdata->pagerlen, ch->wimpy );
act_info.c:         ch_printf( ch, "Roomvnum [%s]", xIS_SET( ch->act, PLR_ROOMVNUM ) ? "+" : " " );
act_info.c:                 xIS_SET( ch->act, PLR_SILENCE ) ?
act_info.c:                 xIS_SET( ch->act, PLR_NO_EMOTE ) ?
act_info.c:                 xIS_SET( ch->act, PLR_NO_TELL ) ?
act_info.c:                 xIS_SET( ch->act, PLR_LITTERBUG ) ?
act_info.c:                 xIS_SET( ch->act, PLR_THIEF ) ?
act_info.c:                 xIS_SET( ch->act, PLR_KILLER ) ?
act_info.c:                 IS_SET( ch->pcdata->flags, PCFLAG_NODESC ) ? " You are not permitted to set your description.\r\n" : "" );
act_info.c:         if( ( bit == PLR_FLEE || bit == PLR_NICE || bit == PLR_SHOVEDRAG ) && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
act_info.c:            xSET_BIT( ch->act, bit );
act_info.c:            xREMOVE_BIT( ch->act, bit );
act_info.c:            SET_BIT( ch->pcdata->flags, bit );
act_info.c:            REMOVE_BIT( ch->pcdata->flags, bit );
act_info.c:   if( xIS_SET( ch->act, PLR_AFK ) )
act_info.c:      xREMOVE_BIT( ch->act, PLR_AFK );
act_info.c:      xSET_BIT( ch->act, PLR_AFK );
act_info.c:         if( ch->pcdata->learned[normalSn] <= 0 && SPELL_FLAG( skill, SF_SECRETSKILL ) )
act_info.c:         if( i == skill->skill_level[ch->Class] || i == skill->race_level[ch->race] )
act_info.c:                          skn, skill->name, ch->pcdata->learned[normalSn], skill->skill_adept[ch->Class], buf );
act_info.c:      if( IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) )
act_info.c:         ch_printf( ch, "Pager is now enabled at %d lines.\r\n", ch->pcdata->pagerlen );
act_info.c:   ch->pcdata->pagerlen = atoi( arg );
act_info.c:   if( ch->pcdata->pagerlen < 5 )
act_info.c:      ch->pcdata->pagerlen = 5;
act_info.c:   ch_printf( ch, "Page pausing set to %d lines.\r\n", ch->pcdata->pagerlen );
act_info.c:      if( !ch->pcdata->first_ignored )
act_info.c:      for( temp = ch->pcdata->first_ignored; temp; temp = temp->next )
act_info.c:      for( temp = ch->pcdata->first_ignored; temp; temp = next )
act_info.c:         UNLINK( temp, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
act_info.c:   else if( !strcmp( arg, "self" ) || nifty_is_name( arg, ch->name ) )
act_info.c:         if( !ch->reply )
act_info.c:            mudstrlcpy( arg, ch->reply->name, MAX_INPUT_LENGTH );
act_info.c:      for( temp = ch->pcdata->first_ignored, i = 0; temp; temp = temp->next, i++ )
act_info.c:            UNLINK( temp, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
act_info.c:         LINK( inew, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
act_info.c:   for( temp = ch->pcdata->first_ignored; temp; temp = temp->next )
act_info.c:      if( nifty_is_name( temp->name, ign_ch->name ) )
act_move.c:   cur = ch->carry_weight;
act_move.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_NOFLOOR )
act_move.c:       && ( !IS_AFFECTED( ch, AFF_FLYING ) || ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLYING ) ) ) )
act_move.c:         bug( "Falling (in a loop?) more than 80 rooms: vnum %d", ch->in_room->vnum );
act_move.c:      move_char( ch, get_exit( ch->in_room, DIR_DOWN ), ++fall );
act_move.c: if( ch->pcdata->cpose )
act_move.c:      ch->pcdata->cpose = str_dup( " is here." );
act_move.c:      if( IS_DRUNK( ch, 2 ) && ( ch->position != POS_SHOVE ) && ( ch->position != POS_DRAG ) )
act_move.c:      if( ch->pcdata->nuisance && ch->pcdata->nuisance->flags > 8 &&
act_move.c:          ( ch->position != POS_SHOVE ) && ( ch->position != POS_DRAG ) &&
act_move.c:          number_percent(  ) > ( ch->pcdata->nuisance->flags * ch->pcdata->nuisance->power ) )
act_move.c:      pexit = get_exit( ch->in_room, door );
act_move.c:      log_printf( "move_char: %s to door %d", ch->name, pexit->vdir );
act_move.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_MOUNTED ) )
act_move.c:   in_room = ch->in_room;
act_move.c:      if( drunk && ch->position != POS_MOUNTED
act_move.c:          && ch->in_room->sector_type != SECT_WATER_SWIM
act_move.c:          && ch->in_room->sector_type != SECT_WATER_NOSWIM
act_move.c:          && ch->in_room->sector_type != SECT_UNDERWATER && ch->in_room->sector_type != SECT_OCEANFLOOR )
act_move.c:               ch->position = POS_RESTING;
act_move.c:               ch->position = POS_INCAP;
act_move.c:   if( IS_SET( pexit->exit_info, EX_NOMOB ) && IS_NPC( ch ) && !xIS_SET( ch->act, ACT_PET ) )
act_move.c:   if( !fall && IS_AFFECTED( ch, AFF_CHARM ) && ch->master && in_room == ch->master->in_room )
act_move.c:   if( IS_NPC(ch) && xIS_SET( to_room->room_flags, ROOM_NO_MOB ) && !xIS_SET( ch->act, ACT_PET ) )
act_move.c:   if( !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && ch->in_room->area != to_room->area )
act_move.c:      if( ch->level < to_room->area->low_hard_range )
act_move.c:         switch ( to_room->area->low_hard_range - ch->level )
act_move.c:      else if( ch->level > to_room->area->hi_hard_range )
act_move.c:          && !IS_SET( ch->in_room->area->flags, AFLAG_NOPKILL ) && ( IS_PKILL( ch ) && !IS_IMMORTAL( ch ) ) )
act_move.c:         if( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:         if( !ch->mount && !IS_AFFECTED( ch, AFF_FLYING ) )
act_move.c:         if( ( ch->mount && !IS_FLOATING( ch->mount ) ) || !IS_FLOATING( ch ) )
act_move.c:               if( ch->mount )
act_move.c:         if( ch->mount && IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:         if( !found && !ch->mount )
act_move.c:            if( ( !IS_NPC( ch ) && number_percent(  ) > LEARNED( ch, gsn_climb ) ) || drunk || ch->mental_state < -90 )
act_move.c:      if( ch->mount )
act_move.c:         switch ( ch->mount->position )
act_move.c:         if( !IS_FLOATING( ch->mount ) )
act_move.c:         if( ch->mount->move < move )
act_move.c:         if( ch->move < move )
act_move.c:      if( ch->mount )
act_move.c:         ch->mount->move -= move;
act_move.c:         ch->move -= move;
act_move.c:      int count = ch->mount ? 1 : 0;
act_move.c:            if( ch->mount && count == to_room->tunnel )
act_move.c:   if( !IS_AFFECTED( ch, AFF_SNEAK ) && ( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_WIZINVIS ) ) )
act_move.c:         if( ch->mount )
act_move.c:            if( IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:            else if( IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:            else if( ch->position == POS_SHOVE )
act_move.c:            else if( ch->position == POS_DRAG )
act_move.c:      if( ch->mount )
act_move.c:         act( AT_ACTION, buf, ch, NULL, ch->mount, TO_NOTVICT );
act_move.c:   if( ch->mount )
act_move.c:      rprog_leave_trigger( ch->mount );
act_move.c:      if( char_died( ch->mount ) )
act_move.c:      if( ch->mount )
act_move.c:         char_from_room( ch->mount );
act_move.c:         char_to_room( ch->mount, to_room );
act_move.c:   if( !IS_AFFECTED( ch, AFF_SNEAK ) && ( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_WIZINVIS ) ) )
act_move.c:      else if( ch->mount )
act_move.c:         if( IS_AFFECTED( ch->mount, AFF_FLOATING ) )
act_move.c:         else if( IS_AFFECTED( ch->mount, AFF_FLYING ) )
act_move.c:         else if( ch->position == POS_SHOVE )
act_move.c:         else if( ch->position == POS_DRAG )
act_move.c:      if( ch->mount )
act_move.c:         act( AT_ACTION, buf, ch, NULL, ch->mount, TO_ROOM );
act_move.c:   if( !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && ch->in_room->area != to_room->area )
act_move.c:      if( ch->level < to_room->area->low_soft_range )
act_move.c:      else if( ch->level > to_room->area->hi_soft_range )
act_move.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_DEATH ) && !IS_IMMORTAL( ch ) )
act_move.c:      if( xIS_SET( ch->act, PLR_BRIEF ) )
act_move.c:      xREMOVE_BIT( ch->act, PLR_BRIEF );
act_move.c:      xSET_BIT( ch->act, PLR_BRIEF );
act_move.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_DEATH ) && !IS_IMMORTAL( ch ) )
act_move.c:      snprintf( buf, MAX_STRING_LENGTH, "%s hit a DEATH TRAP in room %d!", ch->name, ch->in_room->vnum );
act_move.c:      for( fch = from_room->first_person; fch; fch = fch->next_in_room )
act_move.c:         nextinroom = fch->next_in_room;
act_move.c:             && fch->master == ch && fch->position == POS_STANDING )
act_move.c:   if( ch->in_room->first_content )
act_move.c:      if( !IS_AFFECTED( ch, AFF_FLOATING ) || ( ch->mount && !IS_AFFECTED( ch->mount, AFF_FLOATING ) ) )
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_NORTH ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_EAST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_SOUTH ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_WEST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_UP ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_DOWN ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_NORTHEAST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_NORTHWEST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_SOUTHEAST ), 0 );
act_move.c:   move_char( ch, get_exit( ch->in_room, DIR_SOUTHWEST ), 0 );
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:   if( ( pexit = get_exit( ch->in_room, door ) ) == NULL )
act_move.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c:            for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:      if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c:         for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
act_move.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_bashdoor]->skill_level[ch->Class] )
act_move.c:   if( ch->fighting )
act_move.c:          && ch->move >= 15 && number_percent(  ) < ( schance + 4 * ( get_curr_str( ch ) - 19 ) ) )
act_move.c:             && ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
act_move.c:            for( rch = to_room->first_person; rch; rch = rch->next_in_room )
act_move.c:         damage( ch, ch, ( ch->max_hit / 20 ), gsn_bashdoor );
act_move.c:         damage( ch, ch, ( ch->max_hit / 20 ) + 10, gsn_bashdoor );
act_move.c:      damage( ch, ch, ( ch->max_hit / 20 ) + 10, gsn_bashdoor );
act_move.c:   switch ( ch->position )
act_move.c:         ch->position = POS_STANDING;
act_move.c:         ch->position = POS_STANDING;
act_move.c:         ch->position = POS_STANDING;
act_move.c:   switch ( ch->position )
act_move.c:         ch->position = POS_SITTING;
act_move.c:         ch->position = POS_SITTING;
act_move.c:         ch->position = POS_SITTING;
act_move.c:   switch ( ch->position )
act_move.c:         ch->position = POS_RESTING;
act_move.c:         ch->position = POS_RESTING;
act_move.c:         ch->position = POS_RESTING;
act_move.c:   switch ( ch->position )
act_move.c:         if( ch->mental_state > 30 && ( number_percent(  ) + 10 ) < ch->mental_state )
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:         if( ch->mental_state > 30 && ( number_percent(  ) + 5 ) < ch->mental_state )
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:         if( ch->mental_state > 30 && number_percent(  ) < ch->mental_state )
act_move.c:         ch->position = POS_SLEEPING;
act_move.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_DEATH ) && !IS_IMMORTAL( ch ) )
act_move.c:      snprintf( buf, MAX_STRING_LENGTH, "%s hit a DEATH TRAP in room %d!", ch->name, ch->in_room->vnum );
act_move.c:   ROOM_INDEX_DATA *start = ch->in_room, *dest;
act_move.c:      nch_next = nch->next_in_room;
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:      if( ch->in_room->sector_type != SECT_INSIDE && IS_OUTSIDE( ch ) )
act_move.c:         for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:      for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:      if( ch->in_room->sector_type == SECT_INSIDE || !IS_OUTSIDE( ch ) )
act_move.c:         for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
act_move.c:   if( ( room = ch->in_room ) == NULL )
act_move.c:      bug( "%s: %s not in a room?!?", __func__, ch->name );
act_move.c:      int count = ch->mount ? 1 : 0;
act_move.c:               if( ( ch->mount && !IS_FLOATING( ch->mount ) ) || ( !ch->mount && !IS_FLOATING( ch ) ) )
act_move.c:         if( ( ch->mount && !IS_FLOATING( ch->mount ) ) || ( !ch->mount && !IS_FLOATING( ch ) ) )
act_move.c:      if( ch->mount )
act_move.c:         char_from_room( ch->mount );
act_move.c:         char_to_room( ch->mount, xit->to_room );
act_move.c:            do_look( ch->mount, "auto" );
act_obj.c:   if( !CAN_WEAR( obj, ITEM_TAKE ) && ( ch->level < sysdata.level_getobjnotake ) )
act_obj.c:         if( !is_name( ch->name, obj->action_desc ) && !IS_IMMORTAL( ch ) )
act_obj.c:   if( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:            if( ( ch->carry_weight + weight ) > can_carry_w( ch ) )
act_obj.c:      else if( ( ch->carry_weight + weight ) > can_carry_w( ch ) )
act_obj.c:      if( IS_OBJ_STAT( container, ITEM_CLANCORPSE ) && !IS_NPC( ch ) && str_cmp( container->name + 7, ch->name ) )
act_obj.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_obj.c:      save_house_by_vnum( ch->in_room->vnum ); /* House Object Saving */
act_obj.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) && ( !container || container->carried_by == NULL ) )
act_obj.c:         if( vault->vnum == ch->in_room->vnum )
act_obj.c:      ch->gold += amt;
act_obj.c:      new_ob = create_object( get_obj_index( first_ob->value[2] ), ch->level );
act_obj.c:   if( ch->carry_number < 0 || ch->carry_weight < 0 )
act_obj.c:      log_printf( "%s has negative carry_number or carry_weight!", ch->name );
act_obj.c:      if( ( ch->carry_number + number ) > can_carry_n( ch ) )
act_obj.c:         obj = get_obj_list( ch, arg1, ch->in_room->first_content );
act_obj.c:         if( xIS_SET( ch->in_room->room_flags, ROOM_DONATION ) )
act_obj.c:         for( obj = ch->in_room->last_content; obj; obj = obj_next )
act_obj.c:                   || ch->carry_number >= can_carry_n( ch )
act_obj.c:                   || ch->carry_weight >= can_carry_w( ch ) || ( number && cnt >= number ) )
act_obj.c:            if( ch->carry_weight + container->weight > can_carry_w( ch ) )
act_obj.c:                && !IS_NPC( ch ) && ( get_timer( ch, TIMER_PKILLED ) > 0 ) && str_cmp( name, ch->name ) )
act_obj.c:                && str_cmp( name, ch->name ) && str_cmp( container->action_desc, ch->name ) )
act_obj.c:                && !IS_NPC( ch ) && str_cmp( name, ch->name ) && container->value[5] >= 3 )
act_obj.c:                && !IS_NPC( ch ) && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY )
act_obj.c:                && container->value[4] - ch->level < 6 && container->value[4] - ch->level > -6 )
act_obj.c:            if( !str_cmp( name, ch->name ) && !IS_IMMORTAL( ch ) )
act_obj.c:               for( gch = first_char; gch; gch = gch->next )
act_obj.c:                  if( !IS_NPC( gch ) && is_same_group( ch, gch ) && !str_cmp( name, gch->name ) )
act_obj.c:             && !IS_IMMORTAL( ch ) && !IS_NPC( ch ) && str_cmp( ch->name, container->name + 7 ) )
act_obj.c:                   || ch->carry_number >= can_carry_n( ch )
act_obj.c:                   || ch->carry_weight >= can_carry_w( ch ) || ( number && cnt >= number ) )
act_obj.c:      if( ch->carry_weight + container->weight > can_carry_w( ch ) )
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_obj.c:         save_house_by_vnum( ch->in_room->vnum ); /* House Object Saving */
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) && container->carried_by == NULL )
act_obj.c:            if( vault->vnum == ch->in_room->vnum )
act_obj.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_obj.c:         save_house_by_vnum( ch->in_room->vnum ); /* House Object Saving */
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) && container->carried_by == NULL )
act_obj.c:            if( vault->vnum == ch->in_room->vnum )
act_obj.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_LITTERBUG ) )
act_obj.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_NODROP ) && ch != supermob )
act_obj.c:         if( ch->gold < number )
act_obj.c:         ch->gold -= number;
act_obj.c:         for( obj = ch->in_room->first_content; obj; obj = obj_next )
act_obj.c:         obj_to_room( create_money( number ), ch->in_room );
act_obj.c:      if( ch->in_room->max_weight > 0
act_obj.c:         && ch->in_room->max_weight < get_real_obj_weight( obj ) / obj->count + ch->in_room->weight )
act_obj.c:      obj = obj_to_room( obj, ch->in_room );
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_obj.c:         save_house_by_vnum( ch->in_room->vnum ); /* House Object Saving */
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:            if( vault->vnum == ch->in_room->vnum )
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_NODROPALL ) || xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:            && ( !ch->in_room->max_weight || ch->in_room->max_weight > get_real_obj_weight( obj ) / obj->count + ch->in_room->weight ) )
act_obj.c:                  obj_next = ch->first_carrying;
act_obj.c:            obj = obj_to_room( obj, ch->in_room );
act_obj.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_obj.c:      save_house_by_vnum( ch->in_room->vnum ); /* House Object Saving */
act_obj.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:         if( vault->vnum == ch->in_room->vnum )
act_obj.c:      if( ch->gold < amount )
act_obj.c:      ch->gold -= amount;
act_obj.c:   if( !IS_NPC( ch ) && ( !IS_PKILL( ch ) || ( IS_PKILL( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) ) ) )
act_obj.c:            ch->armor += apply_ac( obj, obj->wear_loc );
act_obj.c:               ch->armor -= apply_ac( obj, obj->wear_loc );
act_obj.c:            ch->armor -= apply_ac( obj, obj->wear_loc );
act_obj.c:    	log_printf( "%s scrapped %s (vnum: %d)", ch->name, obj->short_descr, obj->pIndexData->vnum );
act_obj.c:   if( !fReplace && ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:   if( IS_NPC( ch ) || ch->pcdata->learned[gsn_dual_wield] )
act_obj.c:   for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
act_obj.c:       && ( ( IS_OBJ_STAT( obj, ITEM_ANTI_WARRIOR ) && ch->Class == CLASS_WARRIOR )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_WARRIOR ) && ch->Class == CLASS_SAVAGE )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_WARRIOR ) && ch->Class == CLASS_PALADIN )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_MAGE ) && ch->Class == CLASS_MAGE )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_MAGE ) && ch->Class == CLASS_NEPHANDI )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_THIEF ) && ch->Class == CLASS_THIEF )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_VAMPIRE ) && ch->Class == CLASS_VAMPIRE )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_DRUID ) && ch->Class == CLASS_DRUID )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_WARRIOR ) && ch->Class == CLASS_RANGER )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_MAGE ) && ch->Class == CLASS_AUGURER )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_CLERIC ) && ch->Class == CLASS_CLERIC )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_GOOD ) && ch->alignment > 350 )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_NEUTRAL ) && ch->alignment >= -350 && ch->alignment <= 350 )
act_obj.c:            || ( IS_OBJ_STAT( obj, ITEM_ANTI_EVIL ) && ch->alignment < -350 ) ) )
act_obj.c:   if( IS_OBJ_STAT( obj, ITEM_PERSONAL ) && str_cmp( ch->name, obj->owner ) )
act_obj.c:      obj_to_room( obj, ch->in_room );
act_obj.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
act_obj.c:      for( obj = ch->first_carrying; obj != NULL; obj = obj_next )
act_obj.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
act_obj.c:   obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
act_obj.c:   switch( ch->in_room->sector_type )
act_obj.c:   if( move > ch->move )
act_obj.c:   ch->move -= move;
act_obj.c:   if( arg[0] == '\0' || !str_cmp( arg, ch->name ) )
act_obj.c:   obj = get_obj_list_rev( ch, arg, ch->in_room->last_content );
act_obj.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_obj.c:         if( ch->level - obj->value[5] > 5 || obj->value[5] - ch->level > 5 )
act_obj.c:   if( !IS_NPC( ch ) && ch->pcdata->deity && ch->pcdata->deity->name[0] != '\0' )
act_obj.c:      mudstrlcpy( name, ch->pcdata->deity->name, 50 );
act_obj.c:   else if( !IS_NPC( ch ) && ch->pcdata->clan && ch->pcdata->clan->deity[0] != '\0' )
act_obj.c:      mudstrlcpy( name, ch->pcdata->clan->deity, 50 );
act_obj.c:   ch->gold += 1;
act_obj.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_obj.c:         save_house_by_vnum( ch->in_room->vnum ); /* Prevent House Object Duplication */
act_obj.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_obj.c:      save_house_by_vnum( ch->in_room->vnum ); /* Prevent House Object Duplication */
act_obj.c:      for( vch = ch->in_room->first_person; vch; vch = vch_next )
act_obj.c:         vch_next = vch->next_in_room;
act_obj.c:         if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
act_obj.c:   if( arg[0] == '\0' && !ch->fighting )
act_obj.c:      if( ch->fighting )
act_obj.c:   if( ch->level < 3 )
act_obj.c:         if( ch->level < auction->item->level )
act_obj.c:         if( newbet > ch->gold )
act_obj.c:         ch->gold -= newbet;  /* substract the gold - important :) */
act_obj.c:            for( rch = obj->in_room->first_person; rch; rch = rch->next_in_room, chcnt++ )
act_obj.c:            if( IS_NPC( vch ) && xIS_SET( vch->act, ACT_HARDHAT ) )
act_obj.c:               damage( vch, vch, dam * vch->level, TYPE_UNDEFINED );
act_obj.c:   obj = recursive_note_find( ch->first_carrying, argument );
act_wiz.c:   if( !IS_NPC( ch ) && ch->pcdata )
act_wiz.c:      if( IS_SET( ch->pcdata->flags, PCFLAG_DND ) )
act_wiz.c:         REMOVE_BIT( ch->pcdata->flags, PCFLAG_DND );
act_wiz.c:         SET_BIT( ch->pcdata->flags, PCFLAG_DND );
act_wiz.c:      if( ch->level >= LEVEL_IMPLEMENTOR )
act_wiz.c:      snprintf( fname, 256, "%s%s", WATCH_DIR, strlower( ch->name ) );
act_wiz.c:      snprintf( fname, 256, "%s%s", WATCH_DIR, strlower( ch->name ) );
act_wiz.c:      snprintf( fname, 256, "%s%s", WATCH_DIR, strlower( ch->name ) );
act_wiz.c:   if( ch->level >= LEVEL_IMPLEMENTOR && !str_cmp( arg, "show" ) && !str_cmp( arg2, "all" ) )
act_wiz.c:            if( !str_cmp( ch->name, pw->imm_name ) )
act_wiz.c:            if( !str_cmp( ch->name, pw->imm_name ) )
act_wiz.c:            if( !str_cmp( ch->name, pw->imm_name ) && pw->target_name && !str_cmp( arg2, pw->target_name ) )
act_wiz.c:      pinsert->imm_name = str_dup( strlower( ch->name ) );
act_wiz.c:            if( !str_cmp( ch->name, pw->imm_name ) && pw->player_site && !str_cmp( arg2, pw->player_site ) )
act_wiz.c:      pinsert->imm_name = str_dup( strlower( ch->name ) );
act_wiz.c:         if( !str_cmp( ch->name, pw->imm_name ) && pw->target_name && !str_cmp( arg2, pw->target_name ) )
act_wiz.c:      pinsert->imm_name = str_dup( strlower( ch->name ) );
act_wiz.c:      log_printf( "%s restricting %s to level %d", ch->name, cmd->name, level );
act_wiz.c:      victim->pcdata->authed_by = QUICKLINK( ch->name );
act_wiz.c:      DISPOSE( ch->pcdata->bamfin );
act_wiz.c:      ch->pcdata->bamfin = newbamf;
act_wiz.c:      DISPOSE( ch->pcdata->bamfout );
act_wiz.c:      ch->pcdata->bamfout = newbamf;
act_wiz.c:   DISPOSE( ch->pcdata->rank );
act_wiz.c:      ch->pcdata->rank = str_dup( "" );
act_wiz.c:      ch->pcdata->rank = newrank;
act_wiz.c:      ch_printf( victim, "%s brings you back from retirement.\r\n", ch->name );
act_wiz.c:      ch_printf( victim, "Courtesy of %s, you are now a retired immortal.\r\n", ch->name );
act_wiz.c:      vch_next = vch->next;
act_wiz.c:      if( vch->in_room->area == ch->in_room->area )
act_wiz.c:   if( xIS_SET( ch->act, PLR_NO_EMOTE ) )
act_wiz.c:   if( xIS_SET( ch->act, PLR_NO_EMOTE ) )
act_wiz.c:      echo_to_room( color, ch->in_room, argument );
act_wiz.c:      echo_to_room( AT_IMMORT, ch->in_room, argument );
act_wiz.c:      location = ch->in_room;
act_wiz.c:      ch_printf( victim, "Your DND flag just foiled %s's transfer command.\r\n", ch->name );
act_wiz.c:   snprintf( buf, MAX_STRING_LENGTH, "%d", ch->regoto );
act_wiz.c:   else if( ( wch = get_char_world( ch, arg ) ) == NULL || wch->in_room == NULL )
act_wiz.c:      location = wch->in_room;
act_wiz.c:   if( wch && !IS_NPC( wch ) && IS_SET( wch->pcdata->flags, PCFLAG_DND ) && get_trust( ch ) < get_trust( wch ) )
act_wiz.c:      ch_printf( ch, "Sorry. %s does not wish to be disturbed.\r\n", wch->name );
act_wiz.c:      ch_printf( wch, "Your DND flag just foiled %s's at command.\r\n", ch->name );
act_wiz.c:      ch_printf( victim, "Your DND flag just foiled %s's atmob command\r\n", ch->name );
act_wiz.c:   original = ch->in_room;
act_wiz.c:      ch_printf( victim, "Your DND flag just foiled %s's atobj command\r\n", ch->name );
act_wiz.c:   original = ch->in_room;
act_wiz.c:   original = ch->in_room;
act_wiz.c:      location = ch->in_room;
act_wiz.c:   location = ( arg[0] == '\0' ) ? ch->in_room : find_location( ch, arg );
act_wiz.c:   if( ch->in_room != location && room_is_private( location ) )
act_wiz.c:   switch ( ch->in_room->sector_type )
act_wiz.c:   if( !ch->in_room->first_permaffect )
act_wiz.c:   for( rch = location->first_person; rch; rch = rch->next_in_room )
act_wiz.c:         one_argument( rch->name, buf );
act_wiz.c:   snprintf( buf, MAX_STRING_LENGTH, "Reboot by %s.", ch->name );
act_wiz.c:      for( vch = first_char; vch; vch = vch->next )
act_wiz.c:   snprintf( buf, MAX_STRING_LENGTH, "Shutdown by %s.", ch->name );
act_wiz.c:      for( vch = first_char; vch; vch = vch->next )
act_wiz.c:         if( d->snoop_by == ch->desc )
act_wiz.c:   if( ch->desc )
act_wiz.c:      for( d = ch->desc->snoop_by; d; d = d->snoop_by )
act_wiz.c:   victim->desc->snoop_by = ch->desc;
act_wiz.c:   if( !ch->desc )
act_wiz.c:   if( ch->desc->original )
act_wiz.c:   if( !IS_NPC( victim ) && ch->level < LEVEL_GREATER )
act_wiz.c:   ch->desc->character = victim;
act_wiz.c:   ch->desc->original = ch;
act_wiz.c:   victim->desc = ch->desc;
act_wiz.c:   ch->desc = NULL;
act_wiz.c:   ch->switched = victim;
act_wiz.c:   if( !ch->desc )
act_wiz.c:   if( !ch->desc->original )
act_wiz.c:      xREMOVE_BIT( ch->affected_by, AFF_POSSESS );
act_wiz.c:   ch->desc->character = ch->desc->original;
act_wiz.c:   ch->desc->original = NULL;
act_wiz.c:   ch->desc->character->desc = ch->desc;
act_wiz.c:   ch->desc->character->switched = NULL;
act_wiz.c:   ch->desc = NULL;
act_wiz.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
act_wiz.c:   char_to_room( victim, ch->in_room );
act_wiz.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
act_wiz.c:         level = ch->level;
act_wiz.c:      obj = obj_to_room( obj, ch->in_room );
act_wiz.c:      for( victim = ch->in_room->first_person; victim; victim = vnext )
act_wiz.c:      for( obj = ch->in_room->first_content; obj; obj = obj_next )
act_wiz.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_wiz.c:         save_house_by_vnum( ch->in_room->vnum ); /* Prevent House Object Duplication */
act_wiz.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_wiz.c:            if( vault->vnum == ch->in_room->vnum )
act_wiz.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_wiz.c:         save_house_by_vnum( ch->in_room->vnum ); /* Prevent House Object Duplication */
act_wiz.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_wiz.c:            if( vault->vnum == ch->in_room->vnum )
act_wiz.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
act_wiz.c:         save_house_by_vnum( ch->in_room->vnum ); /* Prevent House Object Duplication */
act_wiz.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
act_wiz.c:            if( vault->vnum == ch->in_room->vnum )
act_wiz.c:      snprintf( buf2, MAX_STRING_LENGTH, "%s balzhuring %s", ch->name, buf );
act_wiz.c:            snprintf( buf2, MAX_STRING_LENGTH, "%s destroying %s", ch->name, buf );
act_wiz.c:      if( !ch->pcdata )
act_wiz.c:      ch->pcdata->restore_time = current_time;
act_wiz.c:         vch_next = vch->next;
act_wiz.c:            if( deity && vch->pcdata->deity != deity )
act_wiz.c:               vch->hit = ( short )( vch->max_hit * 1.5 );
act_wiz.c:               vch->hit = vch->max_hit;
act_wiz.c:            vch->mana = vch->max_mana;
act_wiz.c:            vch->move = vch->max_move;
act_wiz.c:            vch->pcdata->condition[COND_BLOODTHIRST] = ( 10 + vch->level );
act_wiz.c:   if( !ch->pcdata )
act_wiz.c:   if( !ch->pcdata->restore_time )
act_wiz.c:   time_passed = current_time - ch->pcdata->restore_time;
act_wiz.c:      ch_printf( victim, "%s is attempting to freeze you.\r\n", ch->name );
act_wiz.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
act_wiz.c:      if( rch->fighting )
act_wiz.c:   for( pwatch = first_watch; pwatch; pwatch = pwatch->next )
act_wiz.c:      fprintf( fp, "%d %s~%s~%s~\n", pwatch->imm_level, pwatch->imm_name,
act_wiz.c:               pwatch->target_name ? pwatch->target_name : " ", pwatch->player_site ? pwatch->player_site : " " );
act_wiz.c:         vch_next = vch->next;
act_wiz.c:         ch->pcdata->wizinvis = level;
act_wiz.c:         ch->mobinvis = level;
act_wiz.c:      if( ch->mobinvis < 2 )
act_wiz.c:         ch->mobinvis = ch->level;
act_wiz.c:   if( ch->pcdata->wizinvis < 2 )
act_wiz.c:      ch->pcdata->wizinvis = ch->level;
act_wiz.c:   if( xIS_SET( ch->act, PLR_WIZINVIS ) )
act_wiz.c:      xREMOVE_BIT( ch->act, PLR_WIZINVIS );
act_wiz.c:      xSET_BIT( ch->act, PLR_WIZINVIS );
act_wiz.c:   if( xIS_SET( ch->act, PLR_HOLYLIGHT ) )
act_wiz.c:      xREMOVE_BIT( ch->act, PLR_HOLYLIGHT );
act_wiz.c:      xSET_BIT( ch->act, PLR_HOLYLIGHT );
act_wiz.c:         char_to_room( d->character, ch->in_room );
act_wiz.c:         snprintf( buf2, MAX_STRING_LENGTH, "%s mortalizing %s", ch->name, buf );
act_wiz.c:               snprintf( buf2, MAX_STRING_LENGTH, "%s mortalizing %s", ch->name, buf );
act_wiz.c:      char_to_room( d->character, ch->in_room );
act_wiz.c:   ch_printf( victim, "%s has bestowed on you the area: %s\r\n", ch->name, argument );
act_wiz.c:      ch_printf( victim, "%s has removed your bestowed commands.\r\n", ch->name );
act_wiz.c:   ch_printf( victim, "%s has bestowed on you the command(s): %s\r\n", ch->name, arg_buf );
act_wiz.c:      ech_next = ech->next;
act_wiz.c:      if( ech->fighting )
act_wiz.c:         if( URANGE( pArea->low_m_vnum, ech->pIndexData->vnum, pArea->hi_m_vnum ) == ech->pIndexData->vnum
act_wiz.c:             || ( ech->in_room && ech->in_room->area == pArea ) )
act_wiz.c:      if( ech->in_room && ech->in_room->area == pArea )
act_wiz.c:         snprintf( buf2, MAX_STRING_LENGTH, "%s destroying %s", ch->name, buf );
act_wiz.c:         snprintf( buf2, MAX_STRING_LENGTH, "%s destroying %s", ch->name, buf );
act_wiz.c:               snprintf( buf2, MAX_STRING_LENGTH, "%s destroying %s", ch->name, buf );
act_wiz.c:      snprintf( buf, MAX_STRING_LENGTH, "%s destroying %s", ch->name, arg );
act_wiz.c:      return ch->name;
act_wiz.c:   one_argument( ch->name, name );  /* copy the first word into name */
act_wiz.c:   for( rch = ch->in_room->first_person; rch && ( rch != ch ); rch = rch->next_in_room )
act_wiz.c:      if( is_name( name, rch->name ) )
act_wiz.c:            old_room = ch->in_room;
act_wiz.c:               old_room = ch->in_room;
act_wiz.c:   victim->pcdata->helled_by = STRALLOC( ch->name );
act_wiz.c:   location = ch->in_room;
act_wiz.c:/*ch->in_room = get_room_index(ROOM_VNUM_HELL);*/
act_wiz.c:/*ch->in_room = location;          The case of unhell self, etc.*/
act_wiz.c:      location = ch->in_room;
act_wiz.c:      if( str_cmp( ch->name, victim->pcdata->helled_by ) )
act_wiz.c:      if( str_cmp( ch->pcdata->council_name, "Quest Council" ) && ( get_trust( ch ) < LEVEL_DEMI ) )
act_wiz.c:                t->tm_mon + 1, t->tm_mday, ch->in_room ? ch->in_room->vnum : 0,
act_wiz.c:                IS_NPC( ch ) ? ch->short_descr : ch->name, argument );
act_wiz.c:   ch_printf( ch, "Kill history for %s:\r\n", vch->name );
act_wiz.c:   for( track = 0; track < MAX_KILLTRACK && vch->pcdata->killed[track].vnum; track++ )
act_wiz.c:      tmob = get_mob_index( vch->pcdata->killed[track].vnum );
act_wiz.c:      ch_printf( ch, "    - killed %d times.\r\n", vch->pcdata->killed[track].count );
act_wiz.c:   if( !ch->desc )
act_wiz.c:   switch ( ch->substate )
act_wiz.c:         if( !ch->pnote )
act_wiz.c:         if( ch->dest_buf != ch->pnote )
act_wiz.c:            bug( "%s", "do_project: sub_writing_note: ch->dest_buf != ch->pnote" );
act_wiz.c:         STRFREE( ch->pnote->text );
act_wiz.c:         ch->pnote->text = copy_buffer( ch );
act_wiz.c:         if( !ch->dest_buf )
act_wiz.c:            bug( "%s", "do_project: sub_project_desc: NULL ch->dest_buf" );
act_wiz.c:            ch->substate = SUB_NONE;
act_wiz.c:         pproject = ( PROJECT_DATA * ) ch->dest_buf;
act_wiz.c:         ch->substate = ch->tempnum;
act_wiz.c:         if( MINE && ( !pproject->owner || str_cmp( ch->name, pproject->owner ) )
act_wiz.c:             && ( !pproject->coder || str_cmp( ch->name, pproject->coder ) ) )
act_wiz.c:      if( str_cmp( ch->pcdata->council_name, "Code Council" )
act_wiz.c:      if( get_trust( ch ) < LEVEL_GOD && str_cmp( ch->pcdata->council_name, "Code Council" ) )
act_wiz.c:      if( get_trust( ch ) < LEVEL_GOD && str_cmp( ch->pcdata->council_name, "Code Council" ) )
act_wiz.c:      ch->tempnum = SUB_NONE;
act_wiz.c:      ch->substate = SUB_PROJ_DESC;
act_wiz.c:      ch->dest_buf = pproject;
act_wiz.c:      if( str_cmp( ch->pcdata->council_name, "Code Council" ) && get_trust( ch ) < LEVEL_ASCENDANT )
act_wiz.c:      pproject->owner = STRALLOC( vch->name );
act_wiz.c:      ch_printf( ch, "Project assigned to %s.\n\r", vch->name );
act_wiz.c:      if( pproject->taken && pproject->owner && !str_cmp( pproject->owner, ch->name ) )
act_wiz.c:      pproject->owner = STRALLOC( ch->name );
act_wiz.c:      if( pproject->coder && !str_cmp( ch->name, pproject->coder ) )
act_wiz.c:      pproject->coder = str_dup( ch->name );
act_wiz.c:      if( pproject->owner && str_cmp( pproject->owner, ch->name ) &&
act_wiz.c:          && pproject->coder && str_cmp( pproject->coder, ch->name ) && str_cmp( ch->pcdata->council_name, "Code Council" ) )
act_wiz.c:         ch->substate = SUB_WRITING_NOTE;
act_wiz.c:         ch->dest_buf = ch->pnote;
act_wiz.c:         start_editing( ch, ch->pnote->text );
act_wiz.c:         STRFREE( ch->pnote->subject );
act_wiz.c:         ch->pnote->subject = STRALLOC( argument );
act_wiz.c:         if( pproject->owner && str_cmp( ch->name, pproject->owner ) &&
act_wiz.c:             pproject->coder && str_cmp( ch->name, pproject->coder ) &&
act_wiz.c:             get_trust( ch ) < LEVEL_GREATER && str_cmp( ch->pcdata->council_name, "Code Council" ) )
act_wiz.c:         if( !ch->pnote )
act_wiz.c:         if( !ch->pnote->subject )
act_wiz.c:         ch->pnote->date = STRALLOC( strtime );
act_wiz.c:         ch->pnote->sender = ch->name;
act_wiz.c:         plog = ch->pnote;
act_wiz.c:         ch->pnote = NULL;
act_wiz.c:             str_cmp( ch->name, pproject->owner ) && get_trust( ch ) < LEVEL_SAVIOR
act_wiz.c:             && str_cmp( ch->name, pproject->coder ) && str_cmp( ch->pcdata->council_name, "Code Council" ) )
act_wiz.c:         if( pproject->owner && str_cmp( ch->name, pproject->owner ) &&
act_wiz.c:             pproject->coder && str_cmp( ch->name, pproject->coder ) && str_cmp( ch->pcdata->council_name, "Code Council" ) )
act_wiz.c:             str_cmp( ch->name, pproject->owner ) && get_trust( ch ) < LEVEL_SAVIOR
act_wiz.c:             && str_cmp( ch->name, pproject->coder ) && str_cmp( ch->pcdata->council_name, "Code Council" ) )
act_wiz.c:      if( inroom && ch->in_room != d->character->in_room )
act_wiz.c:      if( inarea && ch->in_room->area != d->character->in_room->area )
act_wiz.c:      ch_printf( victim, "%s has removed your vnum range.\r\n", ch->name );
act_wiz.c:   ch_printf( victim, "%s has assigned you the vnum range %d - %d.\r\n", ch->name, lo, hi );
agecommand.c:         if( corpse->action_desc && is_name( ch->name, corpse->action_desc ) );
agecommand.c:             && ( skill->guild != CLASS_NONE && ( !IS_GUILDED( ch ) || ( ch->pcdata->clan->Class != skill->guild ) ) ) )
agecommand.c:            if( ch->level >= skill->skill_level[ch->Class] )
agecommand.c:            if( ch->level >= skill->race_level[ch->race] )
agecommand.c:         if( ch->pcdata->learned[sn] <= 0 && SPELL_FLAG( skill, SF_SECRETSKILL ) )
agecommand.c:if ( ch->pcdata->learned[normalSn] <= 99 )
agecommand.c:         if( ch->pcdata->learned[normalSn] > 99 )
agecommand.c:         if( ch->pcdata->learned[normalSn] < 99 )
agecommand.c:pager_printf( ch, "You have a balance of %d\r\n", ch->pcdata->balance);
agecommand.c:      amount = ch->pcdata->balance;
agecommand.c:   if( amount > ch->pcdata->balance )
agecommand.c:   ch->pcdata->balance -= amount;
agecommand.c:   ch->gold += amount;
agecommand.c:pager_printf( ch, "How much gold would you like to deposit, %s?", ch->name );
agecommand.c:pager_printf( ch, "How much gold would you like to deposit, %s?", ch->name );
agecommand.c:      amount = ch->gold;
agecommand.c:   if( amount > ch->gold )
agecommand.c:pager_printf( ch, "Sorrym %s, you do not have that much gold", ch->name );
agecommand.c:pager_printf( ch, "How much gold would you like to deposit, %s?", ch->name );
agecommand.c:   ch->gold -= amount;
agecommand.c:   ch->pcdata->balance += amount;
agecommand.c:        if ( ch->pcdata->souls <= 1999)
agecommand.c:        ch->pcdata->souls -= 2000;
agecommand.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOCPOSE ) )
agecommand.c:      ch->pcdata->cpose = str_dup( " is here." );
agecommand.c:   ch->pcdata->cpose = STRALLOC( buf );
agecommand.c:      ch->pcdata->customclass = str_dup( "Adventurer" );
agecommand.c:   ch->pcdata->customclass = STRALLOC( buf );
agecommand.c:pager_printf( ch, "&CYou are a level %d %s %s from %s.\r\n", ch->level, capitalize( get_race( ch ) ),  ch->pcdata->customclass, ch->pcdata->hometown  );
agecommand.c:pager_printf( ch, "Your TIER rank is %d.\r\n\r\n", ch->pcdata->tier);
agecommand.c:                    (ch->pcdata->str + ch->pcdata->strplus), (ch->pcdata->str + ch->pcdata->att + ch->damroll),  ch->pcdata->attlevel );
agecommand.c:                    (ch->pcdata->dex + ch->pcdata->strplus), (ch->pcdata->def + ch->pcdata->defplus) , ch->pcdata->deflevel );
agecommand.c:                    (ch->pcdata->intel + ch->pcdata->intplus) , (ch->pcdata->mdef + ch->pcdata->mdefplus), ch->pcdata->mlevel );
agecommand.c:                    (ch->pcdata->lck + ch->pcdata->lckplus ) );
agecommand.c:                    ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move );
agecommand.c:                    ch->gold, ch->pcdata->ap, ch->practice );
agecommand.c:   switch ( ch->position )
agecommand.c:   switch ( ch->style )
agecommand.c:      switch ( ch->mental_state / 10 )
agecommand.c:pager_printf( ch, "Your Cpose is set at '%s'\r\n", ch->pcdata->cpose );
agecommand.c:                    ch->pcdata->pkills, ch->pcdata->illegal_pk, ch->pcdata->pdeaths );
agecommand.c:   if( ch->pcdata->clan && ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD )
agecommand.c:                    ch->pcdata->clan->name, ch->pcdata->clan->pkills[6],
agecommand.c:                    ( ch->pcdata->clan->pkills[1] + ch->pcdata->clan->pkills[2] +
agecommand.c:                      ch->pcdata->clan->pkills[3] + ch->pcdata->clan->pkills[4] + ch->pcdata->clan->pkills[5] ) );
agecommand.c:                    ch->pcdata->clan->pdeaths[6],
agecommand.c:                    ( ch->pcdata->clan->pdeaths[1] + ch->pcdata->clan->pdeaths[2] +
agecommand.c:                      ch->pcdata->clan->pdeaths[3] + ch->pcdata->clan->pdeaths[4] + ch->pcdata->clan->pdeaths[5] ) );
agecommand.c:                    xIS_SET( ch->act, PLR_WIZINVIS ) ? "X" : " ", ch->pcdata->wizinvis );
agecommand.c:      pager_printf( ch, "Bamfin:  %s\r\n", ( ch->pcdata->bamfin[0] != '\0' )
agecommand.c:                    ? ch->pcdata->bamfin : "An immortal appears." );
agecommand.c:      pager_printf( ch, "Bamfout: %s\r\n", ( ch->pcdata->bamfout[0] != '\0' )
agecommand.c:                    ? ch->pcdata->bamfout : "The immortal disappears." );
agecommand.c:      if( ch->pcdata->area )
agecommand.c:                       ch->pcdata->area->low_r_vnum, ch->pcdata->area->hi_r_vnum,
agecommand.c:                       ch->pcdata->area->low_o_vnum, ch->pcdata->area->hi_o_vnum,
agecommand.c:                       ch->pcdata->area->low_m_vnum, ch->pcdata->area->hi_m_vnum );
agecommand.c:         pager_printf( ch, "Area Loaded [%s]\r\n", ( IS_SET( ch->pcdata->area->status, AREA_LOADED ) ) ? "yes" : "no" );
agemobcomm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
agemobcomm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
ban.c:   if( !ch->desc )   /* No desc means no go :) */
ban.c:   switch ( ch->substate )
ban.c:         ch->tempnum = SUB_NONE;
ban.c:   if( !ch->desc )   /* No desc is a bad thing */
ban.c:   if( !ch->desc )
ban.c:   switch ( ch->substate )
ban.c:                        temp->ban_by = str_dup( ch->name );
ban.c:               pban->ban_by = str_dup( ch->name );
ban.c:                        temp->ban_by = str_dup( ch->name );
ban.c:               pban->ban_by = str_dup( ch->name );
ban.c:                        temp->ban_by = str_dup( ch->name );
ban.c:               pban->ban_by = str_dup( ch->name );
ban.c:         ch->substate = SUB_BAN_DESC;
ban.c:         ch->dest_buf = pban;
ban.c:         pban = ( BAN_DATA * ) ch->dest_buf;
ban.c:            bug( "%s", "do_ban: sub_ban_desc: NULL ch->dest_buf" );
ban.c:            ch->substate = SUB_NONE;
ban.c:         ch->substate = ch->tempnum;
ban.c:         for( i = 0; i < ( int )( strlen( ch->desc->host ) ); i++ )
ban.c:            new_host[i] = LOWER( ch->desc->host[i] );
ban.c:      if( type == BAN_CLASS && pban->flag == ch->Class )
ban.c:         if( ch->level > pban->level )
ban.c:               log_printf_plus( LOG_WARN, sysdata.log_level, "%s class logging in from %s.", pban->name, ch->desc->host );
ban.c:      if( type == BAN_RACE && pban->flag == ch->race )
ban.c:         if( ch->level > pban->level )
ban.c:               log_printf_plus( LOG_WARN, sysdata.log_level, "%s race logging in from %s.", pban->name, ch->desc->host );
ban.c:            if( ch->level > pban->level )
ban.c:                  log_printf_plus( LOG_WARN, sysdata.log_level, "%s logging in from site %s.", ch->name, ch->desc->host );
bank.c:   for( banker = ch->in_room->first_person; banker; banker = banker->next_in_room )
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "Sorry, %s, we don't do business with mobs.", ch->short_descr );
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s How much gold do you wish to deposit?", ch->name );
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s How much gold do you wish to deposit?", ch->name );
bank.c:      amount = ch->gold;
bank.c:   if( amount > ch->gold )
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s Sorry, but you don't have that much gold to deposit.", ch->name );
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s Oh, I see.. your a comedian.", ch->name );
bank.c:   ch->gold -= amount;
bank.c:   ch->pcdata->balance += amount;
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "Sorry, %s, we don't do business with mobs.", ch->short_descr );
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s How much gold do you wish to withdraw?", ch->name );
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s How much gold do you wish to withdraw?", ch->name );
bank.c:      amount = ch->pcdata->balance;
bank.c:   if( amount > ch->pcdata->balance )
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s But you do not have that much gold in your account!", ch->name );
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "%s Oh I see.. your a comedian.", ch->name );
bank.c:   ch->pcdata->balance -= amount;
bank.c:   ch->gold += amount;
bank.c:      snprintf( buf, MAX_STRING_LENGTH, "Sorry, %s, we don't do business with mobs.", ch->short_descr );
bank.c:   ch_printf( ch, "You have %d gold in the bank.\r\n", ch->pcdata->balance );
boards.c:      if( is_name( ch->name, board->extra_removers ) )
boards.c:      if( ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, board->read_group ) )
boards.c:      if( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, board->read_group ) )
boards.c:      if( is_name( ch->name, board->extra_readers ) )
boards.c:      if( ch->pcdata->clan && !str_cmp( ch->pcdata->clan->name, board->post_group ) )
boards.c:      if( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, board->post_group ) )
boards.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
boards.c:   if( !str_cmp( ch->name, pnote->sender ) )
boards.c:   if( is_name( ch->name, pnote->to_list ) )
boards.c:   if( ch->pnote )
boards.c:   pnote->sender = QUICKLINK( ch->name );
boards.c:   ch->pnote = pnote;
boards.c:   for( quill = ch->last_carrying; quill; quill = quill->prev_content )
boards.c:   switch ( ch->substate )
boards.c:   switch ( ch->substate )
boards.c:   if( !ch->desc )
boards.c:   switch ( ch->substate )
boards.c:         ed = ( EXTRA_DESCR_DATA * ) ch->dest_buf;
boards.c:                      ( board->extra_ballots[0] != '\0' && is_name( ch->name, board->extra_ballots ) ) )
boards.c:                  if( ch->gold < 10 && get_trust( ch ) < sysdata.read_mail_free )
boards.c:                     ch->gold -= 10;
boards.c:      if( pnote->no_remove != 0 && pnote->no_remove > ch->level )
boards.c:      pnote->no_remove = ch->level;
boards.c:         if( str_cmp( ch->name, pnote->sender ) && get_trust( ch ) < LEVEL_GREATER )
boards.c:         if( str_cmp( ch->name, pnote->sender ) && get_trust( ch ) < LEVEL_GREATER )
boards.c:         if( str_cmp( ch->name, pnote->sender ) )
boards.c:      if( is_name( ch->name, buf ) )
boards.c:         snprintf( buf, MAX_STRING_LENGTH, "%s %s", pnote->yesvotes, ch->name );
boards.c:         snprintf( buf, MAX_STRING_LENGTH, "%s %s", pnote->novotes, ch->name );
boards.c:         snprintf( buf, MAX_STRING_LENGTH, "%s %s", pnote->abstentions, ch->name );
boards.c:      if( ch->substate == SUB_RESTRICTED )
boards.c:         ch->substate = SUB_WRITING_NOTE;
boards.c:         ch->dest_buf = ed;
boards.c:      ch_printf( ch, "%s: %s\r\nTo: %s\r\n", ch->name, subject, to_list );
boards.c:      pnote->sender = QUICKLINK( ch->name );
boards.c:      if( ch->substate == SUB_RESTRICTED )
boards.c:         ch->substate = SUB_WRITING_NOTE;
boards.c:         ch->dest_buf = ed;
boards.c:                && ( get_trust( ch ) < sysdata.take_others_mail ) && ( take == 1 ) && str_cmp( ch->name, pnote->sender ) )
boards.c:            if( pnote->no_remove != 0 && ( take == 1 || take == 0 ) && ch->level < pnote->no_remove )
boards.c:               if( ch->gold < 50 && get_trust( ch ) < sysdata.read_mail_free )
boards.c:                  ch->gold -= 50;
boards.c:            if( is_name( ch->name, note->to_list ) )
boards.c:            else if( !str_cmp( ch->name, note->sender ) )
boards.c:   if( !ch->desc )
boards.c:   switch ( ch->substate )
boards.c:            bug( "%s: Player not holding journal. (Player: %s)", __func__, ch->name );
boards.c:         ed = ( EXTRA_DESCR_DATA * )ch->dest_buf;
boards.c:         bug( "%s: Journal size greater than 50 pages! Resetting to 50 pages. (Player: %s)", __func__, ch->name );
boards.c:      ch->substate = SUB_JOURNAL_WRITE;
boards.c:      ch->dest_buf = ed;
boards.c:            bug( "%s: Journal size greater than 50 pages! Resetting to 50 pages. (Player: %s)", __func__, ch->name );
boards.c:         bug( "%s: Journal size greater than 50 pages! Resetting to 50 pages. (Player: %s)", __func__, ch->name );
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   if( !ch->desc )
build.c:   if( ch->substate == SUB_RESTRICTED )
build.c:      bug( "%s", "NOT GOOD: start_editing: ch->substate == SUB_RESTRICTED" );
build.c:   if( ch->editor )
build.c:   ch->editor = edit;
build.c:   ch->desc->connected = CON_EDITING;
build.c:   if( !ch->editor )
build.c:   for( x = 0; x < ch->editor->numlines; x++ )
build.c:      mudstrlcpy( tmp, ch->editor->line[x], 100 );
build.c:   if( !ch->editor )
build.c:   for( x = 0; x < ch->editor->numlines; x++ )
build.c:      mudstrlcpy( tmp, ch->editor->line[x], 100 );
build.c:   DISPOSE( ch->editor );
build.c:   ch->editor = NULL;
build.c:   ch->dest_buf = NULL;
build.c:   ch->spare_ptr = NULL;
build.c:   ch->substate = SUB_NONE;
build.c:   if( !ch->desc )
build.c:   ch->desc->connected = CON_PLAYING;
build.c:      if( !IS_NPC( fch ) && get_trust( ch ) < get_trust( fch ) && IS_SET( fch->pcdata->flags, PCFLAG_DND ) )
build.c:         ch_printf( ch, "Sorry. %s does not wish to be disturbed.\r\n", fch->name );
build.c:         ch_printf( fch, "Your DND flag just foiled %s's goto command.\r\n", ch->name );
build.c:      if( get_trust( ch ) < LEVEL_CREATOR || vnum < 1 || IS_NPC( ch ) || !ch->pcdata->area )
build.c:         if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:      location = make_room( vnum, ch->pcdata->area );
build.c:      ch_printf( victim, "Your DND flag just foiled %s's goto command.\r\n", ch->name );
build.c:   in_room = ch->in_room;
build.c:   if( ch->fighting )
build.c:   if( !xIS_SET( ch->act, PLR_WIZINVIS ) )
build.c:           ( ch->pcdata
build.c:             && ch->pcdata->bamfout[0] != '\0' ) ? ch->pcdata->bamfout : ( char * )"The immortal disappears.", TO_ROOM );
build.c:   ch->regoto = ch->in_room->vnum;
build.c:   if( ch->mount )
build.c:      char_from_room( ch->mount );
build.c:      char_to_room( ch->mount, location );
build.c:   if( !xIS_SET( ch->act, PLR_WIZINVIS ) )
build.c:           ( ch->pcdata
build.c:             && ch->pcdata->bamfin[0] != '\0' ) ? ch->pcdata->bamfin : ( char * )"An immortal appears.", TO_ROOM );
build.c:   if( ch->in_room == in_room )
build.c:      fch_next = fch->next_in_room;
build.c:      if( fch->master == ch && IS_IMMORTAL( fch ) )
build.c:      else if( IS_NPC( fch ) && fch->master == ch )
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "%s", "do_mset: sub_mob_desc: NULL ch->dest_buf" );
build.c:            ch->substate = SUB_NONE;
build.c:         victim = ( CHAR_DATA * ) ch->dest_buf;
build.c:         ch->substate = ch->tempnum;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      victim = ( CHAR_DATA * ) ch->dest_buf;
build.c:         if( ch->dest_buf )
build.c:            RelDestroy( relMSET_ON, ch, ch->dest_buf );
build.c:         ch->substate = SUB_NONE;
build.c:         ch->dest_buf = NULL;
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:            ch->pcdata->subprompt = NULL;
build.c:   if( arg1[0] == '\0' || ( arg2[0] == '\0' && ch->substate != SUB_REPEATCMD ) || !str_cmp( arg1, "?" ) )
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      ch->dest_buf = NULL;
build.c:      ch->dest_buf = NULL;
build.c:      ch->dest_buf = victim;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->dest_buf = victim;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->pcdata->subprompt = STRALLOC( buf );
build.c:      ch_printf( victim, "Your password has been changed by %s.\r\n", ch->name );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_MOB_DESC;
build.c:      ch->dest_buf = victim;
build.c:            else if( value == ACT_PROTOTYPE && ch->level < sysdata.level_modify_proto )
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_mset;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "%s: sub_obj_extra: NULL ch->dest_buf", __func__ );
build.c:            ch->substate = SUB_NONE;
build.c:         ed = ( EXTRA_DESCR_DATA * ) ch->dest_buf;
build.c:         tmpobj = ( OBJ_DATA * ) ch->spare_ptr;
build.c:         ch->dest_buf = tmpobj;
build.c:         ch->substate = ch->tempnum;
build.c:         if( !ch->dest_buf )
build.c:            bug( "%s: sub_obj_long: NULL ch->dest_buf", __func__ );
build.c:            ch->substate = SUB_NONE;
build.c:         obj = ( OBJ_DATA * ) ch->dest_buf;
build.c:         tmpobj = ( OBJ_DATA * ) ch->spare_ptr;
build.c:         ch->substate = ch->tempnum;
build.c:         ch->dest_buf = tmpobj;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      obj = ( OBJ_DATA * ) ch->dest_buf;
build.c:         if( ch->dest_buf )
build.c:            RelDestroy( relOSET_ON, ch, ch->dest_buf );
build.c:         ch->substate = SUB_NONE;
build.c:         ch->dest_buf = NULL;
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:            ch->pcdata->subprompt = NULL;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      ch->dest_buf = obj;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->dest_buf = obj;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->pcdata->subprompt = STRALLOC( buf );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:         ch->spare_ptr = obj;
build.c:         ch->spare_ptr = NULL;
build.c:      ch->substate = SUB_OBJ_LONG;
build.c:      ch->dest_buf = obj;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:         ch->spare_ptr = obj;
build.c:         ch->spare_ptr = NULL;
build.c:      ch->substate = SUB_OBJ_EXTRA;
build.c:      ch->dest_buf = ed;
build.c:                && get_trust( ch ) < LEVEL_GREATER && !is_name( "protoflag", ch->pcdata->bestowments ) )
build.c:            for( vch = first_char; vch; vch = vch->next )
build.c:               for( eq = vch->first_carrying; eq; eq = eq->next_content )
build.c:                  for( vch = first_char; vch; vch = vch->next )
build.c:                     for( eq = vch->first_carrying; eq; eq = eq->next_content )
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_oset;
build.c:   if( !ch->pcdata->area )
build.c:   ch_location = ch->in_room;
build.c:      pArea = ch->pcdata->area;
build.c:      location->area = ch->pcdata->area;
build.c:   ch_location = ch->in_room;
build.c:   pArea = ch->pcdata->area;
build.c:         location->area = ch->pcdata->area;
build.c:      for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
build.c:               for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
build.c:               for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
build.c:   if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   original = ch->in_room;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         location = ( ROOM_INDEX_DATA * ) ch->dest_buf;
build.c:            bug( "%s", "redit: sub_room_desc: NULL ch->dest_buf" );
build.c:            location = ch->in_room;
build.c:         ch->substate = ch->tempnum;
build.c:         ed = ( EXTRA_DESCR_DATA * ) ch->dest_buf;
build.c:            bug( "%s", "redit: sub_room_extra: NULL ch->dest_buf" );
build.c:         ch->substate = ch->tempnum;
build.c:   location = ch->in_room;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:         if( ch->pcdata && ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:            ch->pcdata->subprompt = NULL;
build.c:         ch->substate = SUB_NONE;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      if( ch->pcdata )
build.c:         if( ch->pcdata->subprompt )
build.c:            STRFREE( ch->pcdata->subprompt );
build.c:         ch->pcdata->subprompt = STRALLOC( "<&CRedit &W#%r&w> %i" );
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_ROOM_DESC;
build.c:      ch->dest_buf = location;
build.c:      if( ch->substate == SUB_REPEATCMD )
build.c:         ch->tempnum = SUB_REPEATCMD;
build.c:         ch->tempnum = SUB_NONE;
build.c:      ch->substate = SUB_ROOM_EXTRA;
build.c:      ch->dest_buf = ed;
build.c:   if( ch->substate == SUB_REPEATCMD )
build.c:      ch->substate = SUB_RESTRICTED;
build.c:      ch->substate = SUB_REPEATCMD;
build.c:      ch->last_cmd = do_redit;
build.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:      if( !ch->pcdata || !( pArea = ch->pcdata->area ) )
build.c:   char_to_room( mob, ch->in_room );
build.c:   if( ( d = ch->desc ) == NULL )
build.c:   if( ch->substate <= SUB_PAUSE )
build.c:      bug( "%s: illegal ch->substate (%d)", __func__, ch->substate );
build.c:   if( !ch->editor )
build.c:   edit = ch->editor;
build.c:         int substate = ch->substate;
build.c:         last_cmd = ch->last_cmd;
build.c:         ch->substate = SUB_RESTRICTED;
build.c:         ch->substate = substate;
build.c:         ch->last_cmd = last_cmd;
build.c:         if( !ch->last_cmd )
build.c:         ( *ch->last_cmd ) ( ch, "" );
build.c:      if( !ch->last_cmd )
build.c:      ( *ch->last_cmd ) ( ch, "" );
build.c:   if( get_trust( ch ) > LEVEL_IMMORTAL && ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
build.c:      tarea = ch->pcdata->area;
build.c:      snprintf( taf, 1024, "%s.are", capitalize( ch->name ) );
build.c:         log_printf_plus( LOG_NORMAL, ch->level, "Creating area entry for %s", ch->name );
build.c:         snprintf( buf, MAX_STRING_LENGTH, "{PROTO} %s's area in progress", ch->name );
build.c:         snprintf( buf2, MAX_STRING_LENGTH, "%s", ch->name );
build.c:         log_printf_plus( LOG_NORMAL, ch->level, "Updating area entry for %s", ch->name );
build.c:      tarea->low_r_vnum = ch->pcdata->r_range_lo;
build.c:      tarea->low_o_vnum = ch->pcdata->o_range_lo;
build.c:      tarea->low_m_vnum = ch->pcdata->m_range_lo;
build.c:      tarea->hi_r_vnum = ch->pcdata->r_range_hi;
build.c:      tarea->hi_o_vnum = ch->pcdata->o_range_hi;
build.c:      tarea->hi_m_vnum = ch->pcdata->m_range_hi;
build.c:      ch->pcdata->area = tarea;
build.c:      ch->pcdata->area = NULL;
build.c:      if( !ch->pcdata->area )
build.c:       || ( is_name( buf, ch->pcdata->bestowments )
build.c:       || ( ch->pcdata->council && is_name( buf, ch->pcdata->council->powers ) ) )
build.c:                || is_name( tmp->filename, ch->pcdata->bestowments )
build.c:                || ( ch->pcdata->council
build.c:                     && ( is_name( buf, ch->pcdata->council->powers )
build.c:                          || is_name( "aassign", ch->pcdata->council->powers ) ) ) )
build.c:   ch->pcdata->area = tarea;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata || ( argument[0] == '\0' && !ch->pcdata->area ) )
build.c:      tarea = ch->pcdata->area;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata || ( argument[0] == '\0' && !ch->pcdata->area ) )
build.c:      tarea = ch->pcdata->area;
build.c:         tarea = ch->in_room->area;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:   tarea = ch->pcdata->area;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:   tarea = ch->pcdata->area;
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:   tarea = ch->pcdata->area;
build.c:   ch->substate = SUB_MPROG_EDIT;
build.c:   ch->dest_buf = mprg;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "%s", "do_mpedit: sub_mprog_edit: NULL ch->dest_buf" );
build.c:            ch->substate = SUB_NONE;
build.c:         mprog = ( MPROG_DATA * ) ch->dest_buf;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "%s", "do_opedit: sub_oprog_edit: NULL ch->dest_buf" );
build.c:            ch->substate = SUB_NONE;
build.c:         mprog = ( MPROG_DATA * ) ch->dest_buf;
build.c:   ch->substate = SUB_MPROG_EDIT;
build.c:   ch->dest_buf = mprg;
build.c:   if( !ch->desc )
build.c:   switch ( ch->substate )
build.c:         if( !ch->dest_buf )
build.c:            bug( "%s", "do_opedit: sub_oprog_edit: NULL ch->dest_buf" );
build.c:            ch->substate = SUB_NONE;
build.c:         mprog = ( MPROG_DATA * ) ch->dest_buf;
build.c:   if( !can_rmodify( ch, ch->in_room ) )
build.c:   mprog = ch->in_room->mudprogs;
build.c:            xCLEAR_BITS( ch->in_room->progtypes );
build.c:               xSET_BIT( ch->in_room->progtypes, mprg->type );
build.c:         mprg_next = ch->in_room->mudprogs;
build.c:         ch->in_room->mudprogs = mprg_next->next;
build.c:            xREMOVE_BIT( ch->in_room->progtypes, mptype );
build.c:         xSET_BIT( ch->in_room->progtypes, mptype );
build.c:         ch->in_room->mudprogs = mprg;
build.c:            xSET_BIT( ch->in_room->progtypes, mptype );
build.c:         ch->in_room->mudprogs = mprg;
build.c:      xSET_BIT( ch->in_room->progtypes, mptype );
build.c:   if( ch->substate == SUB_RESTRICTED )
build.c:   if( ch->substate == SUB_RESTRICTED )
build.c:       && ( obj->vnum < ch->pcdata->area->low_o_vnum || obj->vnum > ch->pcdata->area->hi_o_vnum ) )
build.c:   if( ch->substate == SUB_RESTRICTED )
build.c:       && ( mob->vnum < ch->pcdata->area->low_m_vnum || mob->vnum > ch->pcdata->area->hi_m_vnum ) )
build.c:   if( !ch->desc )
build.c:   if( !ch->desc )
build.c:   if( !ch->desc )
build.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_CREATOR || !ch->pcdata
build.c:       || ( !ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER ) )
build.c:   tarea = ch->pcdata->area;
calendar.c:   ch->pcdata->timezone = i;
calendar.c:   ch_printf( ch, "&wYour local time        :  &W %s&D\r\n", c_time( current_time, ch->pcdata->timezone ) );
calendar.c:      if( day == ch->pcdata->day + 1 && time_info.month == ch->pcdata->month )
chess.c:   if( IS_WHITE( board->board[x][y] ) && !str_cmp( board->player1, ch->name ) )
chess.c:   if( IS_BLACK( board->board[x][y] ) && ( !str_cmp( board->player2, ch->name ) || !ch ) )
chess.c:         ch->pcdata->game_board = NULL;
chess.c:         ch->pcdata->game_board = NULL;
chess.c:      if( ch->pcdata->game_board )
chess.c:      ch->pcdata->game_board = board;
chess.c:      ch->pcdata->game_board->player1 = QUICKLINK( ch->name );
chess.c:      if( ch->pcdata->game_board )
chess.c:         board->player1 = QUICKLINK( ch->name );
chess.c:         ch->pcdata->game_board = board;
chess.c:         imc_send_chess( ch->name, arg2, "start" );
chess.c:      board = vch->pcdata->game_board;
chess.c:      board->player2 = QUICKLINK( ch->name );
chess.c:      ch->pcdata->game_board = board;
chess.c:      ch_printf( vch, "%s has joined your game.\r\n", ch->name );
chess.c:   if( !ch->pcdata->game_board )
chess.c:      free_game( ch->pcdata->game_board );
chess.c:      GAME_BOARD_DATA *board = ch->pcdata->game_board;
chess.c:      else if( !str_cmp( board->player1, ch->name ) )
chess.c:      else if( !str_cmp( board->player2, ch->name ) )
chess.c:      if( board->turn % 2 == 1 && !str_cmp( board->player1, ch->name ) )
chess.c:      else if( board->turn % 2 == 0 && !str_cmp( board->player2, ch->name ) )
chess.c:      send_to_char( print_big_board( ch, ch->pcdata->game_board ), ch );
chess.c:      if( !ch->pcdata->game_board->player1 || !ch->pcdata->game_board->player2 )
chess.c:      if( ch->pcdata->game_board->turn < 0 )
chess.c:      if( king_in_checkmate( ch->pcdata->game_board, BLACK_KING ) )
chess.c:      if( king_in_checkmate( ch->pcdata->game_board, WHITE_KING ) )
chess.c:      if( ch->pcdata->game_board->turn % 2 == 1 && !str_cmp( ch->pcdata->game_board->player1, ch->name ) )
chess.c:      if( ch->pcdata->game_board->turn % 2 == 0 && !str_cmp( ch->pcdata->game_board->player2, ch->name ) )
chess.c:      ret = is_valid_move( ch, ch->pcdata->game_board, x, y, dx, dy );
chess.c:         board = ch->pcdata->game_board;
chess.c:            if( ch->pcdata->game_board->type == TYPE_IMC )
chess.c:               imc_send_chess( ch->pcdata->game_board->player1, ch->pcdata->game_board->player2, arg );
chess.c:      if( !str_cmp( ch->name, ch->pcdata->game_board->player1 ) )
chess.c:         opp = get_char_world( ch, ch->pcdata->game_board->player2 );
chess.c:            mudstrlcpy( opp_name, ch->pcdata->game_board->player2, MAX_INPUT_LENGTH );
chess.c:         opp = get_char_world( ch, ch->pcdata->game_board->player1 );
chess.c:            mudstrlcpy( opp_name, ch->pcdata->game_board->player1, MAX_INPUT_LENGTH );
chess.c:         if( ch->pcdata->game_board->type == TYPE_LOCAL ) \
chess.c:         if( ch->pcdata->game_board->type == TYPE_IMC ) \
chess.c:            imc_send_tell( ch->name, opp_name, (arg), 1 ); \
chess.c:         if( ch->pcdata->game_board->type == TYPE_LOCAL ) \
chess.c:            snprintf( arg, MAX_INPUT_LENGTH, "%s has moved.\r\n", ch->name );
chess.c:            snprintf( arg, MAX_INPUT_LENGTH, "%s has taken one of your pieces!", ch->name );
chess.c:            snprintf( arg, MAX_INPUT_LENGTH, "%s has attempted a move that would result in checkmate.", ch->name );
chess.c:            snprintf( arg, MAX_INPUT_LENGTH, "%s has made a move that would result in a check.", ch->name );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   for( roster = ch->pcdata->clan->first_member; roster; roster = roster->next )
clans.c:      if( !str_cmp( ch->name, roster->name ) )
clans.c:         roster->level = ch->level;
clans.c:         roster->kills = ch->pcdata->mkills;
clans.c:         roster->deaths = ch->pcdata->mdeaths;
clans.c:         save_clan( ch->pcdata->clan );
clans.c:   add_roster( ch->pcdata->clan, ch->name, ch->Class, ch->level, ch->pcdata->mkills, ch->pcdata->mdeaths );
clans.c:   save_clan( ch->pcdata->clan );
clans.c:      templvl = ch->level;
clans.c:      ch->level = LEVEL_HERO;  /* make sure EQ doesn't get lost */
clans.c:      contents = ch->in_room->last_content;
clans.c:      ch->level = templvl;
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( str_cmp( ch->name, clan->leader )
clans.c:       && str_cmp( ch->name, clan->deity ) && ( clan->clan_type != CLAN_GUILD || str_cmp( ch->name, clan->number1 ) ) )
clans.c:      obj = obj_to_room( obj, ch->in_room );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( ( ch->pcdata && ch->pcdata->bestowments
clans.c:         && is_name( "caninduct", ch->pcdata->bestowments ) )
clans.c:       || !str_cmp( ch->name, clan->deity )
clans.c:       || !str_cmp( ch->name, clan->leader ) || !str_cmp( ch->name, clan->number1 ) || !str_cmp( ch->name, clan->number2 ) )
clans.c:      if( victim->level > ch->level )
clans.c:            ch_printf( victim, "%s instructs you in the ways of %s.\r\n", ch->name, skill_table[sn]->name );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->council )
clans.c:   council = ch->pcdata->council;
clans.c:   if( ( council->head == NULL || str_cmp( ch->name, council->head ) )
clans.c:       && ( council->head2 == NULL || str_cmp( ch->name, council->head2 ) ) && str_cmp( council->name, "mortal council" ) )
clans.c:   if( !str_cmp( ch->name, clan->deity ) )
clans.c:   if( !str_cmp( ch->name, clan->leader ) )
clans.c:   if( !str_cmp( ch->name, clan->number1 ) )
clans.c:   if( !str_cmp( ch->name, clan->number2 ) )
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   clan = ch->pcdata->clan;
clans.c:   if( ( ch->pcdata && ch->pcdata->bestowments
clans.c:         && is_name( "canoutcast", ch->pcdata->bestowments ) )
clans.c:       || !str_cmp( ch->name, clan->deity )
clans.c:       || !str_cmp( ch->name, clan->leader ) || !str_cmp( ch->name, clan->number1 ) || !str_cmp( ch->name, clan->number2 ) )
clans.c:      if( ch->pcdata->clan->clan_type == CLAN_ORDER )
clans.c:      else if( ch->pcdata->clan->clan_type == CLAN_GUILD )
clans.c:   if( victim->pcdata->clan != ch->pcdata->clan )
clans.c:      if( ch->pcdata->clan->clan_type == CLAN_ORDER )
clans.c:      else if( ch->pcdata->clan->clan_type == CLAN_GUILD )
clans.c:   if( !str_cmp( victim->name, ch->pcdata->clan->number1 ) )
clans.c:      STRFREE( ch->pcdata->clan->number1 );
clans.c:      ch->pcdata->clan->number1 = STRALLOC( "" );
clans.c:   if( !str_cmp( victim->name, ch->pcdata->clan->number2 ) )
clans.c:      STRFREE( ch->pcdata->clan->number2 );
clans.c:      ch->pcdata->clan->number2 = STRALLOC( "" );
clans.c:   if( !str_cmp( victim->name, ch->pcdata->clan->deity ) )
clans.c:      STRFREE( ch->pcdata->clan->deity );
clans.c:      ch->pcdata->clan->deity = STRALLOC( "" );
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->council )
clans.c:   council = ch->pcdata->council;
clans.c:   if( ( council->head == NULL || str_cmp( ch->name, council->head ) )
clans.c:       && ( council->head2 == NULL || str_cmp( ch->name, council->head2 ) ) && str_cmp( council->name, "mortal council" ) )
clans.c:   if( victim->pcdata->council != ch->pcdata->council )
clans.c:   if( council->head2 && !str_cmp( victim->name, ch->pcdata->council->head2 ) )
clans.c:      STRFREE( ch->pcdata->council->head2 );
clans.c:      ch->pcdata->council->head2 = NULL;
clans.c:   if( !str_cmp( ch->name, clan->deity )
clans.c:       || !str_cmp( ch->name, clan->leader )
clans.c:       || !str_cmp( ch->name, clan->number1 ) || !str_cmp( ch->name, clan->number2 ) || get_trust( ch ) >= LEVEL_GREATER )
clans.c:   if( !str_cmp( ch->name, order->deity )
clans.c:       || !str_cmp( ch->name, order->leader )
clans.c:       || !str_cmp( ch->name, order->number1 ) || !str_cmp( ch->name, order->number2 ) || get_trust( ch ) >= LEVEL_GREATER )
clans.c:   if( !str_cmp( ch->name, guild->deity )
clans.c:       || !str_cmp( ch->name, guild->leader )
clans.c:       || !str_cmp( ch->name, guild->number1 ) || !str_cmp( ch->name, guild->number2 ) || get_trust( ch ) >= LEVEL_GREATER )
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   if( ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD )
clans.c:      snprintf( filename, 256, "%s%s.defeats", CLAN_DIR, ch->pcdata->clan->name );
clans.c:      if( !str_cmp( ch->name, ch->pcdata->clan->leader ) && !str_cmp( argument, "clean" ) )
clans.c:   if( IS_NPC( ch ) || !ch->pcdata->clan )
clans.c:   if( ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD )
clans.c:      snprintf( filename, 256, "%s%s.record", CLAN_DIR, ch->pcdata->clan->name );
clans.c:      if( !str_cmp( ch->name, ch->pcdata->clan->leader ) && !str_cmp( argument, "clean" ) )
clans.c:   if( IS_NPC( ch ) || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
clans.c:   if( ch->level - victim->level > 5 || victim->level - ch->level > 5 )
clans.c:   if( ( pexit = get_exit( ch->in_room, exit_dir ) ) == NULL )
clans.c:   if( ch->in_room->area != to_room->area && !in_hard_range( victim, to_room->area ) )
clans.c:   if( ch->Class == CLASS_WARRIOR )
clans.c:   if( ch->Class == CLASS_VAMPIRE )
clans.c:   if( ch->Class == CLASS_RANGER )
clans.c:   if( ch->Class == CLASS_DRUID )
clans.c:   if( ch->Class == CLASS_CLERIC )
clans.c:   if( ch->Class == CLASS_THIEF )
clans.c:   if( ch->Class == CLASS_MAGE )
clans.c:   if( ch->Class == CLASS_AUGURER )
clans.c:   if( ch->Class == CLASS_PALADIN )
clans.c:   if( ch->Class == CLASS_NEPHANDI )
clans.c:   if( ch->Class == CLASS_SAVAGE )
clans.c:   schance += ( ch->level - victim->level );
clans.c:   if( ch->race == RACE_ELF )
clans.c:   if( ch->race == RACE_DWARF )
clans.c:   if( ch->race == RACE_HALFLING )
clans.c:   if( ch->race == RACE_PIXIE )
clans.c:   if( ch->race == RACE_HALF_OGRE )
clans.c:   if( ch->race == RACE_HALF_ORC )
clans.c:   if( ch->race == RACE_HALF_TROLL )
clans.c:   if( ch->race == RACE_HALF_ELF )
clans.c:   if( ch->race == RACE_GITH )
clans.c:   if( ch->race == RACE_PIXIE )
clans.c:   if( ch->race == RACE_DROW )
clans.c:   if( ch->race == RACE_SEA_ELF )
clans.c:   if( ch->race == RACE_LIZARDMAN )
clans.c:   if( ch->race == RACE_GNOME )
clans.c:   move_char( victim, get_exit( ch->in_room, exit_dir ), 0 );
clans.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) && get_timer( ch, TIMER_SHOVEDRAG ) <= 0 )
clans.c:   if( !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) && IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) )
clans.c:   if( ch->level - victim->level > 5 || victim->level - ch->level > 5 )
clans.c:      if( IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
clans.c:   if( ( pexit = get_exit( ch->in_room, exit_dir ) ) == NULL )
clans.c:   if( ch->in_room->area != to_room->area && !in_hard_range( victim, to_room->area ) )
clans.c:   if( ch->Class == CLASS_WARRIOR )
clans.c:   if( ch->Class == CLASS_VAMPIRE )
clans.c:   if( ch->Class == CLASS_RANGER )
clans.c:   if( ch->Class == CLASS_DRUID )
clans.c:   if( ch->Class == CLASS_CLERIC )
clans.c:   if( ch->Class == CLASS_THIEF )
clans.c:   if( ch->Class == CLASS_MAGE )
clans.c:   schance += ( ch->level - victim->level );
clans.c:   if( ch->race == 1 )
clans.c:   if( ch->race == 2 )
clans.c:   if( ch->race == 3 )
clans.c:   if( ch->race == 4 )
clans.c:   if( ch->race == 6 )
clans.c:   if( ch->race == 7 )
clans.c:   if( ch->race == 8 )
clans.c:   if( ch->race == 9 )
clans.c:      move_char( victim, get_exit( ch->in_room, exit_dir ), 0 );
clans.c:      move_char( ch, get_exit( ch->in_room, exit_dir ), 0 );
color.c:         memcpy( &ch->colors, &default_set, sizeof( default_set ) );
color.c:               ch->colors[x] = fread_number( fp );
color.c:      log_printf( "%s: Attempting to reset NPC colors: %s", __func__, ch->short_descr );
color.c:         fprintf( fp, " %d", ch->colors[x] );
color.c:               ch->colors[x] = fread_number( fp );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, ANSI_RESET, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, log_buf, 0 );
color.c:      write_to_buffer( ch->desc, ANSI_RESET, 0 );
color.c:         ch->colors[count] = default_set[count];
color.c:         ch->colors[ccount] = y;
color.c:      ch->colors[count] = y;
color.c:   if( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_ANSI ) )
color.c:   switch ( ch->colors[AType] )
color.c:         ansi = ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_ANSI ) );
color.c:                  if( ch && ch->desc )
color.c:                     mudstrlcat( dst, color_str( ch->desc->pagecolor, ch ), dstlen );
color.c:   if( !ch || !ch->desc )
color.c:   write_to_buffer( ch->desc, color_str( AType, ch ), 0 );
color.c:   if( !ch->desc )
color.c:      bug( "%s: NULL descriptor after WTB! CH: %s", __func__, ch->name ? ch->name : "Unknown?!?" );
color.c:   ch->desc->pagecolor = ch->colors[AType];
color.c:   if( !ch || !ch->desc )
color.c:   write_to_pager( ch->desc, color_str( AType, ch ), 0 );
color.c:   if( !ch->desc )
color.c:      bug( "%s: NULL descriptor after WTP! CH: %s", __func__, ch->name ? ch->name : "Unknown?!?" );
color.c:   ch->desc->pagecolor = ch->colors[AType];
color.c:   if( txt && ch->desc )
color.c:      send_to_desc_color( txt, ch->desc );
color.c:   if( txt && ch->desc )
color.c:      DESCRIPTOR_DATA *d = ch->desc;
color.c:      if( IS_NPC( ch ) || !IS_SET( ch->pcdata->flags, PCFLAG_PAGERON ) )
color.c:         if( ch->desc )
color.c:            send_to_desc_color( txt, ch->desc );
color.c:         if( ch->desc )
color.c:            write_to_pager( ch->desc, colorize( txt, ch->desc ), 0 );
comm.c:  for ( ch = first_char; ch; ch = ch->next )
comm.c:    log_printf( "%cPC: %-20s room: %d", IS_NPC(ch) ? 'N' : ' ', ch->name, ch->in_room->vnum );
comm.c:           ch ? ch->name : d->host, ( void * )dclose, ( void * )first_descriptor );
comm.c:            bug( "%s: %s desc:%p found, prev should be:%p, fixing.", __func__, ch ? ch->name : d->host, ( void * )dclose,
comm.c:         bug( "%s: %s desc:%p could not be found!.", __func__, ch ? ch->name : dclose->host, ( void * )dclose );
comm.c:           ch ? ch->name : d->host, ( void * )dclose, ( void * )last_descriptor );
comm.c:            bug( "%s: %s desc:%p found, next should be:%p, fixing.", __func__, ch ? ch->name : d->host, ( void * )dclose,
comm.c:         bug( "%s: %s desc:%p could not be found!.", __func__, ch ? ch->name : dclose->host, ( void * )dclose );
comm.c:      log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "Closing link to %s. (INRoom %d)", ch->pcdata->filename, ( ch->in_room ? ch->in_room->vnum : -1 ) );
comm.c:         if( ch->last_cmd )
comm.c:            ch->last_cmd( ch, "" );
comm.c:         ch->desc = NULL;
comm.c:      if( xIS_SET( ch->act, PLR_BLANK ) )
comm.c:      if( xIS_SET( ch->act, PLR_PROMPT ) )
comm.c:      if( ch && !IS_NPC( ch ) && xIS_SET( ch->act, PLR_ANSI ) )
comm.c:      if( xIS_SET( ch->act, PLR_TELNET_GA ) )
comm.c:   if( !IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO ) )
comm.c:      if( xIS_SET( ch->act, PLR_RIP ) )
comm.c:      else if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c:   if( xIS_SET( ch->act, PLR_DENY ) )
comm.c:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c:   if( check_playing( d, ch->pcdata->filename, TRUE ) )
comm.c:chk = check_reconnect( d, ch->pcdata->filename, TRUE );
comm.c:   mudstrlcpy( buf, ch->pcdata->filename, MAX_STRING_LENGTH );
comm.c:   if( ch->position == POS_FIGHTING
comm.c:       || ch->position == POS_EVASIVE
comm.c:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
comm.c:      ch->position = POS_STANDING;
comm.c:   log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s (%s) has connected.", ch->name, d->host );
comm.c:                   "\r\nPick a good password for %s: %s", ch->name, echo_off_str );
comm.c:   DISPOSE( ch->pcdata->pwd );
comm.c:   ch->pcdata->pwd = str_dup( pwdnew );
comm.c:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c:         ch->sex = SEX_MALE;
comm.c:         ch->sex = SEX_FEMALE;
comm.c:            ch->Class = iClass;
comm.c:   ch->pcdata->cpose = str_dup( " is here." );
comm.c:   ch->Class = 6;
comm.c:   ch->pcdata->customclass = str_dup( "Adventurer" );
comm.c:   ch->pcdata->str = 4;
comm.c:   ch->pcdata->intel = 3;
comm.c:   ch->pcdata->dex = 4;
comm.c:   ch->pcdata->lck = 2;
comm.c:   ch->pcdata->att = 10;
comm.c:   ch->pcdata->def = 15;
comm.c:   ch->pcdata->mdef = 5;
comm.c:   ch->pcdata->matt = 5;
comm.c:   ch->pcdata->strplus = 0;
comm.c:   ch->pcdata->intplus = 0;
comm.c:   ch->pcdata->dexplus = 0;
comm.c:   ch->pcdata->lckplus = 0;
comm.c:   ch->pcdata->attplus = 0;
comm.c:   ch->pcdata->defplus = 0;
comm.c:   ch->pcdata->mattplus = 0;
comm.c:   ch->pcdata->mdefplus = 0;
comm.c:   ch->pcdata->mlevel = 1;
comm.c:   ch->pcdata->deflevel = 1;
comm.c:   ch->pcdata->attlevel = 1;
comm.c:  ch->perm_con = 18;
comm.c:  ch->perm_cha = 18;
comm.c:  ch->perm_wis = 18;
comm.c:  ch->perm_str = 18;
comm.c:  ch->perm_int = 18;
comm.c:  ch->perm_lck = 18;
comm.c:  ch->perm_dex = 18;
comm.c:          && !IS_SET( race_table[iRace]->class_restriction, 1 << ch->Class )
comm.c:         ch->race = iRace;
comm.c:       || IS_SET( race_table[iRace]->class_restriction, 1 << ch->Class )
comm.c:	if (ch->race == 0)
comm.c:   ch->pcdata->hometown = str_dup( "Kroridge" );
comm.c:	if (ch->race == 1)
comm.c:   ch->pcdata->hometown = str_dup( "O'ran Thalore" );
comm.c:	if (ch->race == 2)
comm.c:   ch->pcdata->hometown = str_dup( "Kimlodar" );
comm.c:	if (ch->race == 3)
comm.c:   ch->pcdata->hometown = str_dup( "Shireton" );
comm.c:	if (ch->race == 9)
comm.c:   ch->pcdata->hometown = str_dup( "BeachCastle" );
comm.c:	if (ch->race == 10)
comm.c:   ch->pcdata->hometown = str_dup( "Calmarnock" );
comm.c:	if (ch->race == 11)
comm.c:   ch->pcdata->hometown = str_dup( "Tarnstead" );
comm.c:	if (ch->race == 15)
comm.c:   ch->pcdata->hometown = str_dup( "Dhubrokh" );
comm.c:         xSET_BIT( ch->act, PLR_RIP );
comm.c:         xSET_BIT( ch->act, PLR_ANSI );
comm.c:         xSET_BIT( ch->act, PLR_ANSI );
comm.c:   snprintf( log_buf, MAX_STRING_LENGTH, "%s@%s new %s %s.", ch->name, d->host,
comm.c:             race_table[ch->race]->race_name, class_table[ch->Class]->who_name );
comm.c:   ch->level = 0;
comm.c:   ch->position = POS_STANDING;
comm.c:   if( chk_watch( get_trust( ch ), ch->name, d->host ) ) /*  --Gorog */
comm.c:      SET_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c:      REMOVE_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c:   if( xIS_SET( ch->act, PLR_RIP ) )
comm.c:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c:   if( ch->level == LEVEL_AVATAR )
comm.c:   if( ch->level < LEVEL_AVATAR && ch->level > 0 )
comm.c:   if( ch->level == 0 )
comm.c:   if( ch->level == 0 )
comm.c:      ch->pcdata->clan = NULL;
comm.c:      switch ( class_table[ch->Class]->attr_prime )
comm.c:            ch->perm_str = 16;
comm.c:            ch->perm_int = 16;
comm.c:            ch->perm_wis = 16;
comm.c:            ch->perm_dex = 16;
comm.c:            ch->perm_con = 16;
comm.c:            ch->perm_cha = 16;
comm.c:            ch->perm_lck = 16;
comm.c:      ch->perm_str += race_table[ch->race]->str_plus;
comm.c:      ch->perm_int += race_table[ch->race]->int_plus;
comm.c:      ch->perm_wis += race_table[ch->race]->wis_plus;
comm.c:      ch->perm_dex += race_table[ch->race]->dex_plus;
comm.c:      ch->perm_con += race_table[ch->race]->con_plus;
comm.c:      ch->perm_cha += race_table[ch->race]->cha_plus;
comm.c:      ch->affected_by = race_table[ch->race]->affected;
comm.c:      ch->perm_lck += race_table[ch->race]->lck_plus;
comm.c:      ch->armor += race_table[ch->race]->ac_plus;
comm.c:      ch->alignment += race_table[ch->race]->alignment;
comm.c:      ch->attacks = race_table[ch->race]->attacks;
comm.c:      ch->defenses = race_table[ch->race]->defenses;
comm.c:      ch->saving_poison_death = race_table[ch->race]->saving_poison_death;
comm.c:      ch->saving_wand = race_table[ch->race]->saving_wand;
comm.c:      ch->saving_para_petri = race_table[ch->race]->saving_para_petri;
comm.c:      ch->saving_breath = race_table[ch->race]->saving_breath;
comm.c:      ch->saving_spell_staff = race_table[ch->race]->saving_spell_staff;
comm.c:      ch->height =
comm.c:         number_range( ( int )( race_table[ch->race]->height * .9 ), ( int )( race_table[ch->race]->height * 1.1 ) );
comm.c:      ch->weight =
comm.c:         number_range( ( int )( race_table[ch->race]->weight * .9 ), ( int )( race_table[ch->race]->weight * 1.1 ) );
comm.c:      if( ch->Class == CLASS_PALADIN )
comm.c:         ch->alignment = 1000;
comm.c:         ch->pcdata->learned[iLang] = 100;
comm.c:      if( race_table[ch->race] )
comm.c:            if( IS_SET( race_table[ch->race]->language, 1 << iLang ) )
comm.c:                  ch->pcdata->learned[uLang] = 100;
comm.c:       * ch->resist           += race_table[ch->race]->resist;    drats
comm.c:       * ch->susceptible     += race_table[ch->race]->suscept;    drats
comm.c:      ch->level = 1;
comm.c:      ch->exp = 0;
comm.c:      ch->max_hit += race_table[ch->race]->hit;
comm.c:      ch->max_mana += race_table[ch->race]->mana;
comm.c:      ch->hit = UMAX( 1, ch->max_hit );
comm.c:      ch->mana = UMAX( 1, ch->max_mana );
comm.c:      ch->move = ch->max_move;
comm.c:      ch->gold = 0;
comm.c:      ch->pcdata->day = time_info.day;
comm.c:      ch->pcdata->month = time_info.month;
comm.c:      ch->pcdata->year = time_info.year - 17;
comm.c:      ch->pcdata->age = 17;
comm.c:      ch->pcdata->age_bonus = 0;
comm.c:      snprintf( buf, MAX_STRING_LENGTH, "the %s", title_table[ch->Class][ch->level][ch->sex == SEX_FEMALE ? 1 : 0] );
comm.c:      xSET_BIT( ch->act, PLR_AUTOGOLD );
comm.c:      xSET_BIT( ch->act, PLR_AUTOEXIT );
comm.c:         ch->pcdata->auth_state = 0;
comm.c:         SET_BIT( ch->pcdata->flags, PCFLAG_UNAUTHED );
comm.c:   else if( !IS_IMMORTAL( ch ) && ch->pcdata->release_date > 0 && ch->pcdata->release_date > current_time )
comm.c:      if( ch->in_room->vnum == 6 || ch->in_room->vnum == 8 || ch->in_room->vnum == 1206 )
comm.c:         char_to_room( ch, ch->in_room );
comm.c:   else if( ch->in_room && ( IS_IMMORTAL( ch ) || !xIS_SET( ch->in_room->room_flags, ROOM_PROTOTYPE ) ) )
comm.c:      char_to_room( ch, ch->in_room );
comm.c:   if( ch->pcdata->pet )
comm.c:      act( AT_ACTION, "$n returns to $s master from the Void.", ch->pcdata->pet, NULL, ch, TO_NOTVICT );
comm.c:      act( AT_ACTION, "$N returns with you to the realms.", ch, NULL, ch->pcdata->pet, TO_CHAR );
comm.c:   if( !ch->was_in_room && ch->in_room == get_room_index( ROOM_VNUM_TEMPLE ) )
comm.c:      ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c:   else if( ch->was_in_room == get_room_index( ROOM_VNUM_TEMPLE ) )
comm.c:      ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c:   else if( !ch->was_in_room )
comm.c:      ch->was_in_room = ch->in_room;
comm.c:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c:      log_printf( "Player: %s has deleted.", capitalize( ch->name ) );
comm.c:      do_destroy( ch, ch->name );
comm.c:   for( ch = first_char; ch; ch = ch->next )
comm.c:      if( !IS_NPC( ch ) && ( !fConn || !ch->desc ) && ch->pcdata->filename && !str_cmp( name, ch->pcdata->filename ) )
comm.c:         if( fConn && ch->switched )
comm.c:            d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c:            ch->desc = d;
comm.c:            ch->timer = 0;
comm.c:               ch->pcdata->recent_site = STRALLOC( d->host );
comm.c:            log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s (%s) reconnected.", ch->name, d->host );
comm.c:         if( !ch->name || ( cstate != CON_PLAYING && cstate != CON_EDITING && cstate != CON_DELETE ) )
comm.c:            log_printf_plus( LOG_COMM, sysdata.log_level, "%s already connected.", ch->pcdata->filename );
comm.c:         ch->desc = d;
comm.c:         ch->timer = 0;
comm.c:         if( ch->switched )
comm.c:            do_return( ch->switched, "" );
comm.c:         ch->switched = NULL;
comm.c:            ch->pcdata->recent_site = STRALLOC( d->host );
comm.c:         log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s@%s reconnected, kicking off old link.",
comm.c:                          ch->pcdata->filename, d->host );
comm.c:   if( !ch || !ch->desc || ch->desc->connected != CON_PLAYING || !IS_IDLE( ch ) )
comm.c:   ch->timer = 0;
comm.c:   was_in_room = ch->was_in_room;
comm.c:   ch->was_in_room = ch->in_room;
comm.c:    * ch->was_in_room  = NULL;
comm.c:   REMOVE_BIT( ch->pcdata->flags, PCFLAG_IDLE );
comm.c:#define NAME(ch)        ( IS_NPC(ch) ? ch->short_descr : ch->name )
comm.c:   if( ch->morph && ch->morph->morph && ch->morph->morph->short_desc != NULL )
comm.c:      return ch->morph->morph->short_desc;
comm.c:               if( ch->sex > 2 || ch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c:                   !can_see( to, ch ) ? "It" : capitalize( he_she[URANGE( 0, ch->sex, 2 )] ) :
comm.c:                   !can_see( to, ch ) ? "it" : he_she[URANGE( 0, ch->sex, 2 )];
comm.c:               if( vch->sex > 2 || vch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c:                   !can_see( to, vch ) ? "It" : capitalize( he_she[URANGE( 0, vch->sex, 2 )] ) :
comm.c:                   !can_see( to, vch ) ? "it" : he_she[URANGE( 0, vch->sex, 2 )];
comm.c:               if( ch->sex > 2 || ch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c:                   !can_see( to, ch ) ? "It" : capitalize( him_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c:                   !can_see( to, ch ) ? "it" : him_her[URANGE( 0, ch->sex, 2 )];
comm.c:               if( vch->sex > 2 || vch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c:                   !can_see( to, vch ) ? "It" : capitalize( him_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c:                   !can_see( to, vch ) ? "it" : him_her[URANGE( 0, vch->sex, 2 )];
comm.c:               i = ( to == ch ) ? "your" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c:               if( ch->sex > 2 || ch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c:                   !can_see( to, ch ) ? "It" : capitalize( his_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c:                   !can_see( to, ch ) ? "it" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c:               if( vch->sex > 2 || vch->sex < 0 )
comm.c:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c:                   !can_see( to, vch ) ? "It" : capitalize( his_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c:                   !can_see( to, vch ) ? "it" : his_her[URANGE( 0, vch->sex, 2 )];
comm.c:   if( !ch->in_room )
comm.c:      to = ch->in_room->first_person;
comm.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_SECRETIVE ) && type != TO_CHAR )
comm.c:         bug( "%s (%s)", ch->name, format );
comm.c:      if( !vch->in_room )
comm.c:         bug( "%s -> %s (%s)", ch->name, vch->name, format );
comm.c:         || ( !IS_NPC(ch) && (xIS_SET(ch->act, PLR_WIZINVIS)
comm.c:         && ( get_trust(to) < ( ch->pcdata ? ch->pcdata->wizinvis : 0 ) ) ) ) ) )
comm.c:   if( !NOT_AUTHED( ch ) || ch->pcdata->auth_state != 2 )
comm.c:   if( check_playing( ch->desc, argument, FALSE ) == BERR )
comm.c:   if( !str_cmp( ch->name, ucase_argument ) )
comm.c:   STRFREE( ch->name );
comm.c:   ch->name = STRALLOC( ucase_argument );
comm.c:   STRFREE( ch->pcdata->filename );
comm.c:   ch->pcdata->filename = STRALLOC( ucase_argument );
comm.c:   ch->pcdata->auth_state = 0;
comm.c:   if( ch->fighting != NULL )
comm.c:      ch_printf( ch, "Consider this carefuly %s, if you delete, you will not\r\nbe reinstated as an immortal!\r\n", ch->name );
comm.c:   write_to_buffer( ch->desc, (const char *)echo_off_str, 0 );
comm.c:   ch->desc->connected = CON_DELETE;
comm.c:   bool ansi = ( !IS_NPC( och ) && xIS_SET( och->act, PLR_ANSI ) );
comm.c:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_HELPSTART ) )
comm.c:   else if( !IS_NPC( ch ) && ch->substate != SUB_NONE && ch->pcdata->subprompt && ch->pcdata->subprompt[0] != '\0' )
comm.c:      prompt = ch->pcdata->subprompt;
comm.c:   else if( IS_NPC( ch ) || ( !ch->fighting && ( !ch->pcdata->prompt || !*ch->pcdata->prompt ) ) )
comm.c:   else if( ch->fighting )
comm.c:      if( !ch->pcdata->fprompt || !*ch->pcdata->fprompt )
comm.c:         prompt = ch->pcdata->fprompt;
comm.c:      prompt = ch->pcdata->prompt;
comm.c:                  if( ch->level >= 10 )
comm.c:                     pstat = ch->alignment;
comm.c:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c:                  pstat = ch->hit;
comm.c:                  pstat = ch->max_hit;
comm.c:                     pstat = ch->mana;
comm.c:                     pstat = ch->max_mana;
comm.c:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c:                     pstat = ch->pcdata->condition[COND_BLOODTHIRST];
comm.c:                     pstat = ch->level + 10;
comm.c:                  pstat = ch->move;
comm.c:                  pstat = ch->max_move;
comm.c:                  pstat = ch->gold;
comm.c:                     pstat = ch->in_room->vnum;
comm.c:                     snprintf( pbuf, MAX_STRING_LENGTH, "%s", ext_flag_string( &ch->in_room->room_flags, r_flags ) );
comm.c:                  if( xIS_SET( och->act, PLR_ROOMVNUM ) )
comm.c:                     snprintf( pbuf, MAX_STRING_LENGTH, "<#%d> ", ch->in_room->vnum );
comm.c:                     if( IS_SET( ch->pcdata->flags, PCFLAG_DND ) )
comm.c:                  pstat = ch->exp;
comm.c:                  pstat = exp_level( ch, ch->level + 1 ) - ch->exp;
comm.c:                  pstat = ch->carry_weight;
comm.c:                  if( ch->style == STYLE_BERSERK )
comm.c:                  else if( ch->style == STYLE_AGGRESSIVE )
comm.c:                  else if( ch->style == STYLE_DEFENSIVE )
comm.c:                  else if( ch->style == STYLE_EVASIVE )
comm.c:                  if( ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_WIZINVIS ) ) ||
comm.c:                      ( IS_NPC( ch ) && xIS_SET( ch->act, ACT_MOBINVIS ) ) )
comm.c:                               ( IS_NPC( ch ) ? ch->mobinvis : ch->pcdata->wizinvis ) );
comm.c:                  pstat = ( IS_NPC( ch ) ? ( xIS_SET( ch->act, ACT_MOBINVIS ) ? ch->mobinvis : 0 )
comm.c:                            : ( xIS_SET( ch->act, PLR_WIZINVIS ) ? ch->pcdata->wizinvis : 0 ) );
comm.c:   pclines = UMAX( ch->pcdata->pagerlen, 5 ) - 1;
comm.c:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.backup:  for ( ch = first_char; ch; ch = ch->next )
comm.c.backup:    log_printf( "%cPC: %-20s room: %d", IS_NPC(ch) ? 'N' : ' ', ch->name, ch->in_room->vnum );
comm.c.backup:           ch ? ch->name : d->host, ( void * )dclose, ( void * )first_descriptor );
comm.c.backup:            bug( "%s: %s desc:%p found, prev should be:%p, fixing.", __func__, ch ? ch->name : d->host, ( void * )dclose,
comm.c.backup:         bug( "%s: %s desc:%p could not be found!.", __func__, ch ? ch->name : dclose->host, ( void * )dclose );
comm.c.backup:           ch ? ch->name : d->host, ( void * )dclose, ( void * )last_descriptor );
comm.c.backup:            bug( "%s: %s desc:%p found, next should be:%p, fixing.", __func__, ch ? ch->name : d->host, ( void * )dclose,
comm.c.backup:         bug( "%s: %s desc:%p could not be found!.", __func__, ch ? ch->name : dclose->host, ( void * )dclose );
comm.c.backup:      log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "Closing link to %s. (INRoom %d)", ch->pcdata->filename, ( ch->in_room ? ch->in_room->vnum : -1 ) );
comm.c.backup:         if( ch->last_cmd )
comm.c.backup:            ch->last_cmd( ch, "" );
comm.c.backup:         ch->desc = NULL;
comm.c.backup:      if( xIS_SET( ch->act, PLR_BLANK ) )
comm.c.backup:      if( xIS_SET( ch->act, PLR_PROMPT ) )
comm.c.backup:      if( ch && !IS_NPC( ch ) && xIS_SET( ch->act, PLR_ANSI ) )
comm.c.backup:      if( xIS_SET( ch->act, PLR_TELNET_GA ) )
comm.c.backup:   if( !IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO ) )
comm.c.backup:      if( xIS_SET( ch->act, PLR_RIP ) )
comm.c.backup:      else if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.backup:   if( xIS_SET( ch->act, PLR_DENY ) )
comm.c.backup:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c.backup:   if( check_playing( d, ch->pcdata->filename, TRUE ) )
comm.c.backup:chk = check_reconnect( d, ch->pcdata->filename, TRUE );
comm.c.backup:   mudstrlcpy( buf, ch->pcdata->filename, MAX_STRING_LENGTH );
comm.c.backup:   if( ch->position == POS_FIGHTING
comm.c.backup:       || ch->position == POS_EVASIVE
comm.c.backup:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
comm.c.backup:      ch->position = POS_STANDING;
comm.c.backup:   log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s (%s) has connected.", ch->name, d->host );
comm.c.backup:                   "\r\nPick a good password for %s: %s", ch->name, echo_off_str );
comm.c.backup:   DISPOSE( ch->pcdata->pwd );
comm.c.backup:   ch->pcdata->pwd = str_dup( pwdnew );
comm.c.backup:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c.backup:         ch->sex = SEX_MALE;
comm.c.backup:         ch->sex = SEX_FEMALE;
comm.c.backup:            ch->Class = iClass;
comm.c.backup:   ch->Class = 6;
comm.c.backup:   ch->pcdata->customclass = str_dup( "Adventurer" );
comm.c.backup:          && !IS_SET( race_table[iRace]->class_restriction, 1 << ch->Class )
comm.c.backup:         ch->race = iRace;
comm.c.backup:       || IS_SET( race_table[iRace]->class_restriction, 1 << ch->Class )
comm.c.backup:         xSET_BIT( ch->act, PLR_RIP );
comm.c.backup:         xSET_BIT( ch->act, PLR_ANSI );
comm.c.backup:         xSET_BIT( ch->act, PLR_ANSI );
comm.c.backup:   snprintf( log_buf, MAX_STRING_LENGTH, "%s@%s new %s %s.", ch->name, d->host,
comm.c.backup:             race_table[ch->race]->race_name, class_table[ch->Class]->who_name );
comm.c.backup:   ch->level = 0;
comm.c.backup:   ch->position = POS_STANDING;
comm.c.backup:   if( chk_watch( get_trust( ch ), ch->name, d->host ) ) /*  --Gorog */
comm.c.backup:      SET_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c.backup:      REMOVE_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c.backup:   if( xIS_SET( ch->act, PLR_RIP ) )
comm.c.backup:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.backup:   if( ch->level == LEVEL_AVATAR )
comm.c.backup:   if( ch->level < LEVEL_AVATAR && ch->level > 0 )
comm.c.backup:   if( ch->level == 0 )
comm.c.backup:   if( ch->level == 0 )
comm.c.backup:      ch->pcdata->clan = NULL;
comm.c.backup:      switch ( class_table[ch->Class]->attr_prime )
comm.c.backup:            ch->perm_str = 16;
comm.c.backup:            ch->perm_int = 16;
comm.c.backup:            ch->perm_wis = 16;
comm.c.backup:            ch->perm_dex = 16;
comm.c.backup:            ch->perm_con = 16;
comm.c.backup:            ch->perm_cha = 16;
comm.c.backup:            ch->perm_lck = 16;
comm.c.backup:      ch->perm_str += race_table[ch->race]->str_plus;
comm.c.backup:      ch->perm_int += race_table[ch->race]->int_plus;
comm.c.backup:      ch->perm_wis += race_table[ch->race]->wis_plus;
comm.c.backup:      ch->perm_dex += race_table[ch->race]->dex_plus;
comm.c.backup:      ch->perm_con += race_table[ch->race]->con_plus;
comm.c.backup:      ch->perm_cha += race_table[ch->race]->cha_plus;
comm.c.backup:      ch->affected_by = race_table[ch->race]->affected;
comm.c.backup:      ch->perm_lck += race_table[ch->race]->lck_plus;
comm.c.backup:      ch->armor += race_table[ch->race]->ac_plus;
comm.c.backup:      ch->alignment += race_table[ch->race]->alignment;
comm.c.backup:      ch->attacks = race_table[ch->race]->attacks;
comm.c.backup:      ch->defenses = race_table[ch->race]->defenses;
comm.c.backup:      ch->saving_poison_death = race_table[ch->race]->saving_poison_death;
comm.c.backup:      ch->saving_wand = race_table[ch->race]->saving_wand;
comm.c.backup:      ch->saving_para_petri = race_table[ch->race]->saving_para_petri;
comm.c.backup:      ch->saving_breath = race_table[ch->race]->saving_breath;
comm.c.backup:      ch->saving_spell_staff = race_table[ch->race]->saving_spell_staff;
comm.c.backup:      ch->height =
comm.c.backup:         number_range( ( int )( race_table[ch->race]->height * .9 ), ( int )( race_table[ch->race]->height * 1.1 ) );
comm.c.backup:      ch->weight =
comm.c.backup:         number_range( ( int )( race_table[ch->race]->weight * .9 ), ( int )( race_table[ch->race]->weight * 1.1 ) );
comm.c.backup:      if( ch->Class == CLASS_PALADIN )
comm.c.backup:         ch->alignment = 1000;
comm.c.backup:         ch->pcdata->learned[iLang] = 100;
comm.c.backup:      if( race_table[ch->race] )
comm.c.backup:            if( IS_SET( race_table[ch->race]->language, 1 << iLang ) )
comm.c.backup:                  ch->pcdata->learned[uLang] = 100;
comm.c.backup:       * ch->resist           += race_table[ch->race]->resist;    drats
comm.c.backup:       * ch->susceptible     += race_table[ch->race]->suscept;    drats
comm.c.backup:      ch->level = 1;
comm.c.backup:      ch->exp = 0;
comm.c.backup:      ch->max_hit += race_table[ch->race]->hit;
comm.c.backup:      ch->max_mana += race_table[ch->race]->mana;
comm.c.backup:      ch->hit = UMAX( 1, ch->max_hit );
comm.c.backup:      ch->mana = UMAX( 1, ch->max_mana );
comm.c.backup:      ch->move = ch->max_move;
comm.c.backup:      ch->gold = 0;
comm.c.backup:      ch->pcdata->day = time_info.day;
comm.c.backup:      ch->pcdata->month = time_info.month;
comm.c.backup:      ch->pcdata->year = time_info.year - 17;
comm.c.backup:      ch->pcdata->age = 17;
comm.c.backup:      ch->pcdata->age_bonus = 0;
comm.c.backup:      snprintf( buf, MAX_STRING_LENGTH, "the %s", title_table[ch->Class][ch->level][ch->sex == SEX_FEMALE ? 1 : 0] );
comm.c.backup:      xSET_BIT( ch->act, PLR_AUTOGOLD );
comm.c.backup:      xSET_BIT( ch->act, PLR_AUTOEXIT );
comm.c.backup:         ch->pcdata->auth_state = 0;
comm.c.backup:         SET_BIT( ch->pcdata->flags, PCFLAG_UNAUTHED );
comm.c.backup:   else if( !IS_IMMORTAL( ch ) && ch->pcdata->release_date > 0 && ch->pcdata->release_date > current_time )
comm.c.backup:      if( ch->in_room->vnum == 6 || ch->in_room->vnum == 8 || ch->in_room->vnum == 1206 )
comm.c.backup:         char_to_room( ch, ch->in_room );
comm.c.backup:   else if( ch->in_room && ( IS_IMMORTAL( ch ) || !xIS_SET( ch->in_room->room_flags, ROOM_PROTOTYPE ) ) )
comm.c.backup:      char_to_room( ch, ch->in_room );
comm.c.backup:   if( ch->pcdata->pet )
comm.c.backup:      act( AT_ACTION, "$n returns to $s master from the Void.", ch->pcdata->pet, NULL, ch, TO_NOTVICT );
comm.c.backup:      act( AT_ACTION, "$N returns with you to the realms.", ch, NULL, ch->pcdata->pet, TO_CHAR );
comm.c.backup:   if( !ch->was_in_room && ch->in_room == get_room_index( ROOM_VNUM_TEMPLE ) )
comm.c.backup:      ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c.backup:   else if( ch->was_in_room == get_room_index( ROOM_VNUM_TEMPLE ) )
comm.c.backup:      ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c.backup:   else if( !ch->was_in_room )
comm.c.backup:      ch->was_in_room = ch->in_room;
comm.c.backup:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c.backup:      log_printf( "Player: %s has deleted.", capitalize( ch->name ) );
comm.c.backup:      do_destroy( ch, ch->name );
comm.c.backup:   for( ch = first_char; ch; ch = ch->next )
comm.c.backup:      if( !IS_NPC( ch ) && ( !fConn || !ch->desc ) && ch->pcdata->filename && !str_cmp( name, ch->pcdata->filename ) )
comm.c.backup:         if( fConn && ch->switched )
comm.c.backup:            d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c.backup:            ch->desc = d;
comm.c.backup:            ch->timer = 0;
comm.c.backup:               ch->pcdata->recent_site = STRALLOC( d->host );
comm.c.backup:            log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s (%s) reconnected.", ch->name, d->host );
comm.c.backup:         if( !ch->name || ( cstate != CON_PLAYING && cstate != CON_EDITING && cstate != CON_DELETE ) )
comm.c.backup:            log_printf_plus( LOG_COMM, sysdata.log_level, "%s already connected.", ch->pcdata->filename );
comm.c.backup:         ch->desc = d;
comm.c.backup:         ch->timer = 0;
comm.c.backup:         if( ch->switched )
comm.c.backup:            do_return( ch->switched, "" );
comm.c.backup:         ch->switched = NULL;
comm.c.backup:            ch->pcdata->recent_site = STRALLOC( d->host );
comm.c.backup:         log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s@%s reconnected, kicking off old link.",
comm.c.backup:                          ch->pcdata->filename, d->host );
comm.c.backup:   if( !ch || !ch->desc || ch->desc->connected != CON_PLAYING || !IS_IDLE( ch ) )
comm.c.backup:   ch->timer = 0;
comm.c.backup:   was_in_room = ch->was_in_room;
comm.c.backup:   ch->was_in_room = ch->in_room;
comm.c.backup:    * ch->was_in_room  = NULL;
comm.c.backup:   REMOVE_BIT( ch->pcdata->flags, PCFLAG_IDLE );
comm.c.backup:#define NAME(ch)        ( IS_NPC(ch) ? ch->short_descr : ch->name )
comm.c.backup:   if( ch->morph && ch->morph->morph && ch->morph->morph->short_desc != NULL )
comm.c.backup:      return ch->morph->morph->short_desc;
comm.c.backup:               if( ch->sex > 2 || ch->sex < 0 )
comm.c.backup:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c.backup:                   !can_see( to, ch ) ? "It" : capitalize( he_she[URANGE( 0, ch->sex, 2 )] ) :
comm.c.backup:                   !can_see( to, ch ) ? "it" : he_she[URANGE( 0, ch->sex, 2 )];
comm.c.backup:               if( vch->sex > 2 || vch->sex < 0 )
comm.c.backup:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c.backup:                   !can_see( to, vch ) ? "It" : capitalize( he_she[URANGE( 0, vch->sex, 2 )] ) :
comm.c.backup:                   !can_see( to, vch ) ? "it" : he_she[URANGE( 0, vch->sex, 2 )];
comm.c.backup:               if( ch->sex > 2 || ch->sex < 0 )
comm.c.backup:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c.backup:                   !can_see( to, ch ) ? "It" : capitalize( him_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c.backup:                   !can_see( to, ch ) ? "it" : him_her[URANGE( 0, ch->sex, 2 )];
comm.c.backup:               if( vch->sex > 2 || vch->sex < 0 )
comm.c.backup:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c.backup:                   !can_see( to, vch ) ? "It" : capitalize( him_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c.backup:                   !can_see( to, vch ) ? "it" : him_her[URANGE( 0, vch->sex, 2 )];
comm.c.backup:               i = ( to == ch ) ? "your" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c.backup:               if( ch->sex > 2 || ch->sex < 0 )
comm.c.backup:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c.backup:                   !can_see( to, ch ) ? "It" : capitalize( his_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c.backup:                   !can_see( to, ch ) ? "it" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c.backup:               if( vch->sex > 2 || vch->sex < 0 )
comm.c.backup:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c.backup:                   !can_see( to, vch ) ? "It" : capitalize( his_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c.backup:                   !can_see( to, vch ) ? "it" : his_her[URANGE( 0, vch->sex, 2 )];
comm.c.backup:   if( !ch->in_room )
comm.c.backup:      to = ch->in_room->first_person;
comm.c.backup:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_SECRETIVE ) && type != TO_CHAR )
comm.c.backup:         bug( "%s (%s)", ch->name, format );
comm.c.backup:      if( !vch->in_room )
comm.c.backup:         bug( "%s -> %s (%s)", ch->name, vch->name, format );
comm.c.backup:         || ( !IS_NPC(ch) && (xIS_SET(ch->act, PLR_WIZINVIS)
comm.c.backup:         && ( get_trust(to) < ( ch->pcdata ? ch->pcdata->wizinvis : 0 ) ) ) ) ) )
comm.c.backup:   if( !NOT_AUTHED( ch ) || ch->pcdata->auth_state != 2 )
comm.c.backup:   if( check_playing( ch->desc, argument, FALSE ) == BERR )
comm.c.backup:   if( !str_cmp( ch->name, ucase_argument ) )
comm.c.backup:   STRFREE( ch->name );
comm.c.backup:   ch->name = STRALLOC( ucase_argument );
comm.c.backup:   STRFREE( ch->pcdata->filename );
comm.c.backup:   ch->pcdata->filename = STRALLOC( ucase_argument );
comm.c.backup:   ch->pcdata->auth_state = 0;
comm.c.backup:   if( ch->fighting != NULL )
comm.c.backup:      ch_printf( ch, "Consider this carefuly %s, if you delete, you will not\r\nbe reinstated as an immortal!\r\n", ch->name );
comm.c.backup:   write_to_buffer( ch->desc, (const char *)echo_off_str, 0 );
comm.c.backup:   ch->desc->connected = CON_DELETE;
comm.c.backup:   bool ansi = ( !IS_NPC( och ) && xIS_SET( och->act, PLR_ANSI ) );
comm.c.backup:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_HELPSTART ) )
comm.c.backup:   else if( !IS_NPC( ch ) && ch->substate != SUB_NONE && ch->pcdata->subprompt && ch->pcdata->subprompt[0] != '\0' )
comm.c.backup:      prompt = ch->pcdata->subprompt;
comm.c.backup:   else if( IS_NPC( ch ) || ( !ch->fighting && ( !ch->pcdata->prompt || !*ch->pcdata->prompt ) ) )
comm.c.backup:   else if( ch->fighting )
comm.c.backup:      if( !ch->pcdata->fprompt || !*ch->pcdata->fprompt )
comm.c.backup:         prompt = ch->pcdata->fprompt;
comm.c.backup:      prompt = ch->pcdata->prompt;
comm.c.backup:                  if( ch->level >= 10 )
comm.c.backup:                     pstat = ch->alignment;
comm.c.backup:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.backup:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.backup:                  pstat = ch->hit;
comm.c.backup:                  pstat = ch->max_hit;
comm.c.backup:                     pstat = ch->mana;
comm.c.backup:                     pstat = ch->max_mana;
comm.c.backup:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.backup:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.backup:                     pstat = ch->pcdata->condition[COND_BLOODTHIRST];
comm.c.backup:                     pstat = ch->level + 10;
comm.c.backup:                  pstat = ch->move;
comm.c.backup:                  pstat = ch->max_move;
comm.c.backup:                  pstat = ch->gold;
comm.c.backup:                     pstat = ch->in_room->vnum;
comm.c.backup:                     snprintf( pbuf, MAX_STRING_LENGTH, "%s", ext_flag_string( &ch->in_room->room_flags, r_flags ) );
comm.c.backup:                  if( xIS_SET( och->act, PLR_ROOMVNUM ) )
comm.c.backup:                     snprintf( pbuf, MAX_STRING_LENGTH, "<#%d> ", ch->in_room->vnum );
comm.c.backup:                     if( IS_SET( ch->pcdata->flags, PCFLAG_DND ) )
comm.c.backup:                  pstat = ch->exp;
comm.c.backup:                  pstat = exp_level( ch, ch->level + 1 ) - ch->exp;
comm.c.backup:                  pstat = ch->carry_weight;
comm.c.backup:                  if( ch->style == STYLE_BERSERK )
comm.c.backup:                  else if( ch->style == STYLE_AGGRESSIVE )
comm.c.backup:                  else if( ch->style == STYLE_DEFENSIVE )
comm.c.backup:                  else if( ch->style == STYLE_EVASIVE )
comm.c.backup:                  if( ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_WIZINVIS ) ) ||
comm.c.backup:                      ( IS_NPC( ch ) && xIS_SET( ch->act, ACT_MOBINVIS ) ) )
comm.c.backup:                               ( IS_NPC( ch ) ? ch->mobinvis : ch->pcdata->wizinvis ) );
comm.c.backup:                  pstat = ( IS_NPC( ch ) ? ( xIS_SET( ch->act, ACT_MOBINVIS ) ? ch->mobinvis : 0 )
comm.c.backup:                            : ( xIS_SET( ch->act, PLR_WIZINVIS ) ? ch->pcdata->wizinvis : 0 ) );
comm.c.backup:   pclines = UMAX( ch->pcdata->pagerlen, 5 ) - 1;
comm.c.backup:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.backup:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.bak:  for ( ch = first_char; ch; ch = ch->next )
comm.c.bak:    log_printf( "%cPC: %-20s room: %d", IS_NPC(ch) ? 'N' : ' ', ch->name, ch->in_room->vnum );
comm.c.bak:           ch ? ch->name : d->host, ( void * )dclose, ( void * )first_descriptor );
comm.c.bak:            bug( "%s: %s desc:%p found, prev should be:%p, fixing.", __func__, ch ? ch->name : d->host, ( void * )dclose,
comm.c.bak:         bug( "%s: %s desc:%p could not be found!.", __func__, ch ? ch->name : dclose->host, ( void * )dclose );
comm.c.bak:           ch ? ch->name : d->host, ( void * )dclose, ( void * )last_descriptor );
comm.c.bak:            bug( "%s: %s desc:%p found, next should be:%p, fixing.", __func__, ch ? ch->name : d->host, ( void * )dclose,
comm.c.bak:         bug( "%s: %s desc:%p could not be found!.", __func__, ch ? ch->name : dclose->host, ( void * )dclose );
comm.c.bak:      log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "Closing link to %s. (INRoom %d)", ch->pcdata->filename, ( ch->in_room ? ch->in_room->vnum : -1 ) );
comm.c.bak:         if( ch->last_cmd )
comm.c.bak:            ch->last_cmd( ch, "" );
comm.c.bak:         ch->desc = NULL;
comm.c.bak:      if( xIS_SET( ch->act, PLR_BLANK ) )
comm.c.bak:      if( xIS_SET( ch->act, PLR_PROMPT ) )
comm.c.bak:      if( ch && !IS_NPC( ch ) && xIS_SET( ch->act, PLR_ANSI ) )
comm.c.bak:      if( xIS_SET( ch->act, PLR_TELNET_GA ) )
comm.c.bak:   if( !IS_SET( ch->pcdata->flags, PCFLAG_NOINTRO ) )
comm.c.bak:      if( xIS_SET( ch->act, PLR_RIP ) )
comm.c.bak:      else if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.bak:   if( xIS_SET( ch->act, PLR_DENY ) )
comm.c.bak:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c.bak:   if( check_playing( d, ch->pcdata->filename, TRUE ) )
comm.c.bak:chk = check_reconnect( d, ch->pcdata->filename, TRUE );
comm.c.bak:   mudstrlcpy( buf, ch->pcdata->filename, MAX_STRING_LENGTH );
comm.c.bak:   if( ch->position == POS_FIGHTING
comm.c.bak:       || ch->position == POS_EVASIVE
comm.c.bak:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
comm.c.bak:      ch->position = POS_STANDING;
comm.c.bak:   log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s (%s) has connected.", ch->name, d->host );
comm.c.bak:                   "\r\nPick a good password for %s: %s", ch->name, echo_off_str );
comm.c.bak:   DISPOSE( ch->pcdata->pwd );
comm.c.bak:   ch->pcdata->pwd = str_dup( pwdnew );
comm.c.bak:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c.bak:         ch->sex = SEX_MALE;
comm.c.bak:         ch->sex = SEX_FEMALE;
comm.c.bak:            ch->Class = iClass;
comm.c.bak:   ch->Class = 6;
comm.c.bak:   ch->pcdata->customclass = str_dup( "Adventurer" );
comm.c.bak:          && !IS_SET( race_table[iRace]->class_restriction, 1 << ch->Class )
comm.c.bak:         ch->race = iRace;
comm.c.bak:       || IS_SET( race_table[iRace]->class_restriction, 1 << ch->Class )
comm.c.bak:        ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex, ch->perm_con, 
comm.c.bak:	  ch->perm_cha, ch->perm_lck );
comm.c.bak:         xSET_BIT( ch->act, PLR_RIP );
comm.c.bak:         xSET_BIT( ch->act, PLR_ANSI );
comm.c.bak:         xSET_BIT( ch->act, PLR_ANSI );
comm.c.bak:   snprintf( log_buf, MAX_STRING_LENGTH, "%s@%s new %s %s.", ch->name, d->host,
comm.c.bak:             race_table[ch->race]->race_name, class_table[ch->Class]->who_name );
comm.c.bak:   ch->level = 0;
comm.c.bak:   ch->position = POS_STANDING;
comm.c.bak:   if( chk_watch( get_trust( ch ), ch->name, d->host ) ) /*  --Gorog */
comm.c.bak:      SET_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c.bak:      REMOVE_BIT( ch->pcdata->flags, PCFLAG_WATCH );
comm.c.bak:   if( xIS_SET( ch->act, PLR_RIP ) )
comm.c.bak:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.bak:   if( ch->level == LEVEL_AVATAR )
comm.c.bak:   if( ch->level < LEVEL_AVATAR && ch->level > 0 )
comm.c.bak:   if( ch->level == 0 )
comm.c.bak:   if( ch->level == 0 )
comm.c.bak:      ch->pcdata->clan = NULL;
comm.c.bak:      switch ( class_table[ch->Class]->attr_prime )
comm.c.bak:            ch->perm_str = 16;
comm.c.bak:            ch->perm_int = 16;
comm.c.bak:            ch->perm_wis = 16;
comm.c.bak:            ch->perm_dex = 16;
comm.c.bak:            ch->perm_con = 16;
comm.c.bak:            ch->perm_cha = 16;
comm.c.bak:            ch->perm_lck = 16;
comm.c.bak:      ch->perm_str += race_table[ch->race]->str_plus;
comm.c.bak:      ch->perm_int += race_table[ch->race]->int_plus;
comm.c.bak:      ch->perm_wis += race_table[ch->race]->wis_plus;
comm.c.bak:      ch->perm_dex += race_table[ch->race]->dex_plus;
comm.c.bak:      ch->perm_con += race_table[ch->race]->con_plus;
comm.c.bak:      ch->perm_cha += race_table[ch->race]->cha_plus;
comm.c.bak:      ch->affected_by = race_table[ch->race]->affected;
comm.c.bak:      ch->perm_lck += race_table[ch->race]->lck_plus;
comm.c.bak:      ch->armor += race_table[ch->race]->ac_plus;
comm.c.bak:      ch->alignment += race_table[ch->race]->alignment;
comm.c.bak:      ch->attacks = race_table[ch->race]->attacks;
comm.c.bak:      ch->defenses = race_table[ch->race]->defenses;
comm.c.bak:      ch->saving_poison_death = race_table[ch->race]->saving_poison_death;
comm.c.bak:      ch->saving_wand = race_table[ch->race]->saving_wand;
comm.c.bak:      ch->saving_para_petri = race_table[ch->race]->saving_para_petri;
comm.c.bak:      ch->saving_breath = race_table[ch->race]->saving_breath;
comm.c.bak:      ch->saving_spell_staff = race_table[ch->race]->saving_spell_staff;
comm.c.bak:      ch->height =
comm.c.bak:         number_range( ( int )( race_table[ch->race]->height * .9 ), ( int )( race_table[ch->race]->height * 1.1 ) );
comm.c.bak:      ch->weight =
comm.c.bak:         number_range( ( int )( race_table[ch->race]->weight * .9 ), ( int )( race_table[ch->race]->weight * 1.1 ) );
comm.c.bak:      if( ch->Class == CLASS_PALADIN )
comm.c.bak:         ch->alignment = 1000;
comm.c.bak:         ch->pcdata->learned[iLang] = 100;
comm.c.bak:      if( race_table[ch->race] )
comm.c.bak:            if( IS_SET( race_table[ch->race]->language, 1 << iLang ) )
comm.c.bak:                  ch->pcdata->learned[uLang] = 100;
comm.c.bak:       * ch->resist           += race_table[ch->race]->resist;    drats
comm.c.bak:       * ch->susceptible     += race_table[ch->race]->suscept;    drats
comm.c.bak:      ch->level = 1;
comm.c.bak:      ch->exp = 0;
comm.c.bak:      ch->max_hit += race_table[ch->race]->hit;
comm.c.bak:      ch->max_mana += race_table[ch->race]->mana;
comm.c.bak:      ch->hit = UMAX( 1, ch->max_hit );
comm.c.bak:      ch->mana = UMAX( 1, ch->max_mana );
comm.c.bak:      ch->move = ch->max_move;
comm.c.bak:      ch->gold = 0;
comm.c.bak:      ch->pcdata->day = time_info.day;
comm.c.bak:      ch->pcdata->month = time_info.month;
comm.c.bak:      ch->pcdata->year = time_info.year - 17;
comm.c.bak:      ch->pcdata->age = 17;
comm.c.bak:      ch->pcdata->age_bonus = 0;
comm.c.bak:      snprintf( buf, MAX_STRING_LENGTH, "the %s", title_table[ch->Class][ch->level][ch->sex == SEX_FEMALE ? 1 : 0] );
comm.c.bak:      xSET_BIT( ch->act, PLR_AUTOGOLD );
comm.c.bak:      xSET_BIT( ch->act, PLR_AUTOEXIT );
comm.c.bak:         ch->pcdata->auth_state = 0;
comm.c.bak:         SET_BIT( ch->pcdata->flags, PCFLAG_UNAUTHED );
comm.c.bak:   else if( !IS_IMMORTAL( ch ) && ch->pcdata->release_date > 0 && ch->pcdata->release_date > current_time )
comm.c.bak:      if( ch->in_room->vnum == 6 || ch->in_room->vnum == 8 || ch->in_room->vnum == 1206 )
comm.c.bak:         char_to_room( ch, ch->in_room );
comm.c.bak:   else if( ch->in_room && ( IS_IMMORTAL( ch ) || !xIS_SET( ch->in_room->room_flags, ROOM_PROTOTYPE ) ) )
comm.c.bak:      char_to_room( ch, ch->in_room );
comm.c.bak:   if( ch->pcdata->pet )
comm.c.bak:      act( AT_ACTION, "$n returns to $s master from the Void.", ch->pcdata->pet, NULL, ch, TO_NOTVICT );
comm.c.bak:      act( AT_ACTION, "$N returns with you to the realms.", ch, NULL, ch->pcdata->pet, TO_CHAR );
comm.c.bak:   if( !ch->was_in_room && ch->in_room == get_room_index( ROOM_VNUM_TEMPLE ) )
comm.c.bak:      ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c.bak:   else if( ch->was_in_room == get_room_index( ROOM_VNUM_TEMPLE ) )
comm.c.bak:      ch->was_in_room = get_room_index( ROOM_VNUM_TEMPLE );
comm.c.bak:   else if( !ch->was_in_room )
comm.c.bak:      ch->was_in_room = ch->in_room;
comm.c.bak:   if( str_cmp( sha256_crypt( argument ), ch->pcdata->pwd ) )
comm.c.bak:      log_printf( "Player: %s has deleted.", capitalize( ch->name ) );
comm.c.bak:      do_destroy( ch, ch->name );
comm.c.bak:         ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex, ch->perm_con, 
comm.c.bak:	   ch->perm_cha, ch->perm_lck );
comm.c.bak:   for( ch = first_char; ch; ch = ch->next )
comm.c.bak:      if( !IS_NPC( ch ) && ( !fConn || !ch->desc ) && ch->pcdata->filename && !str_cmp( name, ch->pcdata->filename ) )
comm.c.bak:         if( fConn && ch->switched )
comm.c.bak:            d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c.bak:            ch->desc = d;
comm.c.bak:            ch->timer = 0;
comm.c.bak:               ch->pcdata->recent_site = STRALLOC( d->host );
comm.c.bak:            log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s (%s) reconnected.", ch->name, d->host );
comm.c.bak:         if( !ch->name || ( cstate != CON_PLAYING && cstate != CON_EDITING && cstate != CON_ROLL_STATS && cstate != CON_DELETE ) )
comm.c.bak:            log_printf_plus( LOG_COMM, sysdata.log_level, "%s already connected.", ch->pcdata->filename );
comm.c.bak:         ch->desc = d;
comm.c.bak:         ch->timer = 0;
comm.c.bak:         if( ch->switched )
comm.c.bak:            do_return( ch->switched, "" );
comm.c.bak:         ch->switched = NULL;
comm.c.bak:            ch->pcdata->recent_site = STRALLOC( d->host );
comm.c.bak:         log_printf_plus( LOG_COMM, UMAX( sysdata.log_level, ch->level ), "%s@%s reconnected, kicking off old link.",
comm.c.bak:                          ch->pcdata->filename, d->host );
comm.c.bak:   if( !ch || !ch->desc || ch->desc->connected != CON_PLAYING || !IS_IDLE( ch ) )
comm.c.bak:   ch->timer = 0;
comm.c.bak:   was_in_room = ch->was_in_room;
comm.c.bak:   ch->was_in_room = ch->in_room;
comm.c.bak:    * ch->was_in_room  = NULL;
comm.c.bak:   REMOVE_BIT( ch->pcdata->flags, PCFLAG_IDLE );
comm.c.bak:#define NAME(ch)        ( IS_NPC(ch) ? ch->short_descr : ch->name )
comm.c.bak:   if( ch->morph && ch->morph->morph && ch->morph->morph->short_desc != NULL )
comm.c.bak:      return ch->morph->morph->short_desc;
comm.c.bak:               if( ch->sex > 2 || ch->sex < 0 )
comm.c.bak:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c.bak:                   !can_see( to, ch ) ? "It" : capitalize( he_she[URANGE( 0, ch->sex, 2 )] ) :
comm.c.bak:                   !can_see( to, ch ) ? "it" : he_she[URANGE( 0, ch->sex, 2 )];
comm.c.bak:               if( vch->sex > 2 || vch->sex < 0 )
comm.c.bak:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c.bak:                   !can_see( to, vch ) ? "It" : capitalize( he_she[URANGE( 0, vch->sex, 2 )] ) :
comm.c.bak:                   !can_see( to, vch ) ? "it" : he_she[URANGE( 0, vch->sex, 2 )];
comm.c.bak:               if( ch->sex > 2 || ch->sex < 0 )
comm.c.bak:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c.bak:                   !can_see( to, ch ) ? "It" : capitalize( him_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c.bak:                   !can_see( to, ch ) ? "it" : him_her[URANGE( 0, ch->sex, 2 )];
comm.c.bak:               if( vch->sex > 2 || vch->sex < 0 )
comm.c.bak:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c.bak:                   !can_see( to, vch ) ? "It" : capitalize( him_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c.bak:                   !can_see( to, vch ) ? "it" : him_her[URANGE( 0, vch->sex, 2 )];
comm.c.bak:               i = ( to == ch ) ? "your" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c.bak:               if( ch->sex > 2 || ch->sex < 0 )
comm.c.bak:                  bug( "act_string: player %s has sex set at %d!", ch->name, ch->sex );
comm.c.bak:                   !can_see( to, ch ) ? "It" : capitalize( his_her[URANGE( 0, ch->sex, 2 )] ) :
comm.c.bak:                   !can_see( to, ch ) ? "it" : his_her[URANGE( 0, ch->sex, 2 )];
comm.c.bak:               if( vch->sex > 2 || vch->sex < 0 )
comm.c.bak:                  bug( "act_string: player %s has sex set at %d!", vch->name, vch->sex );
comm.c.bak:                   !can_see( to, vch ) ? "It" : capitalize( his_her[URANGE( 0, vch->sex, 2 )] ) :
comm.c.bak:                   !can_see( to, vch ) ? "it" : his_her[URANGE( 0, vch->sex, 2 )];
comm.c.bak:   if( !ch->in_room )
comm.c.bak:      to = ch->in_room->first_person;
comm.c.bak:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_SECRETIVE ) && type != TO_CHAR )
comm.c.bak:         bug( "%s (%s)", ch->name, format );
comm.c.bak:      if( !vch->in_room )
comm.c.bak:         bug( "%s -> %s (%s)", ch->name, vch->name, format );
comm.c.bak:         || ( !IS_NPC(ch) && (xIS_SET(ch->act, PLR_WIZINVIS)
comm.c.bak:         && ( get_trust(to) < ( ch->pcdata ? ch->pcdata->wizinvis : 0 ) ) ) ) ) )
comm.c.bak:   if( !NOT_AUTHED( ch ) || ch->pcdata->auth_state != 2 )
comm.c.bak:   if( check_playing( ch->desc, argument, FALSE ) == BERR )
comm.c.bak:   if( !str_cmp( ch->name, ucase_argument ) )
comm.c.bak:   STRFREE( ch->name );
comm.c.bak:   ch->name = STRALLOC( ucase_argument );
comm.c.bak:   STRFREE( ch->pcdata->filename );
comm.c.bak:   ch->pcdata->filename = STRALLOC( ucase_argument );
comm.c.bak:   ch->pcdata->auth_state = 0;
comm.c.bak:   if( ch->fighting != NULL )
comm.c.bak:      ch_printf( ch, "Consider this carefuly %s, if you delete, you will not\r\nbe reinstated as an immortal!\r\n", ch->name );
comm.c.bak:   write_to_buffer( ch->desc, (const char *)echo_off_str, 0 );
comm.c.bak:   ch->desc->connected = CON_DELETE;
comm.c.bak:   bool ansi = ( !IS_NPC( och ) && xIS_SET( och->act, PLR_ANSI ) );
comm.c.bak:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_HELPSTART ) )
comm.c.bak:   else if( !IS_NPC( ch ) && ch->substate != SUB_NONE && ch->pcdata->subprompt && ch->pcdata->subprompt[0] != '\0' )
comm.c.bak:      prompt = ch->pcdata->subprompt;
comm.c.bak:   else if( IS_NPC( ch ) || ( !ch->fighting && ( !ch->pcdata->prompt || !*ch->pcdata->prompt ) ) )
comm.c.bak:   else if( ch->fighting )
comm.c.bak:      if( !ch->pcdata->fprompt || !*ch->pcdata->fprompt )
comm.c.bak:         prompt = ch->pcdata->fprompt;
comm.c.bak:      prompt = ch->pcdata->prompt;
comm.c.bak:                  if( ch->level >= 10 )
comm.c.bak:                     pstat = ch->alignment;
comm.c.bak:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.bak:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.bak:                  pstat = ch->hit;
comm.c.bak:                  pstat = ch->max_hit;
comm.c.bak:                     pstat = ch->mana;
comm.c.bak:                     pstat = ch->max_mana;
comm.c.bak:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.bak:                  if( !ch->fighting || ( victim = ch->fighting->who ) == NULL )
comm.c.bak:                     pstat = ch->pcdata->condition[COND_BLOODTHIRST];
comm.c.bak:                     pstat = ch->level + 10;
comm.c.bak:                  pstat = ch->move;
comm.c.bak:                  pstat = ch->max_move;
comm.c.bak:                  pstat = ch->gold;
comm.c.bak:                     pstat = ch->in_room->vnum;
comm.c.bak:                     snprintf( pbuf, MAX_STRING_LENGTH, "%s", ext_flag_string( &ch->in_room->room_flags, r_flags ) );
comm.c.bak:                  if( xIS_SET( och->act, PLR_ROOMVNUM ) )
comm.c.bak:                     snprintf( pbuf, MAX_STRING_LENGTH, "<#%d> ", ch->in_room->vnum );
comm.c.bak:                     if( IS_SET( ch->pcdata->flags, PCFLAG_DND ) )
comm.c.bak:                  pstat = ch->exp;
comm.c.bak:                  pstat = exp_level( ch, ch->level + 1 ) - ch->exp;
comm.c.bak:                  pstat = ch->carry_weight;
comm.c.bak:                  if( ch->style == STYLE_BERSERK )
comm.c.bak:                  else if( ch->style == STYLE_AGGRESSIVE )
comm.c.bak:                  else if( ch->style == STYLE_DEFENSIVE )
comm.c.bak:                  else if( ch->style == STYLE_EVASIVE )
comm.c.bak:                  if( ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_WIZINVIS ) ) ||
comm.c.bak:                      ( IS_NPC( ch ) && xIS_SET( ch->act, ACT_MOBINVIS ) ) )
comm.c.bak:                               ( IS_NPC( ch ) ? ch->mobinvis : ch->pcdata->wizinvis ) );
comm.c.bak:                  pstat = ( IS_NPC( ch ) ? ( xIS_SET( ch->act, ACT_MOBINVIS ) ? ch->mobinvis : 0 )
comm.c.bak:                            : ( xIS_SET( ch->act, PLR_WIZINVIS ) ? ch->pcdata->wizinvis : 0 ) );
comm.c.bak:   pclines = UMAX( ch->pcdata->pagerlen, 5 ) - 1;
comm.c.bak:   if( xIS_SET( ch->act, PLR_ANSI ) )
comm.c.bak:   if( xIS_SET( ch->act, PLR_ANSI ) )
comments.c:   if( !ch->desc )
comments.c:   if( ch->desc->connected == CON_EDITING )
comments.c:   switch ( ch->substate )
comments.c:         if( !ch->pnote )
comments.c:         if( ch->dest_buf != ch->pnote )
comments.c:            bug( "%s: sub_writing_note: ch->dest_buf != ch->pnote", __func__ );
comments.c:         STRFREE( ch->pnote->text );
comments.c:         ch->pnote->text = copy_buffer( ch );
comments.c:      ch->substate = SUB_WRITING_NOTE;
comments.c:      ch->dest_buf = ch->pnote;
comments.c:      start_editing( ch, ch->pnote->text );
comments.c:      STRFREE( ch->pnote->subject );
comments.c:      ch->pnote->subject = STRALLOC( argument );
comments.c:      STRFREE( ch->pnote->to_list );
comments.c:      ch->pnote->to_list = STRALLOC( argument );
comments.c:      if( ch->pnote )
comments.c:         STRFREE( ch->pnote->text );
comments.c:         STRFREE( ch->pnote->subject );
comments.c:         STRFREE( ch->pnote->to_list );
comments.c:         STRFREE( ch->pnote->date );
comments.c:         STRFREE( ch->pnote->sender );
comments.c:         DISPOSE( ch->pnote );
comments.c:      ch->pnote = NULL;
comments.c:      if( !ch->pnote )
comments.c:      ch_printf( ch, "%s: %s\r\nTo: %s\r\n", ch->pnote->sender, ch->pnote->subject, ch->pnote->to_list );
comments.c:      send_to_char( ch->pnote->text, ch );
comments.c:      if( !ch->pnote )
comments.c:      STRFREE( ch->pnote->date );
comments.c:      ch->pnote->date = STRALLOC( strtime );
comments.c:      pnote = ch->pnote;
comments.c:      ch->pnote = NULL;
comments.c:   if( !ch->comments )
comments.c:   for( pnote = ch->comments; pnote; pnote = pnote->next )
comments.c:      ch->comments = pnote;
db.c:         for( pch = first_char; pch; pch = pch->next )
db.c:            if( !IS_NPC( pch ) && IS_AWAKE( pch ) && pch->in_room && pch->in_room->area == pArea )
db.c:   ch->editor = NULL;
db.c:   ch->hunting = NULL;
db.c:   ch->fearing = NULL;
db.c:   ch->hating = NULL;
db.c:   ch->name = NULL;
db.c:   ch->short_descr = NULL;
db.c:   ch->long_descr = NULL;
db.c:   ch->description = NULL;
db.c:   ch->next = NULL;
db.c:   ch->prev = NULL;
db.c:   ch->reply = NULL;
db.c:   ch->retell = NULL;
db.c:   ch->variables = NULL;
db.c:   ch->first_carrying = NULL;
db.c:   ch->last_carrying = NULL;
db.c:   ch->next_in_room = NULL;
db.c:   ch->prev_in_room = NULL;
db.c:   ch->fighting = NULL;
db.c:   ch->switched = NULL;
db.c:   ch->first_affect = NULL;
db.c:   ch->last_affect = NULL;
db.c:   ch->prev_cmd = NULL; /* maps */
db.c:   ch->last_cmd = NULL;
db.c:   ch->dest_buf = NULL;
db.c:   ch->alloc_ptr = NULL;
db.c:   ch->spare_ptr = NULL;
db.c:   ch->mount = NULL;
db.c:   ch->morph = NULL;
db.c:   xCLEAR_BITS( ch->affected_by );
db.c:   ch->logon = current_time;
db.c:   ch->armor = 100;
db.c:   ch->position = POS_STANDING;
db.c:   ch->practice = 0;
db.c:   ch->hit = 20;
db.c:   ch->max_hit = 20;
db.c:   ch->mana = 100;
db.c:   ch->max_mana = 100;
db.c:   ch->move = 100;
db.c:   ch->max_move = 100;
db.c:   ch->height = 72;
db.c:   ch->weight = 180;
db.c:   ch->xflags = 0;
db.c:   ch->race = 0;
db.c:   ch->Class = 3;
db.c:   ch->speaking = LANG_COMMON;
db.c:   ch->speaks = LANG_COMMON;
db.c:   ch->barenumdie = 1;
db.c:   ch->baresizedie = 4;
db.c:   ch->substate = 0;
db.c:   ch->tempnum = 0;
db.c:   ch->perm_str = 13;
db.c:   ch->perm_dex = 13;
db.c:   ch->perm_int = 13;
db.c:   ch->perm_wis = 13;
db.c:   ch->perm_cha = 13;
db.c:   ch->perm_con = 13;
db.c:   ch->perm_lck = 13;
db.c:   ch->mod_str = 0;
db.c:   ch->mod_dex = 0;
db.c:   ch->mod_int = 0;
db.c:   ch->mod_wis = 0;
db.c:   ch->mod_cha = 0;
db.c:   ch->mod_con = 0;
db.c:   ch->mod_lck = 0;
db.c:   if( ch->desc )
db.c:   if( ch->morph )
db.c:      DISPOSE( ch->morph );
db.c:   while( ( obj = ch->last_carrying ) != NULL )
db.c:   while( ( paf = ch->last_affect ) != NULL )
db.c:   while( ( timer = ch->first_timer ) != NULL )
db.c:   if( ch->editor )
db.c:   STRFREE( ch->name );
db.c:   STRFREE( ch->short_descr );
db.c:   STRFREE( ch->long_descr );
db.c:   STRFREE( ch->description );
db.c:   STRFREE( ch->spec_funname );
db.c:   if( ch->pnote )
db.c:      free_note( ch->pnote );
db.c:   for( vd = ch->variables; vd; vd = vd_next )
db.c:   if( ch->pcdata )
db.c:      if( ch->pcdata->pet )
db.c:         extract_char( ch->pcdata->pet, TRUE );
db.c:         ch->pcdata->pet = NULL;
db.c:      for( temp = ch->pcdata->first_ignored; temp; temp = next )
db.c:         UNLINK( temp, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
db.c:      STRFREE( ch->pcdata->filename );
db.c:      STRFREE( ch->pcdata->deity_name );
db.c:      STRFREE( ch->pcdata->clan_name );
db.c:      STRFREE( ch->pcdata->council_name );
db.c:      if( ch->pcdata->recent_site )
db.c:         STRFREE( ch->pcdata->recent_site );
db.c:      if( ch->pcdata->prev_site )
db.c:         STRFREE( ch->pcdata->prev_site );
db.c:      DISPOSE( ch->pcdata->pwd );   /* no hash */
db.c:      DISPOSE( ch->pcdata->bamfin );   /* no hash */
db.c:      DISPOSE( ch->pcdata->bamfout );  /* no hash */
db.c:      DISPOSE( ch->pcdata->rank );
db.c:      STRFREE( ch->pcdata->title );
db.c:      STRFREE( ch->pcdata->bio );
db.c:      DISPOSE( ch->pcdata->bestowments ); /* no hash */
db.c:      DISPOSE( ch->pcdata->homepage ); /* no hash */
db.c:      STRFREE( ch->pcdata->authed_by );
db.c:      STRFREE( ch->pcdata->prompt );
db.c:      STRFREE( ch->pcdata->fprompt );
db.c:      if( ch->pcdata->helled_by )
db.c:         STRFREE( ch->pcdata->helled_by );
db.c:      if( ch->pcdata->subprompt )
db.c:         STRFREE( ch->pcdata->subprompt );
db.c:      if( ch->pcdata->tell_history )
db.c:            if( ch->pcdata->tell_history[i] )
db.c:               STRFREE( ch->pcdata->tell_history[i] );
db.c:         DISPOSE( ch->pcdata->tell_history );
db.c:      DISPOSE( ch->pcdata );
db.c:   for( mpact = ch->mpact; mpact; mpact = mpact_next )
db.c:   for( comments = ch->comments; comments; comments = comments_next )
db.c:      fprintf( fp, "[%5d] %s: %s\n", ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
db.c:   for( ch = first_char; ch; ch = ch->next )
db.c:      if( ch->was_in_room == room )
db.c:         ch->was_in_room = ch->in_room;
db.c:      if( ch->substate == SUB_ROOM_DESC && ch->dest_buf == room )
db.c:         ch->substate = SUB_NONE;
db.c:         ch->dest_buf = NULL;
db.c:      else if( ch->substate == SUB_ROOM_EXTRA && ch->dest_buf )
db.c:            if( ed == ch->dest_buf )
db.c:               ch->substate = SUB_NONE;
db.c:               ch->dest_buf = NULL;
db.c:      ch_next = ch->next;
db.c:      if( ch->pIndexData == mob )
db.c:      else if( ch->substate == SUB_MPROG_EDIT && ch->dest_buf )
db.c:            if( mp == ch->dest_buf )
db.c:               ch->dest_buf = NULL;
db.c:               ch->substate = SUB_NONE;
db.c:      pwatch->imm_level = number;
db.c:      pwatch->imm_name = fread_string_nohash( fp );
db.c:      pwatch->target_name = fread_string_nohash( fp );
db.c:      if( strlen( pwatch->target_name ) < 2 )
db.c:         DISPOSE( pwatch->target_name );
db.c:      pwatch->player_site = fread_string_nohash( fp );
db.c:      if( strlen( pwatch->player_site ) < 2 )
db.c:         DISPOSE( pwatch->player_site );
db.c:      if( pwatch->target_name )
db.c:         for( cmd = command_hash[( int )pwatch->target_name[0]]; cmd; cmd = cmd->next )
db.c:            if( !str_cmp( pwatch->target_name, cmd->name ) )
db.c:      if( !str_cmp( lmsg->name, ch->name ) )
db.c:            bug( "%s: Error: Unknown login msg: %d for %s.", __func__, lmsg->type, ch->name );
deity.c:   switch ( ch->substate )
deity.c:         deity = ( DEITY_DATA * ) ch->dest_buf;
deity.c:         ch->substate = ch->tempnum;
deity.c:      for( vch = first_char; vch; vch = vch->next )
deity.c:            if( vch->pcdata->deity == deity )
deity.c:               snprintf( buf, MAX_STRING_LENGTH, "&R\r\nYour deity, %s, has met its demise!\r\n", vch->pcdata->deity_name );
deity.c:               if( !vch->desc )
deity.c:                  add_loginmsg( vch->name, 18, buf );
deity.c:               xREMOVE_BITS( vch->affected_by, vch->pcdata->deity->affected );
deity.c:               REMOVE_BIT( vch->resistant, vch->pcdata->deity->element );
deity.c:               REMOVE_BIT( vch->susceptible, vch->pcdata->deity->suscept );
deity.c:               vch->pcdata->deity = NULL;
deity.c:               STRFREE( vch->pcdata->deity_name );
deity.c:               vch->pcdata->deity_name = STRALLOC( "" );
deity.c:      if( ch->substate == SUB_REPEATCMD )
deity.c:         ch->tempnum = SUB_REPEATCMD;
deity.c:         ch->tempnum = SUB_NONE;
deity.c:      ch->substate = SUB_DEITYDESC;
deity.c:      ch->dest_buf = deity;
deity.c:   if( ch->level < 5 )
deity.c:      if( !ch->pcdata->deity )
deity.c:      --ch->pcdata->deity->worshippers;
deity.c:      if( ch->pcdata->deity->worshippers < 0 )
deity.c:         ch->pcdata->deity->worshippers = 0;
deity.c:      ch->pcdata->favor = -2500;
deity.c:      ch->mental_state = -80;
deity.c:      xREMOVE_BITS( ch->affected_by, ch->pcdata->deity->affected );
deity.c:      REMOVE_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:      REMOVE_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      save_deity( ch->pcdata->deity );
deity.c:      ch->pcdata->deity = NULL;
deity.c:      STRFREE( ch->pcdata->deity_name );
deity.c:      ch->pcdata->deity_name = STRALLOC( "" );
deity.c:   if( ch->pcdata->deity )
deity.c:   if( ( deity->Class != -1 ) && ( deity->Class != ch->Class ) )
deity.c:   if( ( deity->sex != -1 ) && ( deity->sex != ch->sex ) )
deity.c:      if( ( deity->race != ch->race ) && ( deity->race2 != ch->race ) )
deity.c:   STRFREE( ch->pcdata->deity_name );
deity.c:   ch->pcdata->deity_name = QUICKLINK( deity->name );
deity.c:   ch->pcdata->deity = deity;
deity.c:   if( ch->pcdata->favor > deity->affectednum )
deity.c:      xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
deity.c:   if( ch->pcdata->favor > deity->elementnum )
deity.c:      SET_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:   if( ch->pcdata->favor < deity->susceptnum )
deity.c:      SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:   act( AT_MAGIC, "Body and soul, you devote yourself to $t!", ch, ch->pcdata->deity_name, NULL, TO_CHAR );
deity.c:   ++ch->pcdata->deity->worshippers;
deity.c:   save_deity( ch->pcdata->deity );
deity.c:   if( IS_NPC( ch ) || !ch->pcdata->deity )
deity.c:   oldfavor = ch->pcdata->favor;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->scorpse )
deity.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
deity.c:      snprintf( buf2, MAX_STRING_LENGTH, "the corpse of %s", ch->name );
deity.c:                  ch->pcdata->favor -= ch->pcdata->deity->scorpse;
deity.c:            obj = obj_to_room( obj, ch->in_room );
deity.c:      ch->pcdata->favor -= ch->pcdata->deity->scorpse;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->savatar )
deity.c:      char_to_room( victim, ch->in_room );
deity.c:      snprintf( buf, MAX_STRING_LENGTH, victim->short_descr, ch->pcdata->deity->name );
deity.c:      snprintf( buf, MAX_STRING_LENGTH, victim->long_descr, ch->pcdata->deity->name );
deity.c:      snprintf( buf, MAX_STRING_LENGTH, victim->description, ch->pcdata->deity->name );
deity.c:      victim->hit = ch->hit * 6 + ch->pcdata->favor;
deity.c:      victim->alignment = ch->pcdata->deity->alignment;
deity.c:      victim->max_hit = ch->hit * 6 + ch->pcdata->favor;
deity.c:      ch->pcdata->favor -= ch->pcdata->deity->savatar;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->sdeityobj )
deity.c:      obj = create_object( pObjIndex, ch->level );
deity.c:         obj = obj_to_room( obj, ch->in_room );
deity.c:      snprintf( buf, MAX_STRING_LENGTH, "sigil %s", ch->pcdata->deity->name );
deity.c:      snprintf( buf, MAX_STRING_LENGTH, obj->short_descr, ch->pcdata->deity->name );
deity.c:      snprintf( buf, MAX_STRING_LENGTH, obj->description, ch->pcdata->deity->name );
deity.c:      ch->pcdata->favor -= ch->pcdata->deity->sdeityobj;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:      switch ( ch->pcdata->deity->objstat )
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->srecall )
deity.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_NOSUPPLICATE ) )
deity.c:      if( !IS_NPC( ch ) && ch->pcdata->clan )
deity.c:         location = get_room_index( ch->pcdata->clan->recall );
deity.c:      if( !IS_NPC( ch ) && !location && ch->level >= 5 && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
deity.c:         location = get_room_index( race_table[ch->race]->race_recall );
deity.c:      if( ch->mount )
deity.c:         char_from_room( ch->mount );
deity.c:         char_to_room( ch->mount, location );
deity.c:      ch->pcdata->favor -= ch->pcdata->deity->srecall;
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:   if( IS_NPC( ch ) || !ch->pcdata->deity )
deity.c:   oldfavor = ch->pcdata->favor;
deity.c:   if( ( ch->alignment - ch->pcdata->deity->alignment > 650
deity.c:         || ch->alignment - ch->pcdata->deity->alignment < -650 ) && ch->pcdata->deity->alignment != 0 )
deity.c:      ch->pcdata->favor -= 2;
deity.c:      ch->pcdata->favor = URANGE( -2500, ch->pcdata->favor, 2500 );
deity.c:      if( ch->pcdata->favor > ch->pcdata->deity->affectednum )
deity.c:         xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
deity.c:      if( ch->pcdata->favor > ch->pcdata->deity->elementnum )
deity.c:         SET_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:      if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:          ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:            ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:          ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->flee / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->flee_npcrace / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->kill / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->kill_npcrace / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->kill_magic / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->sac / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->bury_corpse / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->aid_spell / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->aid / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->steal / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->backstab / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->die / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->die_npcrace / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->spell_aid / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->dig_corpse / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->die_npcfoe / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->flee_npcfoe / mod );
deity.c:         ch->pcdata->favor += number_fuzzy( ch->pcdata->deity->kill_npcfoe / mod );
deity.c:   ch->pcdata->favor = URANGE( -2500, ch->pcdata->favor, 2500 );
deity.c:   if( ch->pcdata->favor > ch->pcdata->deity->affectednum )
deity.c:      xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
deity.c:   if( ch->pcdata->favor > ch->pcdata->deity->elementnum )
deity.c:      SET_BIT( ch->resistant, ch->pcdata->deity->element );
deity.c:   if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
deity.c:      SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
deity.c:   if( ( oldfavor > ch->pcdata->deity->affectednum &&
deity.c:         ch->pcdata->favor <= ch->pcdata->deity->affectednum ) ||
deity.c:       ( oldfavor > ch->pcdata->deity->elementnum &&
deity.c:         ch->pcdata->favor <= ch->pcdata->deity->elementnum ) ||
deity.c:       ( oldfavor < ch->pcdata->deity->susceptnum && ch->pcdata->favor >= ch->pcdata->deity->susceptnum ) )
fight.c:   int oldgold = ch->gold;
fight.c:      if( !CAN_WEAR( content, ITEM_TAKE ) && ch->level < sysdata.level_getobjnotake )
fight.c:      ch->gold += content->value[0] * content->count;
fight.c:   if( ch->gold - oldgold > 1 && ch->position > POS_SLEEPING )
fight.c:      snprintf( buf, MAX_INPUT_LENGTH, "%d", ch->gold - oldgold );
fight.c:   if( !ch->hunting || ch->hunting->who != victim )
fight.c:   if( !ch->hating || ch->hating->who != victim )
fight.c:   if( !ch->fearing || ch->fearing->who != victim )
fight.c:   if( ch->hunting )
fight.c:      STRFREE( ch->hunting->name );
fight.c:      DISPOSE( ch->hunting );
fight.c:      ch->hunting = NULL;
fight.c:   if( ch->hating )
fight.c:      STRFREE( ch->hating->name );
fight.c:      DISPOSE( ch->hating );
fight.c:      ch->hating = NULL;
fight.c:   if( ch->fearing )
fight.c:      STRFREE( ch->fearing->name );
fight.c:      DISPOSE( ch->fearing );
fight.c:      ch->fearing = NULL;
fight.c:   if( ch->hunting )
fight.c:   CREATE( ch->hunting, HHF_DATA, 1 );
fight.c:   ch->hunting->name = QUICKLINK( victim->name );
fight.c:   ch->hunting->who = victim;
fight.c:   if( ch->hating )
fight.c:   CREATE( ch->hating, HHF_DATA, 1 );
fight.c:   ch->hating->name = QUICKLINK( victim->name );
fight.c:   ch->hating->who = victim;
fight.c:   if( ch->fearing )
fight.c:   CREATE( ch->fearing, HHF_DATA, 1 );
fight.c:   ch->fearing->name = QUICKLINK( victim->name );
fight.c:   ch->fearing->who = victim;
fight.c:      if( who_fighting( ch->fighting->who ) == ch && IS_AFFECTED( who_fighting( ch ), AFF_GRAPPLE ) )
fight.c:      if( ch->fighting && ( ++ch->fighting->duration % 24 ) == 0 )
fight.c:         ch->fighting->xp = ( ( ch->fighting->xp * 9 ) / 10 );
fight.c:      for( timer = ch->first_timer; timer; timer = timer_next )
fight.c:         if( ch->fighting && timer->type == TIMER_DO_FUN )
fight.c:            tempsub = ch->substate;
fight.c:            ch->substate = SUB_TIMER_DO_ABORT;
fight.c:            ch->substate = tempsub;
fight.c:               DISPOSE( ch->pcdata->nuisance );
fight.c:               tempsub = ch->substate;
fight.c:               ch->substate = timer->value;
fight.c:               ch->substate = tempsub;
fight.c:      for( paf = ch->first_affect; paf; paf = paf_next )
fight.c:               ch->desc->character = ch->desc->original;
fight.c:               ch->desc->original = NULL;
fight.c:               ch->desc->character->desc = ch->desc;
fight.c:               ch->desc->character->switched = NULL;
fight.c:               ch->desc = NULL;
fight.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
fight.c:         log_printf( "violence_update: %s fighting %s in a SAFE room.", ch->name, victim->name );
fight.c:      else if( IS_AWAKE( ch ) && ch->in_room == victim->in_room )
fight.c:         if( !xIS_EMPTY( ch->attacks ) )
fight.c:            if( 30 + ( ch->level / 4 ) >= number_percent(  ) )
fight.c:                  if( xIS_SET( ch->attacks, attacktype ) )
fight.c:                     retcode = spell_energy_drain( skill_lookup( "energy drain" ), ch->level, ch, victim );
fight.c:                     retcode = spell_fire_breath( skill_lookup( "fire breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_frost_breath( skill_lookup( "frost breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_acid_breath( skill_lookup( "acid breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_lightning_breath( skill_lookup( "lightning breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_gas_breath( skill_lookup( "gas breath" ), ch->level, ch, victim );
fight.c:                     retcode = spell_spiral_blast( skill_lookup( "spiral blast" ), ch->level, ch, victim );
fight.c:                     retcode = spell_poison( gsn_poison, ch->level, ch, victim );
fight.c:                      * retcode = spell_nasty_poison( skill_lookup( "nasty poison" ), ch->level, ch, victim );
fight.c:                      * retcode = spell_gaze( skill_lookup( "gaze" ), ch->level, ch, victim );
fight.c:                     retcode = spell_blindness( gsn_blindness, ch->level, ch, victim );
fight.c:                     retcode = spell_cause_serious( skill_lookup( "cause serious" ), ch->level, ch, victim );
fight.c:                     retcode = spell_earthquake( skill_lookup( "earthquake" ), ch->level, ch, victim );
fight.c:                     retcode = spell_cause_critical( skill_lookup( "cause critical" ), ch->level, ch, victim );
fight.c:                     retcode = spell_curse( skill_lookup( "curse" ), ch->level, ch, victim );
fight.c:                     retcode = spell_flamestrike( skill_lookup( "flamestrike" ), ch->level, ch, victim );
fight.c:                     retcode = spell_harm( skill_lookup( "harm" ), ch->level, ch, victim );
fight.c:                     retcode = spell_fireball( skill_lookup( "fireball" ), ch->level, ch, victim );
fight.c:                     retcode = spell_colour_spray( skill_lookup( "colour spray" ), ch->level, ch, victim );
fight.c:                     retcode = spell_weaken( skill_lookup( "weaken" ), ch->level, ch, victim );
fight.c:         if( !xIS_EMPTY( ch->defenses ) )
fight.c:            if( 50 + ( ch->level / 4 ) > number_percent(  ) )
fight.c:                  if( xIS_SET( ch->defenses, attacktype ) )
fight.c:                     if( ch->hit < ch->max_hit )
fight.c:                        retcode = spell_smaug( skill_lookup( "cure light" ), ch->level, ch, ch );
fight.c:                     if( ch->hit < ch->max_hit )
fight.c:                        retcode = spell_smaug( skill_lookup( "cure serious" ), ch->level, ch, ch );
fight.c:                     if( ch->hit < ch->max_hit )
fight.c:                        retcode = spell_smaug( skill_lookup( "cure critical" ), ch->level, ch, ch );
fight.c:                     if( ch->hit < ch->max_hit )
fight.c:                        retcode = spell_smaug( skill_lookup( "heal" ), ch->level, ch, ch );
fight.c:                        retcode = spell_dispel_magic( skill_lookup( "dispel magic" ), ch->level, ch, victim );
fight.c:                     retcode = spell_dispel_evil( skill_lookup( "dispel evil" ), ch->level, ch, victim );
fight.c:                     retcode = spell_teleport( skill_lookup( "teleport" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "shockshield" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "venomshield" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "acidmist" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "fireshield" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "iceshield" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "true" ), ch->level, ch, ch );
fight.c:                        retcode = spell_smaug( skill_lookup( "sanctuary" ), ch->level, ch, ch );
fight.c:      for( rch = ch->in_room->first_person; rch; rch = trvch_next( lcr ) )
fight.c:             && ( rch->fighting )
fight.c:             && ( who_fighting( rch->fighting->who ) == ch )
fight.c:             && ( !xIS_SET( rch->fighting->who->act, ACT_AUTONOMOUS ) ) && ( rch->style < ch->style ) )
fight.c:            rch->fighting->who->fighting->who = rch;
fight.c:         if( IS_AWAKE( rch ) && !rch->fighting )
fight.c:               if( ( ( !IS_NPC( rch ) && rch->desc )
fight.c:            if( IS_NPC( rch ) && !IS_AFFECTED( rch, AFF_CHARM ) && !xIS_SET( rch->act, ACT_NOASSIST )
fight.c:                && !xIS_SET( rch->act, ACT_PET ) )
fight.c:               if( rch->pIndexData == ch->pIndexData || number_bits( 3 ) == 0 )
fight.c:                  for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
fight.c:                        if( vch->mount && vch->mount == rch )
fight.c:      if( xIS_SET( ch->act, PLR_NICE ) )
fight.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_NOATTACK ) )
fight.c:      dual_bonus = IS_NPC( ch ) ? ( ch->level / 10 ) : ( LEARNED( ch, gsn_dual_wield ) / 10 );
fight.c:      schance = IS_NPC( ch ) ? ch->level : LEARNED( ch, gsn_dual_wield );
fight.c:   if( ch->move < 10 )
fight.c:   if( IS_NPC( ch ) && ch->numattacks > 0 )
fight.c:      for( schance = 0; schance < ch->numattacks; schance++ )
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_second_attack ) + dual_bonus ) / 1.5 );
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_third_attack ) + ( dual_bonus * 1.5 ) ) / 2 );
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_fourth_attack ) + ( dual_bonus * 2 ) ) / 3 );
fight.c:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_fifth_attack ) + ( dual_bonus * 3 ) ) / 4 );
fight.c:   schance = IS_NPC( ch ) ? ( int )( ch->level / 2 ) : 0;
fight.c:         move = encumbrance( ch, movement_loss[UMIN( SECT_MAX - 1, ch->in_room->sector_type )] );
fight.c:      if( ch->move )
fight.c:         ch->move = UMAX( 0, ch->move - move );
fight.c:   if( !IS_NPC( ch ) && ch->level > 5 && wield )
fight.c:       * ( 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) );
fight.c:         bonus -= ch->pcdata->favor / -400;
fight.c:      lvl = UMAX( 1, ( ch->level - 10 ) / 2 );
fight.c:            return ch->level;
fight.c:      lvl = ch->level / 2;
fight.c:   if( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:   if( ch->fighting  /* make sure fight is already started */
fight.c:       && dt == TYPE_UNDEFINED && IS_NPC( ch ) && !xIS_EMPTY( ch->attacks ) )
fight.c:         if( xIS_SET( ch->attacks, attacktype ) )
fight.c:      thac0_00 = ch->mobthac0;
fight.c:      thac0_00 = class_table[ch->Class]->thac0_00;
fight.c:      thac0_32 = class_table[ch->Class]->thac0_32;
fight.c:   thac0 = interpolate( ch->level, thac0_00, thac0_32 ) - GET_HITROLL( ch );
fight.c:   if( ch->fighting && ch->fighting->who == victim )
fight.c:      short times = ch->fighting->timeskilled;
fight.c:      dam = number_range( ch->barenumdie, ch->baresizedie * ch->barenumdie ) + ch->damplus;
fight.c:   if( ch->position == POS_BERSERK )
fight.c:   else if( ch->position == POS_AGGRESSIVE )
fight.c:   else if( ch->position == POS_DEFENSIVE )
fight.c:   else if( ch->position == POS_EVASIVE )
fight.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c:      dam *= ( 2 + URANGE( 2, ch->level - ( victim->level / 4 ), 30 ) / 8 );
fight.c:      dam *= ( 2 + URANGE( 2, ch->level - ( victim->level / 4 ), 30 ) / 11 );
fight.c:      dam *= ( 2 + URANGE( 2, ch->level - ( victim->level / 4 ), 30 ) / 16 );
fight.c:      thac0_00 = ch->mobthac0;
fight.c:      thac0_00 = class_table[ch->Class]->thac0_00;
fight.c:      thac0_32 = class_table[ch->Class]->thac0_32;
fight.c:   thac0 = interpolate( ch->level, thac0_00, thac0_32 ) - GET_HITROLL( ch ) + ( dist * 2 );
fight.c:   victim_ac = ((((ch->pcdata->def + ch->pcdata->defplus) * ch->pcdata->deflevel) /15 ) * -1);
fight.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c:   if( IS_SET( ch->immune, ris ) && !IS_SET( ch->no_immune, ris ) )
fight.c:   if( IS_SET( ch->resistant, ris ) && !IS_SET( ch->no_resistant, ris ) )
fight.c:   if( IS_SET( ch->susceptible, ris ) && !IS_SET( ch->no_susceptible, ris ) )
fight.c:      if( IS_NPC( ch ) && IS_SET( ch->immune, ris ) )
fight.c:               victim->hunting->name = QUICKLINK( ch->name );
fight.c:            victim->hating->name = QUICKLINK( ch->name );
fight.c://      maxdam = ch->level * 80;
fight.c://      maxdam = ch->level * 40;
fight.c:	dam = ((dam + ch->pcdata->str + ch->pcdata->att) * ch->pcdata->attlevel) * ((ch->pcdata->dex/100) +1);
fight.c:      bug( "** %s (lvl %d) -> %s **", ch->name, ch->level, victim->name );
fight.c:         if( !victim->fighting && victim->in_room == ch->in_room )
fight.c:         if( !ch->fighting && victim->in_room == ch->in_room )
fight.c:             && victim->master && victim->master->in_room == ch->in_room && number_bits( 3 ) == 0 )
fight.c:      for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:      for( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:                 ( ch->leader == victim ) ? victim : ch, NULL,
fight.c:                 ( ch->leader == victim ) ? victim->master : ch->master, TO_NOTVICT );
fight.c:            if( ch->leader == victim )
fight.c:         if( ch->leader != NULL && !IS_NPC( ch->leader ) && !IS_PKILL( ch->leader ) )
fight.c:            act( AT_ACTION, "$n disbands from $N's group.", ch, NULL, ch->master, TO_NOTVICT );
fight.c:            for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:                  act( AT_ACTION, "$n disbands from $N's group.", ch, NULL, gch->master, TO_NOTVICT );
fight.c:            for( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:                  act( AT_ACTION, "$n disbands from $N's group.", gch, NULL, gch->master, TO_NOTVICT );
fight.c:         xREMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
fight.c:         xREMOVE_BIT( ch->affected_by, AFF_HIDE );
fight.c:      if( dt >= TYPE_HIT && ch->in_room == victim->in_room )
fight.c:         if( IS_NPC( ch ) && xIS_SET( ch->defenses, DFND_DISARM ) && ch->level > 9 && number_percent(  ) < ch->level / 3 ) /* Was 2 try this --Shaddai */
fight.c:         if( IS_NPC( ch ) && xIS_SET( ch->attacks, ATCK_TRIP ) && ch->level > 5 && number_percent(  ) < ch->level / 2 )
fight.c:            if( ch->level < LEVEL_AVATAR )
fight.c:   if( dam && ch != victim && !IS_NPC( ch ) && ch->fighting && ch->fighting->xp )
fight.c:      if( ch->fighting->who == victim )
fight.c:         xp_gain = ( int )( ch->fighting->xp * dam ) / victim->max_hit;
fight.c:       && is_wielding_poisoned( ch ) && !IS_SET( victim->immune, RIS_POISON ) && !saves_poison_death( ch->level, victim ) )
fight.c:            add_loginmsg( victim->name, 17, ( IS_NPC(ch) ? ch->short_descr : ch->name ) );
fight.c:                   victim->name, victim->level, ( IS_NPC( ch ) ? ch->short_descr : ch->name ), victim->in_room->vnum );
fight.c:         if( !IS_NPC( ch ) && !IS_IMMORTAL( ch ) && ch->pcdata->clan
fight.c:             && ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD && victim != ch )
fight.c:            snprintf( filename, 256, "%s%s.record", CLAN_DIR, ch->pcdata->clan->name );
fight.c:                      ch->level,
fight.c:                      ch->name,
fight.c:                      "&P(&WUnclanned&P)", victim->name, ch->in_room->area->name );
fight.c:            if( victim->pcdata && victim->pcdata->clan && victim->pcdata->clan->name == ch->pcdata->clan->name )
fight.c:                     ch->level,
fight.c:                     ch->pcdata->clan ? ch->pcdata->clan->badge :
fight.c:                     "&P(&WUnclanned&P)", ch->name, victim->in_room->area->name );
fight.c:            if( ch->pcdata && ch->pcdata->clan && ch->pcdata->clan->name == victim->pcdata->clan->name )
fight.c:         for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:      if( !IS_NPC( ch ) && ch->pcdata->clan )
fight.c:      if( ch->in_room == victim->in_room )
fight.c:          && new_corpse->in_room == ch->in_room && can_see_obj( ch, new_corpse ) && ch->position > POS_SLEEPING )
fight.c:         if( xIS_SET( ch->act, PLR_AUTOGOLD ) && !loot_coins_from_corpse( ch, new_corpse ) )
fight.c:         if( new_corpse && !obj_extracted( new_corpse ) && new_corpse->in_room == ch->in_room
fight.c:             && ch->position > POS_SLEEPING && can_see_obj( ch, new_corpse ) )
fight.c:            if( xIS_SET( ch->act, PLR_AUTOLOOT ) )
fight.c:            if( !char_died( ch ) && xIS_SET( ch->act, PLR_AUTOSAC ) && !obj_extracted( new_corpse )
fight.c:                && new_corpse->in_room == ch->in_room && ch->position > POS_SLEEPING && can_see_obj( ch, new_corpse ) )
fight.c:      bug( "Is_safe: %s opponent does not exist!", ch->name );
fight.c:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
fight.c:   if( calculate_age( ch ) < 18 || ch->level < 5 )
fight.c:   if( ch->level - victim->level > 5 || victim->level - ch->level > 5 )
fight.c:   if( IS_NPC( ch ) && !ch->master )
fight.c:       && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) && IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) )
fight.c:            level_ratio = URANGE( 1, ch->level, MAX_LEVEL );
fight.c:            level_ratio = URANGE( 1, ch->level / victim->level, MAX_LEVEL );
fight.c:         if( ch->pcdata->clan )
fight.c:            ch->pcdata->clan->mkills++;
fight.c:         ch->pcdata->mkills++;
fight.c:         ch->in_room->area->mkills++;
fight.c:         if( ch->pcdata->deity )
fight.c:            if( victim->race == ch->pcdata->deity->npcrace )
fight.c:            else if( victim->race == ch->pcdata->deity->npcfoe )
fight.c:   if( ch == victim || ch->level >= LEVEL_IMMORTAL )
fight.c:         ch->pcdata->pkills++;
fight.c:         if( ch->pcdata->clan )
fight.c:               ch->pcdata->clan->pkills[0]++;
fight.c:               ch->pcdata->clan->pkills[1]++;
fight.c:               ch->pcdata->clan->pkills[2]++;
fight.c:               ch->pcdata->clan->pkills[3]++;
fight.c:               ch->pcdata->clan->pkills[4]++;
fight.c:               ch->pcdata->clan->pkills[5]++;
fight.c:               ch->pcdata->clan->pkills[6]++;
fight.c:         ch->pcdata->pkills++;
fight.c:         ch->in_room->area->pkills++;
fight.c:       && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) && IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) )
fight.c:      if( !ch->pcdata->clan
fight.c:          || ( ch->pcdata->clan->clan_type != CLAN_NOKILL
fight.c:               && victim->pcdata->clan->clan_type != CLAN_NOKILL && ch->pcdata->clan != victim->pcdata->clan ) )
fight.c:         if( ch->pcdata->clan )
fight.c:               ch->pcdata->clan->pkills[0]++;
fight.c:               ch->pcdata->clan->pkills[1]++;
fight.c:               ch->pcdata->clan->pkills[2]++;
fight.c:               ch->pcdata->clan->pkills[3]++;
fight.c:               ch->pcdata->clan->pkills[4]++;
fight.c:               ch->pcdata->clan->pkills[5]++;
fight.c:               ch->pcdata->clan->pkills[6]++;
fight.c:         ch->pcdata->pkills++;
fight.c:         ch->hit = ch->max_hit;
fight.c:         ch->mana = ch->max_mana;
fight.c:         ch->move = ch->max_move;
fight.c:         if( ch->pcdata )
fight.c:            ch->pcdata->condition[COND_BLOODTHIRST] = ( 10 + ch->level );
fight.c:            if( ch->level < 10 )
fight.c:            else if( ch->level < 15 )
fight.c:            else if( ch->level < 20 )
fight.c:            else if( ch->level < 30 )
fight.c:            else if( ch->level < 40 )
fight.c:            else if( ch->level < 50 )
fight.c:      if( !ch->master )
fight.c:         bug( "Check_killer: %s bad AFF_CHARM", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c:         xREMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c:      if( ch->master )
fight.c:         check_killer( ch->master, victim );
fight.c:         level_ratio = URANGE( 1, ch->level / victim->level, LEVEL_AVATAR );
fight.c:            if( ch->race == victim->pcdata->deity->npcrace )
fight.c:            else if( ch->race == victim->pcdata->deity->npcfoe )
fight.c:      if( ch->pcdata->clan )
fight.c:         ch->pcdata->clan->illegal_pk++;
fight.c:      ch->pcdata->illegal_pk++;
fight.c:      ch->in_room->area->illegal_pk++;
fight.c:         if( ch->level < 10 )
fight.c:         else if( ch->level < 15 )
fight.c:         else if( ch->level < 20 )
fight.c:         else if( ch->level < 30 )
fight.c:         else if( ch->level < 40 )
fight.c:         else if( ch->level < 50 )
fight.c:   if( xIS_SET( ch->act, PLR_KILLER ) )
fight.c:   xSET_BIT( ch->act, PLR_KILLER );
fight.c:   if( xIS_SET( ch->act, PLR_ATTACKER ) )
fight.c:      xREMOVE_BIT( ch->act, PLR_ATTACKER );
fight.c:    { if ( !(ch->pcdata->clan && victim->pcdata->clan
fight.c:      && ch->pcdata->clan == victim->pcdata->clan ) )  return; }
fight.c:      if( !ch->master )
fight.c:         bug( "Check_attacker: %s bad AFF_CHARM", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c:         xREMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c:       * xSET_BIT(ch->master->act, PLR_ATTACKER);
fight.c:       || ch == victim || ch->level >= LEVEL_IMMORTAL || xIS_SET( ch->act, PLR_ATTACKER ) || xIS_SET( ch->act, PLR_KILLER ) )
fight.c:   xSET_BIT( ch->act, PLR_ATTACKER );
fight.c:   if( ch->fighting )
fight.c:      bug( "%s: %s -> %s (already fighting %s)", __func__, ch->name, victim->name, ch->fighting->who->name );
fight.c:   ch->num_fighting = 1;
fight.c:   ch->fighting = fight;
fight.c:    * ch->position = POS_FIGHTING; 
fight.c:      ch->position = POS_FIGHTING;
fight.c:      switch ( ch->style )
fight.c:            ch->position = POS_EVASIVE;
fight.c:            ch->position = POS_DEFENSIVE;
fight.c:            ch->position = POS_AGGRESSIVE;
fight.c:            ch->position = POS_BERSERK;
fight.c:            ch->position = POS_FIGHTING;
fight.c:   if( !ch->fighting )
fight.c:   return ch->fighting->who;
fight.c:   if( ch->fighting )
fight.c:      if( !char_died( ch->fighting->who ) )
fight.c:         --ch->fighting->who->num_fighting;
fight.c:      DISPOSE( ch->fighting );
fight.c:   ch->fighting = NULL;
fight.c:   if( ch->mount )
fight.c:      ch->position = POS_MOUNTED;
fight.c:      ch->position = POS_STANDING;
fight.c:   for( fch = first_char; fch; fch = fch->next )
fight.c:         for( i = 0; i < 32 && ch->xflags; i++ )
fight.c:      name = IS_NPC( ch ) ? ch->short_descr : ch->name;
fight.c:      obj = obj_to_room( obj, ch->in_room );
fight.c:   was_in_room = ch->in_room;
fight.c:         ch->in_room = pexit->to_room;
fight.c:   ch->in_room = was_in_room;
fight.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c:   lch = ch->leader ? ch->leader : ch;
fight.c:   for( gch = ch->in_room->first_person; gch; gch = gch_next )
fight.c:      gch_next = gch->next_in_room;
fight.c:      if( gch->level - lch->level > 8 )
fight.c:      if( gch->level - lch->level < -8 )
fight.c:      if( !gch->fighting )
fight.c:      gch->alignment = align_compute( gch, victim );
fight.c:        ch->pcdata->ap += (victim->level * get_curr_lck(ch));
fight.c:      for( obj = gch->first_carrying; obj; obj = obj_next )
fight.c:               obj = obj_to_room( obj, ch->in_room );
fight.c:   align = gch->alignment - victim->alignment;
fight.c:   if( gch->alignment > -350 && gch->alignment < 350 )
fight.c:      newalign = UMIN( gch->alignment + ( align - 500 ) / divalign, 1000 );
fight.c:      newalign = UMAX( gch->alignment + ( align + 500 ) / divalign, -1000 );
fight.c:      newalign = gch->alignment - ( int )( gch->alignment / divalign );
fight.c:   int gchlev = gch->level;
fight.c:   align = gch->alignment - victim->alignment;
fight.c:   if( gch->alignment > 300 && align < 250 )
fight.c:      xp_ratio = ( int )gch->played / gchlev;
fight.c:   if( ch->in_room != victim->in_room )
fight.c:      was_in_room = ch->in_room;
fight.c:      bug( "%s: bad dt %d from %s in %d.", __func__, dt, ch->name, ch->in_room->vnum );
fight.c:   if( dam == 0 && ( !IS_NPC( ch ) && ( IS_SET( ch->pcdata->flags, PCFLAG_GAG ) ) ) )
fight.c:         bug( "Dam_message: bad dt %d from %s in %d.", dt, ch->name, ch->in_room->vnum );
fight.c:         bug( "Dam_message: bad dt %d from %s in %d.", dt, ch->name, ch->in_room->vnum );
fight.c:   if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
fight.c:   if( ch->position == POS_FIGHTING
fight.c:       || ch->position == POS_EVASIVE
fight.c:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c:      if( ch->master == victim )
fight.c:         if( ch->master )
fight.c:            xSET_BIT( ch->master->act, PLR_ATTACKER );
fight.c:   if( ch->position == POS_FIGHTING
fight.c:       || ch->position == POS_EVASIVE
fight.c:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c:   if( !IS_NPC( victim ) && xIS_SET( ch->act, PLR_NICE ) )
fight.c:      log_printf_plus( LOG_NORMAL, ch->level, "%s: murder %s.", ch->name, victim->name );
fight.c:  // snprintf( buf, MAX_STRING_LENGTH, "Help!  I am being attacked by %s!", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_ARENA ) )
fight.c:   if( IS_SET( ch->in_room->area->flags, AFLAG_FREEKILL ) )
fight.c:   if( ch->in_room->vnum >= 29 && ch->in_room->vnum <= 43 )
fight.c:   if( !str_cmp( ch->in_room->area->filename, "arena.are" ) )
fight.c:            || ch->level - victim->level > 5
fight.c:            || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
fight.c:            snprintf( buf, MAX_STRING_LENGTH, " (%s)", ch->name );
fight.c:      if( ch->position == POS_FIGHTING
fight.c:          || ch->position == POS_EVASIVE
fight.c:          || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c:         if( ch->mount )
fight.c:            ch->position = POS_MOUNTED;
fight.c:            ch->position = POS_STANDING;
fight.c:   if( ch->move <= 0 )
fight.c:   if( !IS_NPC( ch ) && ch->position < POS_FIGHTING )
fight.c:   if( IS_NPC( ch ) && ch->position <= POS_SLEEPING )
fight.c:   was_in = ch->in_room;
fight.c:      xREMOVE_BIT( ch->affected_by, AFF_SNEAK );
fight.c:      if( ch->mount && ch->mount->fighting )
fight.c:         stop_fighting( ch->mount, TRUE );
fight.c:      if( ( now_in = ch->in_room ) == was_in )
fight.c:      ch->in_room = was_in;
fight.c:      ch->in_room = now_in;
fight.c:         los = ( int )( ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.2 );
fight.c:         if( ch->level < LEVEL_AVATAR )
fight.c:               if( ch->level > 1 )
fight.c:         if( wf && ch->pcdata->deity )
fight.c:            int level_ratio = URANGE( 1, wf->level / ch->level, MAX_LEVEL );
fight.c:            if( wf && wf->race == ch->pcdata->deity->npcrace )
fight.c:            else if( wf && wf->race == ch->pcdata->deity->npcfoe )
fight.c:   los = ( int )( ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.1 );
fight.c:   if( ch->level < LEVEL_AVATAR && number_bits( 3 ) == 1 )
fight.c:         if( ch->level > 1 )
fight.c.backup:   int oldgold = ch->gold;
fight.c.backup:      if( !CAN_WEAR( content, ITEM_TAKE ) && ch->level < sysdata.level_getobjnotake )
fight.c.backup:      ch->gold += content->value[0] * content->count;
fight.c.backup:   if( ch->gold - oldgold > 1 && ch->position > POS_SLEEPING )
fight.c.backup:      snprintf( buf, MAX_INPUT_LENGTH, "%d", ch->gold - oldgold );
fight.c.backup:   if( !ch->hunting || ch->hunting->who != victim )
fight.c.backup:   if( !ch->hating || ch->hating->who != victim )
fight.c.backup:   if( !ch->fearing || ch->fearing->who != victim )
fight.c.backup:   if( ch->hunting )
fight.c.backup:      STRFREE( ch->hunting->name );
fight.c.backup:      DISPOSE( ch->hunting );
fight.c.backup:      ch->hunting = NULL;
fight.c.backup:   if( ch->hating )
fight.c.backup:      STRFREE( ch->hating->name );
fight.c.backup:      DISPOSE( ch->hating );
fight.c.backup:      ch->hating = NULL;
fight.c.backup:   if( ch->fearing )
fight.c.backup:      STRFREE( ch->fearing->name );
fight.c.backup:      DISPOSE( ch->fearing );
fight.c.backup:      ch->fearing = NULL;
fight.c.backup:   if( ch->hunting )
fight.c.backup:   CREATE( ch->hunting, HHF_DATA, 1 );
fight.c.backup:   ch->hunting->name = QUICKLINK( victim->name );
fight.c.backup:   ch->hunting->who = victim;
fight.c.backup:   if( ch->hating )
fight.c.backup:   CREATE( ch->hating, HHF_DATA, 1 );
fight.c.backup:   ch->hating->name = QUICKLINK( victim->name );
fight.c.backup:   ch->hating->who = victim;
fight.c.backup:   if( ch->fearing )
fight.c.backup:   CREATE( ch->fearing, HHF_DATA, 1 );
fight.c.backup:   ch->fearing->name = QUICKLINK( victim->name );
fight.c.backup:   ch->fearing->who = victim;
fight.c.backup:      if( who_fighting( ch->fighting->who ) == ch && IS_AFFECTED( who_fighting( ch ), AFF_GRAPPLE ) )
fight.c.backup:      if( ch->fighting && ( ++ch->fighting->duration % 24 ) == 0 )
fight.c.backup:         ch->fighting->xp = ( ( ch->fighting->xp * 9 ) / 10 );
fight.c.backup:      for( timer = ch->first_timer; timer; timer = timer_next )
fight.c.backup:         if( ch->fighting && timer->type == TIMER_DO_FUN )
fight.c.backup:            tempsub = ch->substate;
fight.c.backup:            ch->substate = SUB_TIMER_DO_ABORT;
fight.c.backup:            ch->substate = tempsub;
fight.c.backup:               DISPOSE( ch->pcdata->nuisance );
fight.c.backup:               tempsub = ch->substate;
fight.c.backup:               ch->substate = timer->value;
fight.c.backup:               ch->substate = tempsub;
fight.c.backup:      for( paf = ch->first_affect; paf; paf = paf_next )
fight.c.backup:               ch->desc->character = ch->desc->original;
fight.c.backup:               ch->desc->original = NULL;
fight.c.backup:               ch->desc->character->desc = ch->desc;
fight.c.backup:               ch->desc->character->switched = NULL;
fight.c.backup:               ch->desc = NULL;
fight.c.backup:      if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
fight.c.backup:         log_printf( "violence_update: %s fighting %s in a SAFE room.", ch->name, victim->name );
fight.c.backup:      else if( IS_AWAKE( ch ) && ch->in_room == victim->in_room )
fight.c.backup:         if( !xIS_EMPTY( ch->attacks ) )
fight.c.backup:            if( 30 + ( ch->level / 4 ) >= number_percent(  ) )
fight.c.backup:                  if( xIS_SET( ch->attacks, attacktype ) )
fight.c.backup:                     retcode = spell_energy_drain( skill_lookup( "energy drain" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_fire_breath( skill_lookup( "fire breath" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_frost_breath( skill_lookup( "frost breath" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_acid_breath( skill_lookup( "acid breath" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_lightning_breath( skill_lookup( "lightning breath" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_gas_breath( skill_lookup( "gas breath" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_spiral_blast( skill_lookup( "spiral blast" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_poison( gsn_poison, ch->level, ch, victim );
fight.c.backup:                      * retcode = spell_nasty_poison( skill_lookup( "nasty poison" ), ch->level, ch, victim );
fight.c.backup:                      * retcode = spell_gaze( skill_lookup( "gaze" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_blindness( gsn_blindness, ch->level, ch, victim );
fight.c.backup:                     retcode = spell_cause_serious( skill_lookup( "cause serious" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_earthquake( skill_lookup( "earthquake" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_cause_critical( skill_lookup( "cause critical" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_curse( skill_lookup( "curse" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_flamestrike( skill_lookup( "flamestrike" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_harm( skill_lookup( "harm" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_fireball( skill_lookup( "fireball" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_colour_spray( skill_lookup( "colour spray" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_weaken( skill_lookup( "weaken" ), ch->level, ch, victim );
fight.c.backup:         if( !xIS_EMPTY( ch->defenses ) )
fight.c.backup:            if( 50 + ( ch->level / 4 ) > number_percent(  ) )
fight.c.backup:                  if( xIS_SET( ch->defenses, attacktype ) )
fight.c.backup:                     if( ch->hit < ch->max_hit )
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "cure light" ), ch->level, ch, ch );
fight.c.backup:                     if( ch->hit < ch->max_hit )
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "cure serious" ), ch->level, ch, ch );
fight.c.backup:                     if( ch->hit < ch->max_hit )
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "cure critical" ), ch->level, ch, ch );
fight.c.backup:                     if( ch->hit < ch->max_hit )
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "heal" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_dispel_magic( skill_lookup( "dispel magic" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_dispel_evil( skill_lookup( "dispel evil" ), ch->level, ch, victim );
fight.c.backup:                     retcode = spell_teleport( skill_lookup( "teleport" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "shockshield" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "venomshield" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "acidmist" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "fireshield" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "iceshield" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "true" ), ch->level, ch, ch );
fight.c.backup:                        retcode = spell_smaug( skill_lookup( "sanctuary" ), ch->level, ch, ch );
fight.c.backup:      for( rch = ch->in_room->first_person; rch; rch = trvch_next( lcr ) )
fight.c.backup:             && ( rch->fighting )
fight.c.backup:             && ( who_fighting( rch->fighting->who ) == ch )
fight.c.backup:             && ( !xIS_SET( rch->fighting->who->act, ACT_AUTONOMOUS ) ) && ( rch->style < ch->style ) )
fight.c.backup:            rch->fighting->who->fighting->who = rch;
fight.c.backup:         if( IS_AWAKE( rch ) && !rch->fighting )
fight.c.backup:               if( ( ( !IS_NPC( rch ) && rch->desc )
fight.c.backup:            if( IS_NPC( rch ) && !IS_AFFECTED( rch, AFF_CHARM ) && !xIS_SET( rch->act, ACT_NOASSIST )
fight.c.backup:                && !xIS_SET( rch->act, ACT_PET ) )
fight.c.backup:               if( rch->pIndexData == ch->pIndexData || number_bits( 3 ) == 0 )
fight.c.backup:                  for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
fight.c.backup:                        if( vch->mount && vch->mount == rch )
fight.c.backup:      if( xIS_SET( ch->act, PLR_NICE ) )
fight.c.backup:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_NOATTACK ) )
fight.c.backup:      dual_bonus = IS_NPC( ch ) ? ( ch->level / 10 ) : ( LEARNED( ch, gsn_dual_wield ) / 10 );
fight.c.backup:      schance = IS_NPC( ch ) ? ch->level : LEARNED( ch, gsn_dual_wield );
fight.c.backup:   if( ch->move < 10 )
fight.c.backup:   if( IS_NPC( ch ) && ch->numattacks > 0 )
fight.c.backup:      for( schance = 0; schance < ch->numattacks; schance++ )
fight.c.backup:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_second_attack ) + dual_bonus ) / 1.5 );
fight.c.backup:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_third_attack ) + ( dual_bonus * 1.5 ) ) / 2 );
fight.c.backup:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_fourth_attack ) + ( dual_bonus * 2 ) ) / 3 );
fight.c.backup:   schance = IS_NPC( ch ) ? ch->level : ( int )( ( LEARNED( ch, gsn_fifth_attack ) + ( dual_bonus * 3 ) ) / 4 );
fight.c.backup:   schance = IS_NPC( ch ) ? ( int )( ch->level / 2 ) : 0;
fight.c.backup:         move = encumbrance( ch, movement_loss[UMIN( SECT_MAX - 1, ch->in_room->sector_type )] );
fight.c.backup:      if( ch->move )
fight.c.backup:         ch->move = UMAX( 0, ch->move - move );
fight.c.backup:   if( !IS_NPC( ch ) && ch->level > 5 && wield )
fight.c.backup:       * ( 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) );
fight.c.backup:         bonus -= ch->pcdata->favor / -400;
fight.c.backup:      lvl = UMAX( 1, ( ch->level - 10 ) / 2 );
fight.c.backup:            return ch->level;
fight.c.backup:      lvl = ch->level / 2;
fight.c.backup:   if( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c.backup:   if( ch->fighting  /* make sure fight is already started */
fight.c.backup:       && dt == TYPE_UNDEFINED && IS_NPC( ch ) && !xIS_EMPTY( ch->attacks ) )
fight.c.backup:         if( xIS_SET( ch->attacks, attacktype ) )
fight.c.backup:      thac0_00 = ch->mobthac0;
fight.c.backup:      thac0_00 = class_table[ch->Class]->thac0_00;
fight.c.backup:      thac0_32 = class_table[ch->Class]->thac0_32;
fight.c.backup:   thac0 = interpolate( ch->level, thac0_00, thac0_32 ) - GET_HITROLL( ch );
fight.c.backup:   if( ch->fighting && ch->fighting->who == victim )
fight.c.backup:      short times = ch->fighting->timeskilled;
fight.c.backup:      dam = number_range( ch->barenumdie, ch->baresizedie * ch->barenumdie ) + ch->damplus;
fight.c.backup:   if( ch->position == POS_BERSERK )
fight.c.backup:   else if( ch->position == POS_AGGRESSIVE )
fight.c.backup:   else if( ch->position == POS_DEFENSIVE )
fight.c.backup:   else if( ch->position == POS_EVASIVE )
fight.c.backup:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c.backup:      dam *= ( 2 + URANGE( 2, ch->level - ( victim->level / 4 ), 30 ) / 8 );
fight.c.backup:      dam *= ( 2 + URANGE( 2, ch->level - ( victim->level / 4 ), 30 ) / 11 );
fight.c.backup:      dam *= ( 2 + URANGE( 2, ch->level - ( victim->level / 4 ), 30 ) / 16 );
fight.c.backup:      thac0_00 = ch->mobthac0;
fight.c.backup:      thac0_00 = class_table[ch->Class]->thac0_00;
fight.c.backup:      thac0_32 = class_table[ch->Class]->thac0_32;
fight.c.backup:   thac0 = interpolate( ch->level, thac0_00, thac0_32 ) - GET_HITROLL( ch ) + ( dist * 2 );
fight.c.backup:   victim_ac = ((((ch->pcdata->def + ch->pcdata->defplus) * ch->pcdata->deflevel) /15 ) * -1);
fight.c.backup:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c.backup:   if( IS_SET( ch->immune, ris ) && !IS_SET( ch->no_immune, ris ) )
fight.c.backup:   if( IS_SET( ch->resistant, ris ) && !IS_SET( ch->no_resistant, ris ) )
fight.c.backup:   if( IS_SET( ch->susceptible, ris ) && !IS_SET( ch->no_susceptible, ris ) )
fight.c.backup:      if( IS_NPC( ch ) && IS_SET( ch->immune, ris ) )
fight.c.backup:               victim->hunting->name = QUICKLINK( ch->name );
fight.c.backup:            victim->hating->name = QUICKLINK( ch->name );
fight.c.backup://      maxdam = ch->level * 80;
fight.c.backup://      maxdam = ch->level * 40;
fight.c.backup:	dam = (dam + ch->pcdata->str + ch->pcdata->att + ch->pcdata->attplus) * ch->pcdata->attlevel;
fight.c.backup:      bug( "** %s (lvl %d) -> %s **", ch->name, ch->level, victim->name );
fight.c.backup:         if( !victim->fighting && victim->in_room == ch->in_room )
fight.c.backup:         if( !ch->fighting && victim->in_room == ch->in_room )
fight.c.backup:             && victim->master && victim->master->in_room == ch->in_room && number_bits( 3 ) == 0 )
fight.c.backup:      for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c.backup:      for( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c.backup:                 ( ch->leader == victim ) ? victim : ch, NULL,
fight.c.backup:                 ( ch->leader == victim ) ? victim->master : ch->master, TO_NOTVICT );
fight.c.backup:            if( ch->leader == victim )
fight.c.backup:         if( ch->leader != NULL && !IS_NPC( ch->leader ) && !IS_PKILL( ch->leader ) )
fight.c.backup:            act( AT_ACTION, "$n disbands from $N's group.", ch, NULL, ch->master, TO_NOTVICT );
fight.c.backup:            for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c.backup:                  act( AT_ACTION, "$n disbands from $N's group.", ch, NULL, gch->master, TO_NOTVICT );
fight.c.backup:            for( gch = victim->in_room->first_person; gch; gch = gch->next_in_room )
fight.c.backup:                  act( AT_ACTION, "$n disbands from $N's group.", gch, NULL, gch->master, TO_NOTVICT );
fight.c.backup:         xREMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
fight.c.backup:         xREMOVE_BIT( ch->affected_by, AFF_HIDE );
fight.c.backup:      if( dt >= TYPE_HIT && ch->in_room == victim->in_room )
fight.c.backup:         if( IS_NPC( ch ) && xIS_SET( ch->defenses, DFND_DISARM ) && ch->level > 9 && number_percent(  ) < ch->level / 3 ) /* Was 2 try this --Shaddai */
fight.c.backup:         if( IS_NPC( ch ) && xIS_SET( ch->attacks, ATCK_TRIP ) && ch->level > 5 && number_percent(  ) < ch->level / 2 )
fight.c.backup:            if( ch->level < LEVEL_AVATAR )
fight.c.backup:   if( dam && ch != victim && !IS_NPC( ch ) && ch->fighting && ch->fighting->xp )
fight.c.backup:      if( ch->fighting->who == victim )
fight.c.backup:         xp_gain = ( int )( ch->fighting->xp * dam ) / victim->max_hit;
fight.c.backup:       && is_wielding_poisoned( ch ) && !IS_SET( victim->immune, RIS_POISON ) && !saves_poison_death( ch->level, victim ) )
fight.c.backup:            add_loginmsg( victim->name, 17, ( IS_NPC(ch) ? ch->short_descr : ch->name ) );
fight.c.backup:                   victim->name, victim->level, ( IS_NPC( ch ) ? ch->short_descr : ch->name ), victim->in_room->vnum );
fight.c.backup:         if( !IS_NPC( ch ) && !IS_IMMORTAL( ch ) && ch->pcdata->clan
fight.c.backup:             && ch->pcdata->clan->clan_type != CLAN_ORDER && ch->pcdata->clan->clan_type != CLAN_GUILD && victim != ch )
fight.c.backup:            snprintf( filename, 256, "%s%s.record", CLAN_DIR, ch->pcdata->clan->name );
fight.c.backup:                      ch->level,
fight.c.backup:                      ch->name,
fight.c.backup:                      "&P(&WUnclanned&P)", victim->name, ch->in_room->area->name );
fight.c.backup:            if( victim->pcdata && victim->pcdata->clan && victim->pcdata->clan->name == ch->pcdata->clan->name )
fight.c.backup:                     ch->level,
fight.c.backup:                     ch->pcdata->clan ? ch->pcdata->clan->badge :
fight.c.backup:                     "&P(&WUnclanned&P)", ch->name, victim->in_room->area->name );
fight.c.backup:            if( ch->pcdata && ch->pcdata->clan && ch->pcdata->clan->name == victim->pcdata->clan->name )
fight.c.backup:         for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c.backup:      if( !IS_NPC( ch ) && ch->pcdata->clan )
fight.c.backup:      if( ch->in_room == victim->in_room )
fight.c.backup:          && new_corpse->in_room == ch->in_room && can_see_obj( ch, new_corpse ) && ch->position > POS_SLEEPING )
fight.c.backup:         if( xIS_SET( ch->act, PLR_AUTOGOLD ) && !loot_coins_from_corpse( ch, new_corpse ) )
fight.c.backup:         if( new_corpse && !obj_extracted( new_corpse ) && new_corpse->in_room == ch->in_room
fight.c.backup:             && ch->position > POS_SLEEPING && can_see_obj( ch, new_corpse ) )
fight.c.backup:            if( xIS_SET( ch->act, PLR_AUTOLOOT ) )
fight.c.backup:            if( !char_died( ch ) && xIS_SET( ch->act, PLR_AUTOSAC ) && !obj_extracted( new_corpse )
fight.c.backup:                && new_corpse->in_room == ch->in_room && ch->position > POS_SLEEPING && can_see_obj( ch, new_corpse ) )
fight.c.backup:      bug( "Is_safe: %s opponent does not exist!", ch->name );
fight.c.backup:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
fight.c.backup:   if( calculate_age( ch ) < 18 || ch->level < 5 )
fight.c.backup:   if( ch->level - victim->level > 5 || victim->level - ch->level > 5 )
fight.c.backup:   if( IS_NPC( ch ) && !ch->master )
fight.c.backup:       && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) && IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) )
fight.c.backup:            level_ratio = URANGE( 1, ch->level, MAX_LEVEL );
fight.c.backup:            level_ratio = URANGE( 1, ch->level / victim->level, MAX_LEVEL );
fight.c.backup:         if( ch->pcdata->clan )
fight.c.backup:            ch->pcdata->clan->mkills++;
fight.c.backup:         ch->pcdata->mkills++;
fight.c.backup:         ch->in_room->area->mkills++;
fight.c.backup:         if( ch->pcdata->deity )
fight.c.backup:            if( victim->race == ch->pcdata->deity->npcrace )
fight.c.backup:            else if( victim->race == ch->pcdata->deity->npcfoe )
fight.c.backup:   if( ch == victim || ch->level >= LEVEL_IMMORTAL )
fight.c.backup:         ch->pcdata->pkills++;
fight.c.backup:         if( ch->pcdata->clan )
fight.c.backup:               ch->pcdata->clan->pkills[0]++;
fight.c.backup:               ch->pcdata->clan->pkills[1]++;
fight.c.backup:               ch->pcdata->clan->pkills[2]++;
fight.c.backup:               ch->pcdata->clan->pkills[3]++;
fight.c.backup:               ch->pcdata->clan->pkills[4]++;
fight.c.backup:               ch->pcdata->clan->pkills[5]++;
fight.c.backup:               ch->pcdata->clan->pkills[6]++;
fight.c.backup:         ch->pcdata->pkills++;
fight.c.backup:         ch->in_room->area->pkills++;
fight.c.backup:       && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) && IS_SET( victim->pcdata->flags, PCFLAG_DEADLY ) )
fight.c.backup:      if( !ch->pcdata->clan
fight.c.backup:          || ( ch->pcdata->clan->clan_type != CLAN_NOKILL
fight.c.backup:               && victim->pcdata->clan->clan_type != CLAN_NOKILL && ch->pcdata->clan != victim->pcdata->clan ) )
fight.c.backup:         if( ch->pcdata->clan )
fight.c.backup:               ch->pcdata->clan->pkills[0]++;
fight.c.backup:               ch->pcdata->clan->pkills[1]++;
fight.c.backup:               ch->pcdata->clan->pkills[2]++;
fight.c.backup:               ch->pcdata->clan->pkills[3]++;
fight.c.backup:               ch->pcdata->clan->pkills[4]++;
fight.c.backup:               ch->pcdata->clan->pkills[5]++;
fight.c.backup:               ch->pcdata->clan->pkills[6]++;
fight.c.backup:         ch->pcdata->pkills++;
fight.c.backup:         ch->hit = ch->max_hit;
fight.c.backup:         ch->mana = ch->max_mana;
fight.c.backup:         ch->move = ch->max_move;
fight.c.backup:         if( ch->pcdata )
fight.c.backup:            ch->pcdata->condition[COND_BLOODTHIRST] = ( 10 + ch->level );
fight.c.backup:            if( ch->level < 10 )
fight.c.backup:            else if( ch->level < 15 )
fight.c.backup:            else if( ch->level < 20 )
fight.c.backup:            else if( ch->level < 30 )
fight.c.backup:            else if( ch->level < 40 )
fight.c.backup:            else if( ch->level < 50 )
fight.c.backup:      if( !ch->master )
fight.c.backup:         bug( "Check_killer: %s bad AFF_CHARM", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c.backup:         xREMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c.backup:      if( ch->master )
fight.c.backup:         check_killer( ch->master, victim );
fight.c.backup:         level_ratio = URANGE( 1, ch->level / victim->level, LEVEL_AVATAR );
fight.c.backup:            if( ch->race == victim->pcdata->deity->npcrace )
fight.c.backup:            else if( ch->race == victim->pcdata->deity->npcfoe )
fight.c.backup:      if( ch->pcdata->clan )
fight.c.backup:         ch->pcdata->clan->illegal_pk++;
fight.c.backup:      ch->pcdata->illegal_pk++;
fight.c.backup:      ch->in_room->area->illegal_pk++;
fight.c.backup:         if( ch->level < 10 )
fight.c.backup:         else if( ch->level < 15 )
fight.c.backup:         else if( ch->level < 20 )
fight.c.backup:         else if( ch->level < 30 )
fight.c.backup:         else if( ch->level < 40 )
fight.c.backup:         else if( ch->level < 50 )
fight.c.backup:   if( xIS_SET( ch->act, PLR_KILLER ) )
fight.c.backup:   xSET_BIT( ch->act, PLR_KILLER );
fight.c.backup:   if( xIS_SET( ch->act, PLR_ATTACKER ) )
fight.c.backup:      xREMOVE_BIT( ch->act, PLR_ATTACKER );
fight.c.backup:    { if ( !(ch->pcdata->clan && victim->pcdata->clan
fight.c.backup:      && ch->pcdata->clan == victim->pcdata->clan ) )  return; }
fight.c.backup:      if( !ch->master )
fight.c.backup:         bug( "Check_attacker: %s bad AFF_CHARM", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c.backup:         xREMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c.backup:       * xSET_BIT(ch->master->act, PLR_ATTACKER);
fight.c.backup:       || ch == victim || ch->level >= LEVEL_IMMORTAL || xIS_SET( ch->act, PLR_ATTACKER ) || xIS_SET( ch->act, PLR_KILLER ) )
fight.c.backup:   xSET_BIT( ch->act, PLR_ATTACKER );
fight.c.backup:   if( ch->fighting )
fight.c.backup:      bug( "%s: %s -> %s (already fighting %s)", __func__, ch->name, victim->name, ch->fighting->who->name );
fight.c.backup:   ch->num_fighting = 1;
fight.c.backup:   ch->fighting = fight;
fight.c.backup:    * ch->position = POS_FIGHTING; 
fight.c.backup:      ch->position = POS_FIGHTING;
fight.c.backup:      switch ( ch->style )
fight.c.backup:            ch->position = POS_EVASIVE;
fight.c.backup:            ch->position = POS_DEFENSIVE;
fight.c.backup:            ch->position = POS_AGGRESSIVE;
fight.c.backup:            ch->position = POS_BERSERK;
fight.c.backup:            ch->position = POS_FIGHTING;
fight.c.backup:   if( !ch->fighting )
fight.c.backup:   return ch->fighting->who;
fight.c.backup:   if( ch->fighting )
fight.c.backup:      if( !char_died( ch->fighting->who ) )
fight.c.backup:         --ch->fighting->who->num_fighting;
fight.c.backup:      DISPOSE( ch->fighting );
fight.c.backup:   ch->fighting = NULL;
fight.c.backup:   if( ch->mount )
fight.c.backup:      ch->position = POS_MOUNTED;
fight.c.backup:      ch->position = POS_STANDING;
fight.c.backup:   for( fch = first_char; fch; fch = fch->next )
fight.c.backup:         for( i = 0; i < 32 && ch->xflags; i++ )
fight.c.backup:      name = IS_NPC( ch ) ? ch->short_descr : ch->name;
fight.c.backup:      obj = obj_to_room( obj, ch->in_room );
fight.c.backup:   was_in_room = ch->in_room;
fight.c.backup:         ch->in_room = pexit->to_room;
fight.c.backup:   ch->in_room = was_in_room;
fight.c.backup:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
fight.c.backup:   lch = ch->leader ? ch->leader : ch;
fight.c.backup:   for( gch = ch->in_room->first_person; gch; gch = gch_next )
fight.c.backup:      gch_next = gch->next_in_room;
fight.c.backup:      if( gch->level - lch->level > 8 )
fight.c.backup:      if( gch->level - lch->level < -8 )
fight.c.backup:      if( !gch->fighting )
fight.c.backup:      gch->alignment = align_compute( gch, victim );
fight.c.backup:        ch->pcdata->ap += (victim->level * get_curr_lck(ch));
fight.c.backup:      for( obj = gch->first_carrying; obj; obj = obj_next )
fight.c.backup:               obj = obj_to_room( obj, ch->in_room );
fight.c.backup:   align = gch->alignment - victim->alignment;
fight.c.backup:   if( gch->alignment > -350 && gch->alignment < 350 )
fight.c.backup:      newalign = UMIN( gch->alignment + ( align - 500 ) / divalign, 1000 );
fight.c.backup:      newalign = UMAX( gch->alignment + ( align + 500 ) / divalign, -1000 );
fight.c.backup:      newalign = gch->alignment - ( int )( gch->alignment / divalign );
fight.c.backup:   int gchlev = gch->level;
fight.c.backup:   align = gch->alignment - victim->alignment;
fight.c.backup:   if( gch->alignment > 300 && align < 250 )
fight.c.backup:      xp_ratio = ( int )gch->played / gchlev;
fight.c.backup:   if( ch->in_room != victim->in_room )
fight.c.backup:      was_in_room = ch->in_room;
fight.c.backup:      bug( "%s: bad dt %d from %s in %d.", __func__, dt, ch->name, ch->in_room->vnum );
fight.c.backup:   if( dam == 0 && ( !IS_NPC( ch ) && ( IS_SET( ch->pcdata->flags, PCFLAG_GAG ) ) ) )
fight.c.backup:         bug( "Dam_message: bad dt %d from %s in %d.", dt, ch->name, ch->in_room->vnum );
fight.c.backup:         bug( "Dam_message: bad dt %d from %s in %d.", dt, ch->name, ch->in_room->vnum );
fight.c.backup:   if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
fight.c.backup:   if( ch->position == POS_FIGHTING
fight.c.backup:       || ch->position == POS_EVASIVE
fight.c.backup:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c.backup:      if( ch->master == victim )
fight.c.backup:         if( ch->master )
fight.c.backup:            xSET_BIT( ch->master->act, PLR_ATTACKER );
fight.c.backup:   if( ch->position == POS_FIGHTING
fight.c.backup:       || ch->position == POS_EVASIVE
fight.c.backup:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c.backup:   if( !IS_NPC( victim ) && xIS_SET( ch->act, PLR_NICE ) )
fight.c.backup:      log_printf_plus( LOG_NORMAL, ch->level, "%s: murder %s.", ch->name, victim->name );
fight.c.backup:  // snprintf( buf, MAX_STRING_LENGTH, "Help!  I am being attacked by %s!", IS_NPC( ch ) ? ch->short_descr : ch->name );
fight.c.backup:   if( xIS_SET( ch->in_room->room_flags, ROOM_ARENA ) )
fight.c.backup:   if( IS_SET( ch->in_room->area->flags, AFLAG_FREEKILL ) )
fight.c.backup:   if( ch->in_room->vnum >= 29 && ch->in_room->vnum <= 43 )
fight.c.backup:   if( !str_cmp( ch->in_room->area->filename, "arena.are" ) )
fight.c.backup:            || ch->level - victim->level > 5
fight.c.backup:            || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
fight.c.backup:            snprintf( buf, MAX_STRING_LENGTH, " (%s)", ch->name );
fight.c.backup:      if( ch->position == POS_FIGHTING
fight.c.backup:          || ch->position == POS_EVASIVE
fight.c.backup:          || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
fight.c.backup:         if( ch->mount )
fight.c.backup:            ch->position = POS_MOUNTED;
fight.c.backup:            ch->position = POS_STANDING;
fight.c.backup:   if( ch->move <= 0 )
fight.c.backup:   if( !IS_NPC( ch ) && ch->position < POS_FIGHTING )
fight.c.backup:   if( IS_NPC( ch ) && ch->position <= POS_SLEEPING )
fight.c.backup:   was_in = ch->in_room;
fight.c.backup:      xREMOVE_BIT( ch->affected_by, AFF_SNEAK );
fight.c.backup:      if( ch->mount && ch->mount->fighting )
fight.c.backup:         stop_fighting( ch->mount, TRUE );
fight.c.backup:      if( ( now_in = ch->in_room ) == was_in )
fight.c.backup:      ch->in_room = was_in;
fight.c.backup:      ch->in_room = now_in;
fight.c.backup:         los = ( int )( ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.2 );
fight.c.backup:         if( ch->level < LEVEL_AVATAR )
fight.c.backup:               if( ch->level > 1 )
fight.c.backup:         if( wf && ch->pcdata->deity )
fight.c.backup:            int level_ratio = URANGE( 1, wf->level / ch->level, MAX_LEVEL );
fight.c.backup:            if( wf && wf->race == ch->pcdata->deity->npcrace )
fight.c.backup:            else if( wf && wf->race == ch->pcdata->deity->npcfoe )
fight.c.backup:   los = ( int )( ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.1 );
fight.c.backup:   if( ch->level < LEVEL_AVATAR && number_bits( 3 ) == 1 )
fight.c.backup:         if( ch->level > 1 )
handler.c:      else if( !ch->in_room )
handler.c:         first = ptr = ch->in_room->first_person;
handler.c:         first = ptr = ch->in_room->last_person;
handler.c:   return ch->exp;
handler.c:   wexp = ch->level * ch->level * ch->level * 5;
handler.c:   wexp += ch->max_hit;
handler.c:   wexp -= ( ch->armor - 50 ) * 2;
handler.c:   wexp += ( ch->barenumdie * ch->baresizedie + GET_DAMROLL( ch ) ) * 50;
handler.c:   wexp += GET_HITROLL( ch ) * ch->level * 10;
handler.c:   return class_table[ch->Class]->exp_base;
handler.c:   if( ch->desc && ch->desc->original )
handler.c:      ch = ch->desc->original;
handler.c:   if( ch->trust != 0 )
handler.c:      return ch->trust;
handler.c:   if( IS_NPC( ch ) && ch->level >= LEVEL_AVATAR )
handler.c:   return ch->level;
handler.c:   ch_days = ( ch->pcdata->month + 1 ) * sysdata.dayspermonth;
handler.c:   ch_days += ch->pcdata->day;
handler.c:   age = time_info.year - ch->pcdata->year;
handler.c:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_STR )
handler.c:   else if( class_table[ch->Class]->attr_second == APPLY_STR )
handler.c:   else if( class_table[ch->Class]->attr_deficient == APPLY_STR )
handler.c:   return URANGE( 3, ch->perm_str + ch->mod_str, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_INT )
handler.c:   else if( class_table[ch->Class]->attr_second == APPLY_INT )
handler.c:   else if( class_table[ch->Class]->attr_deficient == APPLY_INT )
handler.c:   return URANGE( 3, ch->perm_int + ch->mod_int, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_WIS )
handler.c:   else if( class_table[ch->Class]->attr_second == APPLY_WIS )
handler.c:   else if( class_table[ch->Class]->attr_deficient == APPLY_WIS )
handler.c:   return URANGE( 3, ch->perm_wis + ch->mod_wis, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_DEX )
handler.c:   else if( class_table[ch->Class]->attr_second == APPLY_DEX )
handler.c:   else if( class_table[ch->Class]->attr_deficient == APPLY_DEX )
handler.c:   return URANGE( 3, ch->perm_dex + ch->mod_dex, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_CON )
handler.c:   else if( class_table[ch->Class]->attr_second == APPLY_CON )
handler.c:   else if( class_table[ch->Class]->attr_deficient == APPLY_CON )
handler.c:   return URANGE( 3, ch->perm_con + ch->mod_con, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_CHA )
handler.c:   else if( class_table[ch->Class]->attr_second == APPLY_CHA )
handler.c:   else if( class_table[ch->Class]->attr_deficient == APPLY_CHA )
handler.c:   return URANGE( 3, ch->perm_cha + ch->mod_cha, max );
handler.c:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_LCK )
handler.c:   else if( class_table[ch->Class]->attr_second == APPLY_LCK )
handler.c:   else if( class_table[ch->Class]->attr_deficient == APPLY_LCK )
handler.c:   return URANGE( 3, ch->perm_lck + ch->mod_lck, max );
handler.c:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_IMMORTAL ) )
handler.c:      return ch->level * 200;
handler.c:   return URANGE( 5, ( ch->level + 15 ) / 5 + get_curr_dex( ch ) - 13 - penalty, 20 );
handler.c:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_IMMORTAL ) )
handler.c:   else if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_PROTOTYPE ) )
handler.c:         ch->pcdata->learned[sn] += mod;
handler.c:         ch->pcdata->learned[sn] = URANGE( 0, ch->pcdata->learned[sn] + mod, GET_ADEPT( ch, sn ) );
handler.c:      xSET_BITS( ch->affected_by, paf->bitvector );
handler.c:            xSET_BIT( ch->affected_by, AFF_RECURRINGSPELL );
handler.c:            bug( "affect_modify(%s) APPLY_RECURRINGSPELL with bad sn %d", ch->name, mod );
handler.c:      xREMOVE_BITS( ch->affected_by, paf->bitvector );
handler.c:            bug( "affect_modify(%s) APPLY_RECURRINGSPELL with bad sn %d", ch->name, mod );
handler.c:         xREMOVE_BIT( ch->affected_by, AFF_RECURRINGSPELL );
handler.c:            REMOVE_BIT( ch->affected_by.bits[0], mod );
handler.c:            xREMOVE_BIT( ch->affected_by, mod );
handler.c:            REMOVE_BIT( ch->resistant, mod );
handler.c:            REMOVE_BIT( ch->immune, mod );
handler.c:            REMOVE_BIT( ch->susceptible, mod );
handler.c:            SET_BIT( ch->affected_by.bits[0], mod );
handler.c:         bug( "%s: unknown location %d. (%s)", __func__, paf->location, ch->name );
handler.c:         ch->mod_str += mod;
handler.c:         ch->mod_dex += mod;
handler.c:         ch->mod_int += mod;
handler.c:         ch->mod_wis += mod;
handler.c:         ch->mod_con += mod;
handler.c:         ch->mod_cha += mod;
handler.c:         ch->mod_lck += mod;
handler.c:         ch->sex = ( ch->sex + mod ) % 3;
handler.c:         if( ch->sex < 0 )
handler.c:            ch->sex += 2;
handler.c:         ch->sex = URANGE( 0, ch->sex, 2 );
handler.c:         ch->height += mod;
handler.c:         ch->weight += mod;
handler.c:         ch->max_mana += mod;
handler.c:         ch->max_hit += mod;
handler.c:         ch->max_move += mod;
handler.c:         ch->armor += mod;
handler.c:         ch->hitroll += mod;
handler.c:         ch->damroll += mod;
handler.c:         ch->saving_poison_death += mod;
handler.c:         ch->saving_wand += mod;
handler.c:         ch->saving_para_petri += mod;
handler.c:         ch->saving_breath += mod;
handler.c:         ch->saving_spell_staff += mod;
handler.c:         SET_BIT( ch->affected_by.bits[0], mod );
handler.c:         xSET_BIT( ch->affected_by, mod );
handler.c:         SET_BIT( ch->resistant, mod );
handler.c:         SET_BIT( ch->immune, mod );
handler.c:         SET_BIT( ch->susceptible, mod );
handler.c:         REMOVE_BIT( ch->affected_by.bits[0], mod );
handler.c:            ch->pcdata->condition[COND_FULL] = URANGE( 0, ch->pcdata->condition[COND_FULL] + mod, 48 );
handler.c:            ch->pcdata->condition[COND_THIRST] = URANGE( 0, ch->pcdata->condition[COND_THIRST] + mod, 48 );
handler.c:            ch->pcdata->condition[COND_DRUNK] = URANGE( 0, ch->pcdata->condition[COND_DRUNK] + mod, 48 );
handler.c:            ch->pcdata->condition[COND_BLOODTHIRST] =
handler.c:               URANGE( 0, ch->pcdata->condition[COND_BLOODTHIRST] + mod, ch->level + 10 );
handler.c:         ch->mental_state = URANGE( -100, ch->mental_state + mod, 100 );
handler.c:         ch->emotional_state = URANGE( -100, ch->emotional_state + mod, 100 );
handler.c:         if( xIS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) || IS_SET( ch->immune, RIS_MAGIC )
handler.c:            if( ( retcode = ( *skill->spell_fun ) ( mod, ch->level, ch, ch ) ) == rCHAR_DIED || char_died( ch ) )
handler.c:      bug( "%s (%s, NULL)", __func__, ch->name );
handler.c:   LINK( paf_new, ch->first_affect, ch->last_affect, next, prev );
handler.c:   if( ch->in_room )
handler.c:      room_affect( ch->in_room, paf_new, TRUE );
handler.c:   if( !ch->first_affect )
handler.c:      bug( "%s (%s, %d): no affect.", __func__, ch->name, paf ? paf->type : 0 );
handler.c:   if( ch->in_room )
handler.c:      room_affect( ch->in_room, paf, FALSE );
handler.c:   UNLINK( paf, ch->first_affect, ch->last_affect, next, prev );
handler.c:   for( paf = ch->first_affect; paf; paf = paf_next )
handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c:   for( paf_old = ch->first_affect; paf_old; paf_old = paf_old->next )
handler.c:   xSET_BITS( ch->affected_by, paf->bitvector );
handler.c:         SET_BIT( ch->affected_by.bits[0], paf->modifier );
handler.c:         SET_BIT( ch->resistant, paf->modifier );
handler.c:         SET_BIT( ch->susceptible, paf->modifier );
handler.c:         SET_BIT( ch->immune, paf->modifier );
handler.c:   xCLEAR_BITS( ch->affected_by );
handler.c:   ch->resistant = 0;
handler.c:   ch->immune = 0;
handler.c:   ch->susceptible = 0;
handler.c:   xCLEAR_BITS( ch->no_affected_by );
handler.c:   ch->no_resistant = 0;
handler.c:   ch->no_immune = 0;
handler.c:   ch->no_susceptible = 0;
handler.c:   xSET_BITS( ch->affected_by, race_table[ch->race]->affected );
handler.c:   SET_BIT( ch->resistant, race_table[ch->race]->resist );
handler.c:   SET_BIT( ch->susceptible, race_table[ch->race]->suscept );
handler.c:   xSET_BITS( ch->affected_by, class_table[ch->Class]->affected );
handler.c:   SET_BIT( ch->resistant, class_table[ch->Class]->resist );
handler.c:   SET_BIT( ch->susceptible, class_table[ch->Class]->suscept );
handler.c:   if( ch->pcdata->deity )
handler.c:      if( ch->pcdata->favor > ch->pcdata->deity->affectednum )
handler.c:         xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
handler.c:      if( ch->pcdata->favor > ch->pcdata->deity->elementnum )
handler.c:         SET_BIT( ch->resistant, ch->pcdata->deity->element );
handler.c:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
handler.c:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c:   if( ch->in_room )
handler.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:   if( ch->in_room ) /* non-existant char booboo-fix --TRI */
handler.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c:   if( ch->morph )
handler.c:      xSET_BITS( ch->affected_by, ch->morph->affected_by );
handler.c:      SET_BIT( ch->immune, ch->morph->immune );
handler.c:      SET_BIT( ch->resistant, ch->morph->resistant );
handler.c:      SET_BIT( ch->susceptible, ch->morph->suscept );
handler.c:      xSET_BITS( ch->no_affected_by, ch->morph->no_affected_by );
handler.c:      SET_BIT( ch->no_immune, ch->morph->no_immune );
handler.c:      SET_BIT( ch->no_resistant, ch->morph->no_resistant );
handler.c:      SET_BIT( ch->no_susceptible, ch->morph->no_suscept );
handler.c:      xSET_BIT( ch->affected_by, AFF_HIDE );
handler.c:   if( !ch->in_room )
handler.c:      --ch->in_room->area->nplayer;
handler.c:       && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room->light > 0 )
handler.c:      --ch->in_room->light;
handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c:      room_affect( ch->in_room, paf, FALSE );
handler.c:   for( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c:   for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
handler.c:   UNLINK( ch, ch->in_room->first_person, ch->in_room->last_person, next_in_room, prev_in_room );
handler.c:   ch->was_in_room = ch->in_room;
handler.c:   ch->in_room = NULL;
handler.c:   ch->next_in_room = NULL;
handler.c:   ch->prev_in_room = NULL;
handler.c:      bug( "%s: %s -> NULL room!  Putting char in limbo (%d)", __func__, ch->name, ROOM_VNUM_LIMBO );
handler.c:   ch->in_room = pRoomIndex;
handler.c:   if( ch->home_vnum < 1 )
handler.c:      ch->home_vnum = ch->in_room->vnum;
handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c:   if( !ch->was_in_room )
handler.c:      ch->was_in_room = ch->in_room;
handler.c:      if( !IS_IMMORTAL( ch ) && ( !IS_NPC( ch ) || !xIS_SET( ch->act, ACT_PROTOTYPE ) ) )
handler.c:         return obj_to_room( obj, ch->in_room );
handler.c:   if( IS_NPC( ch ) && ch->pIndexData->pShop )
handler.c:      for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
handler.c:      if( !IS_NPC( ch ) || !ch->pIndexData->pShop )
handler.c:         LINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c:         for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
handler.c:               INSERT( obj, otmp, ch->first_carrying, next_content, prev_content );
handler.c:               INSERT( obj, otmp, ch->first_carrying, next_content, prev_content );
handler.c:            LINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c:      ch->carry_number += onum;
handler.c:      ch->carry_weight += oweight;
handler.c:      ch->carry_weight += oweight;
handler.c:   UNLINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c:   ch->carry_number -= get_obj_number( obj );
handler.c:   ch->carry_weight -= get_obj_weight( obj );
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:      bug( "%s: %s already equipped (%d).", __func__, ch->name, iWear );
handler.c:      obj = obj_to_room( obj, ch->in_room );
handler.c:   ch->armor -= apply_ac( obj, iWear );
handler.c:   ch->carry_number -= get_obj_number( obj );
handler.c:      ch->carry_weight -= get_obj_weight( obj );
handler.c:       && obj->item_type == ITEM_LIGHT && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room )
handler.c:      ++ch->in_room->light;
handler.c:   ch->carry_number += get_obj_number( obj );
handler.c:      ch->carry_weight += get_obj_weight( obj );
handler.c:   ch->armor += apply_ac( obj, obj->wear_loc );
handler.c:       && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room && ch->in_room->light > 0 )
handler.c:      --ch->in_room->light;
handler.c:   if( !ch->in_room )
handler.c:      bug( "%s: %s in NULL room.", __func__, ch->name ? ch->name : "???" );
handler.c:      bug( "%s: %s already died!", __func__, ch->name );
handler.c:   if( ch->mount )
handler.c:      xREMOVE_BIT( ch->mount->act, ACT_MOUNTED );
handler.c:      ch->mount = NULL;
handler.c:      ch->position = POS_STANDING;
handler.c:      xREMOVE_BIT( ch->act, ACT_MOUNTED );
handler.c:      for( wch = first_char; wch; wch = wch->next )
handler.c:         if( wch->mount == ch )
handler.c:            wch->mount = NULL;
handler.c:            wch->position = POS_STANDING;
handler.c:            if( wch->in_room == ch->in_room )
handler.c:         if( wch->pcdata && wch->pcdata->pet == ch )
handler.c:            wch->pcdata->pet = NULL;
handler.c:            if( wch->in_room == ch->in_room )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj_prev )
handler.c:      if( !IS_NPC( ch ) && ch->pcdata->clan )
handler.c:         location = get_room_index( ch->pcdata->clan->recall );
handler.c:         snprintf( buf, MAX_STRING_LENGTH, "Welcome back to the land of the living, %s", capitalize( ch->name ) );
handler.c:      ch->position = POS_RESTING;
handler.c:      --ch->pIndexData->count;
handler.c:   if( ch->desc && ch->desc->original )
handler.c:   if( ch->switched && ch->switched->desc )
handler.c:      do_return( ch->switched, "" );
handler.c:   for( wch = first_char; wch; wch = wch->next )
handler.c:      if( wch->reply == ch )
handler.c:         wch->reply = NULL;
handler.c:      if( wch->retell == ch )
handler.c:         wch->retell = NULL;
handler.c:   if( ch->desc )
handler.c:      if( ch->desc->character != ch )
handler.c:         ch->desc->character = NULL;
handler.c:         close_socket( ch->desc, FALSE );
handler.c:         ch->desc = NULL;
handler.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c:      if( can_see( ch, rch ) && ( nifty_is_name( arg, rch->name ) || ( IS_NPC( rch ) && vnum == rch->pIndexData->vnum ) ) )
handler.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c:      if( !can_see( ch, rch ) || !nifty_is_name_prefix( arg, rch->name ) )
handler.c:   for( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c:      if( can_see( ch, wch ) && ( nifty_is_name( arg, wch->name ) || ( IS_NPC( wch ) && vnum == wch->pIndexData->vnum ) ) )
handler.c:   for( wch = first_char; wch; wch = wch->next )
handler.c:      if( can_see( ch, wch ) && ( nifty_is_name( arg, wch->name ) || ( IS_NPC( wch ) && vnum == wch->pIndexData->vnum ) ) )
handler.c:   for( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c:      if( !can_see( ch, wch ) || !nifty_is_name_prefix( arg, wch->name ) )
handler.c:   for( wch = first_char; wch; wch = wch->next )
handler.c:      if( !can_see( ch, wch ) || !nifty_is_name_prefix( arg, wch->name ) )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:   obj = get_obj_list_rev( ch, argument, ch->in_room->last_content );
handler.c:   int ms = ch->mental_state;
handler.c:   int drunk = IS_NPC( ch ) ? 0 : ch->pcdata->condition[COND_DRUNK];
handler.c:   for( rch = pRoomIndex->first_person; rch; rch = rch->next_in_room )
handler.c:      if( !IS_NPC( rch ) && rch->pcdata && IS_IMMORTAL( rch )
handler.c:          && IS_SET( rch->pcdata->flags, PCFLAG_DND ) && get_trust( ch ) < get_trust( rch ) && can_see( ch, rch ) )
handler.c:   for( rch = pRoomIndex->first_person; rch; rch = rch->next_in_room )
handler.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c:      if( room_is_dark( ch->in_room ) && !IS_AFFECTED( ch, AFF_INFRARED ) )
handler.c:      if( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, "Newbie Council" ) )
handler.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c:   if( IS_NPC( ch ) && ch->pIndexData->vnum == MOB_VNUM_SUPERMOB )
handler.c:   if( room_is_dark( ch->in_room ) )
handler.c:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c:   if( IS_NPC( ch ) && ch->pIndexData->vnum == MOB_VNUM_SUPERMOB )
handler.c:   if( !ch->in_room || !ch->in_room->first_content )
handler.c:   for( check = ch->in_room->first_content; check; check = check->next_content )
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:         for( vch = room->first_person; vch; vch = vch->next )
handler.c:         for( vch = room->first_person; vch; vch = vch->next )
handler.c:   ch->perm_str = UMIN( 18, ch->perm_str );
handler.c:   ch->perm_wis = UMIN( 18, ch->perm_wis );
handler.c:   ch->perm_dex = UMIN( 18, ch->perm_dex );
handler.c:   ch->perm_int = UMIN( 18, ch->perm_int );
handler.c:   ch->perm_con = UMIN( 18, ch->perm_con );
handler.c:   ch->perm_cha = UMIN( 18, ch->perm_cha );
handler.c:   ch->perm_lck = UMIN( 18, ch->perm_lck );
handler.c:   ch->perm_str = UMAX( 9, ch->perm_str );
handler.c:   ch->perm_wis = UMAX( 9, ch->perm_wis );
handler.c:   ch->perm_dex = UMAX( 9, ch->perm_dex );
handler.c:   ch->perm_int = UMAX( 9, ch->perm_int );
handler.c:   ch->perm_con = UMAX( 9, ch->perm_con );
handler.c:   ch->perm_cha = UMAX( 9, ch->perm_cha );
handler.c:   ch->perm_lck = UMAX( 9, ch->perm_lck );
handler.c:   for( x = 0; x < strlen( ch->name ); x++ )
handler.c:      c = ch->name[x] + x;
handler.c:            ch->perm_str = UMIN( 18, ch->perm_str + a );
handler.c:            ch->perm_dex = UMIN( 18, ch->perm_dex + a );
handler.c:            ch->perm_wis = UMIN( 18, ch->perm_wis + a );
handler.c:            ch->perm_int = UMIN( 18, ch->perm_int + a );
handler.c:            ch->perm_con = UMIN( 18, ch->perm_con + a );
handler.c:            ch->perm_cha = UMIN( 18, ch->perm_cha + a );
handler.c:            ch->perm_lck = UMIN( 18, ch->perm_lck + a );
handler.c:            ch->perm_str = UMAX( 9, ch->perm_str - a );
handler.c:            ch->perm_dex = UMAX( 9, ch->perm_dex - a );
handler.c:            ch->perm_wis = UMAX( 9, ch->perm_wis - a );
handler.c:            ch->perm_int = UMAX( 9, ch->perm_int - a );
handler.c:            ch->perm_con = UMAX( 9, ch->perm_con - a );
handler.c:            ch->perm_cha = UMAX( 9, ch->perm_cha - a );
handler.c:            ch->perm_lck = UMAX( 9, ch->perm_lck - a );
handler.c:   for( aff = ch->first_affect; aff; aff = aff->next )
handler.c:   if( ch->in_room )
handler.c:      for( aff = ch->in_room->first_affect; aff; aff = aff->next )
handler.c:      for( aff = ch->in_room->first_permaffect; aff; aff = aff->next )
handler.c:   xCLEAR_BITS( ch->affected_by );
handler.c:   xSET_BITS( ch->affected_by, race_table[ch->race]->affected );
handler.c:   ch->mental_state = -10;
handler.c:   ch->hit = UMAX( 1, ch->hit );
handler.c:   ch->mana = UMAX( 1, ch->mana );
handler.c:   ch->move = UMAX( 1, ch->move );
handler.c:   ch->armor = 100;
handler.c:   ch->mod_str = 0;
handler.c:   ch->mod_dex = 0;
handler.c:   ch->mod_wis = 0;
handler.c:   ch->mod_int = 0;
handler.c:   ch->mod_con = 0;
handler.c:   ch->mod_cha = 0;
handler.c:   ch->mod_lck = 0;
handler.c:   ch->damroll = 0;
handler.c:   ch->hitroll = 0;
handler.c:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
handler.c:   ch->saving_breath = 0;
handler.c:   ch->saving_wand = 0;
handler.c:   ch->saving_para_petri = 0;
handler.c:   ch->saving_spell_staff = 0;
handler.c:   ch->saving_poison_death = 0;
handler.c:   for( aff = ch->first_affect; aff; aff = aff->next )
handler.c:   if( ch->in_room )
handler.c:      for( aff = ch->in_room->first_affect; aff; aff = aff->next )
handler.c:      for( aff = ch->in_room->first_permaffect; aff; aff = aff->next )
handler.c:   ch->carry_weight = 0;
handler.c:   ch->carry_number = 0;
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:         ch->carry_number += get_obj_number( obj );
handler.c:         ch->carry_weight += get_obj_weight( obj );
handler.c:   cur_room = ch->in_room;
handler.c:   ccd->room = ch->in_room;
handler.c:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c:      LINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c:   UNLINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c:   else if( ch->level >= tarea->low_soft_range || ch->level <= tarea->hi_soft_range )
handler.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
handler.c:       || victim->level >= ch->level + 15
handler.c:       || ( IS_NPC( victim ) && saves_spell_staff( ch->level, victim ) )
handler.c:   else if( ch->level >= tarea->low_hard_range && ch->level <= tarea->hi_hard_range )
handler.c:    clan_factor = 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) / 1000; 
handler.c:      deity_factor = ch->pcdata->favor / -500;
handler.c:   ms = 10 - abs( ch->mental_state );
handler.c:      deity_factor = ch->pcdata->favor / -500;
handler.c:   if( ch->mental_state < 0 )
handler.c:      ch->mental_state = URANGE( -100, ch->mental_state + c, 0 );
handler.c:   else if( ch->mental_state > 0 )
handler.c:      ch->mental_state = URANGE( 0, ch->mental_state - c, 100 );
handler.c:   if( !IS_NPC( ch ) && ch->pcdata->nuisance && ch->pcdata->nuisance->flags > 2 )
handler.c:      c += ( int )( .4 * ( ( ch->pcdata->nuisance->flags - 2 ) * ch->pcdata->nuisance->power ) );
handler.c:   if( ch->mental_state < 0 )
handler.c:      ch->mental_state = URANGE( -100, ch->mental_state - c, 100 );
handler.c:   else if( ch->mental_state > 0 )
handler.c:      ch->mental_state = URANGE( -100, ch->mental_state + c, 100 );
handler.c:      ch->mental_state -= c;
handler.c:   track = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
handler.c:      if( ch->pcdata->killed[x].vnum == vnum )
handler.c:         if( ch->pcdata->killed[x].count < 50 )
handler.c:            ++ch->pcdata->killed[x].count;
handler.c:      else if( ch->pcdata->killed[x].vnum == 0 )
handler.c:   memmove( ( char * )ch->pcdata->killed + sizeof( KILLED_DATA ),
handler.c:            ch->pcdata->killed, ( track - 1 ) * sizeof( KILLED_DATA ) );
handler.c:   ch->pcdata->killed[0].vnum = vnum;
handler.c:   ch->pcdata->killed[0].count = 1;
handler.c:      ch->pcdata->killed[track].vnum = 0;
handler.c:   track = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
handler.c:      if( ch->pcdata->killed[x].vnum == vnum )
handler.c:         return ch->pcdata->killed[x].count;
handler.c:      else if( ch->pcdata->killed[x].vnum == 0 )
handler.c:   for( ch = first_char; ch; ch = ch->next )
handler.c:   if( !ch->switched )
handler.c:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
handler.c:         if( !IS_NPC( ch ) && ch->pcdata->bestowments && is_name( cmd->name, ch->pcdata->bestowments )
handler.c:      set_char_color( AT_BLUE, ch->switched );
handler.c:      send_to_char( "You suddenly forfeit the power to switch!\n\r", ch->switched );
handler.c:   do_return( ch->switched, "" );
handler.c.backup:      else if( !ch->in_room )
handler.c.backup:         first = ptr = ch->in_room->first_person;
handler.c.backup:         first = ptr = ch->in_room->last_person;
handler.c.backup:   return ch->exp;
handler.c.backup:   wexp = ch->level * ch->level * ch->level * 5;
handler.c.backup:   wexp += ch->max_hit;
handler.c.backup:   wexp -= ( ch->armor - 50 ) * 2;
handler.c.backup:   wexp += ( ch->barenumdie * ch->baresizedie + GET_DAMROLL( ch ) ) * 50;
handler.c.backup:   wexp += GET_HITROLL( ch ) * ch->level * 10;
handler.c.backup:   return class_table[ch->Class]->exp_base;
handler.c.backup:   if( ch->desc && ch->desc->original )
handler.c.backup:      ch = ch->desc->original;
handler.c.backup:   if( ch->trust != 0 )
handler.c.backup:      return ch->trust;
handler.c.backup:   if( IS_NPC( ch ) && ch->level >= LEVEL_AVATAR )
handler.c.backup:   return ch->level;
handler.c.backup:   ch_days = ( ch->pcdata->month + 1 ) * sysdata.dayspermonth;
handler.c.backup:   ch_days += ch->pcdata->day;
handler.c.backup:   age = time_info.year - ch->pcdata->year;
handler.c.backup:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_STR )
handler.c.backup:   else if( class_table[ch->Class]->attr_second == APPLY_STR )
handler.c.backup:   else if( class_table[ch->Class]->attr_deficient == APPLY_STR )
handler.c.backup:   return URANGE( 3, ch->perm_str + ch->mod_str, max );
handler.c.backup:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_INT )
handler.c.backup:   else if( class_table[ch->Class]->attr_second == APPLY_INT )
handler.c.backup:   else if( class_table[ch->Class]->attr_deficient == APPLY_INT )
handler.c.backup:   return URANGE( 3, ch->perm_int + ch->mod_int, max );
handler.c.backup:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_WIS )
handler.c.backup:   else if( class_table[ch->Class]->attr_second == APPLY_WIS )
handler.c.backup:   else if( class_table[ch->Class]->attr_deficient == APPLY_WIS )
handler.c.backup:   return URANGE( 3, ch->perm_wis + ch->mod_wis, max );
handler.c.backup:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_DEX )
handler.c.backup:   else if( class_table[ch->Class]->attr_second == APPLY_DEX )
handler.c.backup:   else if( class_table[ch->Class]->attr_deficient == APPLY_DEX )
handler.c.backup:   return URANGE( 3, ch->perm_dex + ch->mod_dex, max );
handler.c.backup:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_CON )
handler.c.backup:   else if( class_table[ch->Class]->attr_second == APPLY_CON )
handler.c.backup:   else if( class_table[ch->Class]->attr_deficient == APPLY_CON )
handler.c.backup:   return URANGE( 3, ch->perm_con + ch->mod_con, max );
handler.c.backup:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_CHA )
handler.c.backup:   else if( class_table[ch->Class]->attr_second == APPLY_CHA )
handler.c.backup:   else if( class_table[ch->Class]->attr_deficient == APPLY_CHA )
handler.c.backup:   return URANGE( 3, ch->perm_cha + ch->mod_cha, max );
handler.c.backup:   if( IS_NPC( ch ) || class_table[ch->Class]->attr_prime == APPLY_LCK )
handler.c.backup:   else if( class_table[ch->Class]->attr_second == APPLY_LCK )
handler.c.backup:   else if( class_table[ch->Class]->attr_deficient == APPLY_LCK )
handler.c.backup:   return URANGE( 3, ch->perm_lck + ch->mod_lck, max );
handler.c.backup:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c.backup:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_IMMORTAL ) )
handler.c.backup:      return ch->level * 200;
handler.c.backup:   return URANGE( 5, ( ch->level + 15 ) / 5 + get_curr_dex( ch ) - 13 - penalty, 20 );
handler.c.backup:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c.backup:   if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_IMMORTAL ) )
handler.c.backup:   else if( IS_NPC( ch ) && xIS_SET( ch->act, ACT_PROTOTYPE ) )
handler.c.backup:         ch->pcdata->learned[sn] += mod;
handler.c.backup:         ch->pcdata->learned[sn] = URANGE( 0, ch->pcdata->learned[sn] + mod, GET_ADEPT( ch, sn ) );
handler.c.backup:      xSET_BITS( ch->affected_by, paf->bitvector );
handler.c.backup:            xSET_BIT( ch->affected_by, AFF_RECURRINGSPELL );
handler.c.backup:            bug( "affect_modify(%s) APPLY_RECURRINGSPELL with bad sn %d", ch->name, mod );
handler.c.backup:      xREMOVE_BITS( ch->affected_by, paf->bitvector );
handler.c.backup:            bug( "affect_modify(%s) APPLY_RECURRINGSPELL with bad sn %d", ch->name, mod );
handler.c.backup:         xREMOVE_BIT( ch->affected_by, AFF_RECURRINGSPELL );
handler.c.backup:            REMOVE_BIT( ch->affected_by.bits[0], mod );
handler.c.backup:            xREMOVE_BIT( ch->affected_by, mod );
handler.c.backup:            REMOVE_BIT( ch->resistant, mod );
handler.c.backup:            REMOVE_BIT( ch->immune, mod );
handler.c.backup:            REMOVE_BIT( ch->susceptible, mod );
handler.c.backup:            SET_BIT( ch->affected_by.bits[0], mod );
handler.c.backup:         bug( "%s: unknown location %d. (%s)", __func__, paf->location, ch->name );
handler.c.backup:         ch->mod_str += mod;
handler.c.backup:         ch->mod_dex += mod;
handler.c.backup:         ch->mod_int += mod;
handler.c.backup:         ch->mod_wis += mod;
handler.c.backup:         ch->mod_con += mod;
handler.c.backup:         ch->mod_cha += mod;
handler.c.backup:         ch->mod_lck += mod;
handler.c.backup:         ch->sex = ( ch->sex + mod ) % 3;
handler.c.backup:         if( ch->sex < 0 )
handler.c.backup:            ch->sex += 2;
handler.c.backup:         ch->sex = URANGE( 0, ch->sex, 2 );
handler.c.backup:         ch->height += mod;
handler.c.backup:         ch->weight += mod;
handler.c.backup:         ch->max_mana += mod;
handler.c.backup:         ch->max_hit += mod;
handler.c.backup:         ch->max_move += mod;
handler.c.backup:         ch->armor += mod;
handler.c.backup:         ch->hitroll += mod;
handler.c.backup:         ch->damroll += mod;
handler.c.backup:         ch->saving_poison_death += mod;
handler.c.backup:         ch->saving_wand += mod;
handler.c.backup:         ch->saving_para_petri += mod;
handler.c.backup:         ch->saving_breath += mod;
handler.c.backup:         ch->saving_spell_staff += mod;
handler.c.backup:         SET_BIT( ch->affected_by.bits[0], mod );
handler.c.backup:         xSET_BIT( ch->affected_by, mod );
handler.c.backup:         SET_BIT( ch->resistant, mod );
handler.c.backup:         SET_BIT( ch->immune, mod );
handler.c.backup:         SET_BIT( ch->susceptible, mod );
handler.c.backup:         REMOVE_BIT( ch->affected_by.bits[0], mod );
handler.c.backup:            ch->pcdata->condition[COND_FULL] = URANGE( 0, ch->pcdata->condition[COND_FULL] + mod, 48 );
handler.c.backup:            ch->pcdata->condition[COND_THIRST] = URANGE( 0, ch->pcdata->condition[COND_THIRST] + mod, 48 );
handler.c.backup:            ch->pcdata->condition[COND_DRUNK] = URANGE( 0, ch->pcdata->condition[COND_DRUNK] + mod, 48 );
handler.c.backup:            ch->pcdata->condition[COND_BLOODTHIRST] =
handler.c.backup:               URANGE( 0, ch->pcdata->condition[COND_BLOODTHIRST] + mod, ch->level + 10 );
handler.c.backup:         ch->mental_state = URANGE( -100, ch->mental_state + mod, 100 );
handler.c.backup:         ch->emotional_state = URANGE( -100, ch->emotional_state + mod, 100 );
handler.c.backup:         if( xIS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) || IS_SET( ch->immune, RIS_MAGIC )
handler.c.backup:            if( ( retcode = ( *skill->spell_fun ) ( mod, ch->level, ch, ch ) ) == rCHAR_DIED || char_died( ch ) )
handler.c.backup:      bug( "%s (%s, NULL)", __func__, ch->name );
handler.c.backup:   LINK( paf_new, ch->first_affect, ch->last_affect, next, prev );
handler.c.backup:   if( ch->in_room )
handler.c.backup:      room_affect( ch->in_room, paf_new, TRUE );
handler.c.backup:   if( !ch->first_affect )
handler.c.backup:      bug( "%s (%s, %d): no affect.", __func__, ch->name, paf ? paf->type : 0 );
handler.c.backup:   if( ch->in_room )
handler.c.backup:      room_affect( ch->in_room, paf, FALSE );
handler.c.backup:   UNLINK( paf, ch->first_affect, ch->last_affect, next, prev );
handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf_next )
handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c.backup:   for( paf_old = ch->first_affect; paf_old; paf_old = paf_old->next )
handler.c.backup:   xSET_BITS( ch->affected_by, paf->bitvector );
handler.c.backup:         SET_BIT( ch->affected_by.bits[0], paf->modifier );
handler.c.backup:         SET_BIT( ch->resistant, paf->modifier );
handler.c.backup:         SET_BIT( ch->susceptible, paf->modifier );
handler.c.backup:         SET_BIT( ch->immune, paf->modifier );
handler.c.backup:   xCLEAR_BITS( ch->affected_by );
handler.c.backup:   ch->resistant = 0;
handler.c.backup:   ch->immune = 0;
handler.c.backup:   ch->susceptible = 0;
handler.c.backup:   xCLEAR_BITS( ch->no_affected_by );
handler.c.backup:   ch->no_resistant = 0;
handler.c.backup:   ch->no_immune = 0;
handler.c.backup:   ch->no_susceptible = 0;
handler.c.backup:   xSET_BITS( ch->affected_by, race_table[ch->race]->affected );
handler.c.backup:   SET_BIT( ch->resistant, race_table[ch->race]->resist );
handler.c.backup:   SET_BIT( ch->susceptible, race_table[ch->race]->suscept );
handler.c.backup:   xSET_BITS( ch->affected_by, class_table[ch->Class]->affected );
handler.c.backup:   SET_BIT( ch->resistant, class_table[ch->Class]->resist );
handler.c.backup:   SET_BIT( ch->susceptible, class_table[ch->Class]->suscept );
handler.c.backup:   if( ch->pcdata->deity )
handler.c.backup:      if( ch->pcdata->favor > ch->pcdata->deity->affectednum )
handler.c.backup:         xSET_BITS( ch->affected_by, ch->pcdata->deity->affected );
handler.c.backup:      if( ch->pcdata->favor > ch->pcdata->deity->elementnum )
handler.c.backup:         SET_BIT( ch->resistant, ch->pcdata->deity->element );
handler.c.backup:      if( ch->pcdata->favor < ch->pcdata->deity->susceptnum )
handler.c.backup:         SET_BIT( ch->susceptible, ch->pcdata->deity->suscept );
handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c.backup:   if( ch->in_room )
handler.c.backup:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c.backup:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
handler.c.backup:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c.backup:   if( ch->in_room ) /* non-existant char booboo-fix --TRI */
handler.c.backup:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c.backup:   if( ch->morph )
handler.c.backup:      xSET_BITS( ch->affected_by, ch->morph->affected_by );
handler.c.backup:      SET_BIT( ch->immune, ch->morph->immune );
handler.c.backup:      SET_BIT( ch->resistant, ch->morph->resistant );
handler.c.backup:      SET_BIT( ch->susceptible, ch->morph->suscept );
handler.c.backup:      xSET_BITS( ch->no_affected_by, ch->morph->no_affected_by );
handler.c.backup:      SET_BIT( ch->no_immune, ch->morph->no_immune );
handler.c.backup:      SET_BIT( ch->no_resistant, ch->morph->no_resistant );
handler.c.backup:      SET_BIT( ch->no_susceptible, ch->morph->no_suscept );
handler.c.backup:      xSET_BIT( ch->affected_by, AFF_HIDE );
handler.c.backup:   if( !ch->in_room )
handler.c.backup:      --ch->in_room->area->nplayer;
handler.c.backup:       && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room->light > 0 )
handler.c.backup:      --ch->in_room->light;
handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c.backup:      room_affect( ch->in_room, paf, FALSE );
handler.c.backup:   for( paf = ch->in_room->first_affect; paf; paf = paf->next )
handler.c.backup:   for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
handler.c.backup:   UNLINK( ch, ch->in_room->first_person, ch->in_room->last_person, next_in_room, prev_in_room );
handler.c.backup:   ch->was_in_room = ch->in_room;
handler.c.backup:   ch->in_room = NULL;
handler.c.backup:   ch->next_in_room = NULL;
handler.c.backup:   ch->prev_in_room = NULL;
handler.c.backup:      bug( "%s: %s -> NULL room!  Putting char in limbo (%d)", __func__, ch->name, ROOM_VNUM_LIMBO );
handler.c.backup:   ch->in_room = pRoomIndex;
handler.c.backup:   if( ch->home_vnum < 1 )
handler.c.backup:      ch->home_vnum = ch->in_room->vnum;
handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
handler.c.backup:   if( !ch->was_in_room )
handler.c.backup:      ch->was_in_room = ch->in_room;
handler.c.backup:      if( !IS_IMMORTAL( ch ) && ( !IS_NPC( ch ) || !xIS_SET( ch->act, ACT_PROTOTYPE ) ) )
handler.c.backup:         return obj_to_room( obj, ch->in_room );
handler.c.backup:   if( IS_NPC( ch ) && ch->pIndexData->pShop )
handler.c.backup:      for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
handler.c.backup:      if( !IS_NPC( ch ) || !ch->pIndexData->pShop )
handler.c.backup:         LINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c.backup:         for( otmp = ch->first_carrying; otmp; otmp = otmp->next_content )
handler.c.backup:               INSERT( obj, otmp, ch->first_carrying, next_content, prev_content );
handler.c.backup:               INSERT( obj, otmp, ch->first_carrying, next_content, prev_content );
handler.c.backup:            LINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c.backup:      ch->carry_number += onum;
handler.c.backup:      ch->carry_weight += oweight;
handler.c.backup:      ch->carry_weight += oweight;
handler.c.backup:   UNLINK( obj, ch->first_carrying, ch->last_carrying, next_content, prev_content );
handler.c.backup:   ch->carry_number -= get_obj_number( obj );
handler.c.backup:   ch->carry_weight -= get_obj_weight( obj );
handler.c.backup:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c.backup:      bug( "%s: %s already equipped (%d).", __func__, ch->name, iWear );
handler.c.backup:      obj = obj_to_room( obj, ch->in_room );
handler.c.backup:   ch->armor -= apply_ac( obj, iWear );
handler.c.backup:   ch->carry_number -= get_obj_number( obj );
handler.c.backup:      ch->carry_weight -= get_obj_weight( obj );
handler.c.backup:       && obj->item_type == ITEM_LIGHT && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room )
handler.c.backup:      ++ch->in_room->light;
handler.c.backup:   ch->carry_number += get_obj_number( obj );
handler.c.backup:      ch->carry_weight += get_obj_weight( obj );
handler.c.backup:   ch->armor += apply_ac( obj, obj->wear_loc );
handler.c.backup:       && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room && ch->in_room->light > 0 )
handler.c.backup:      --ch->in_room->light;
handler.c.backup:   if( !ch->in_room )
handler.c.backup:      bug( "%s: %s in NULL room.", __func__, ch->name ? ch->name : "???" );
handler.c.backup:      bug( "%s: %s already died!", __func__, ch->name );
handler.c.backup:   if( ch->mount )
handler.c.backup:      xREMOVE_BIT( ch->mount->act, ACT_MOUNTED );
handler.c.backup:      ch->mount = NULL;
handler.c.backup:      ch->position = POS_STANDING;
handler.c.backup:      xREMOVE_BIT( ch->act, ACT_MOUNTED );
handler.c.backup:      for( wch = first_char; wch; wch = wch->next )
handler.c.backup:         if( wch->mount == ch )
handler.c.backup:            wch->mount = NULL;
handler.c.backup:            wch->position = POS_STANDING;
handler.c.backup:            if( wch->in_room == ch->in_room )
handler.c.backup:         if( wch->pcdata && wch->pcdata->pet == ch )
handler.c.backup:            wch->pcdata->pet = NULL;
handler.c.backup:            if( wch->in_room == ch->in_room )
handler.c.backup:   for( obj = ch->last_carrying; obj; obj = obj_prev )
handler.c.backup:      if( !IS_NPC( ch ) && ch->pcdata->clan )
handler.c.backup:         location = get_room_index( ch->pcdata->clan->recall );
handler.c.backup:         snprintf( buf, MAX_STRING_LENGTH, "Welcome back to the land of the living, %s", capitalize( ch->name ) );
handler.c.backup:      ch->position = POS_RESTING;
handler.c.backup:      --ch->pIndexData->count;
handler.c.backup:   if( ch->desc && ch->desc->original )
handler.c.backup:   if( ch->switched && ch->switched->desc )
handler.c.backup:      do_return( ch->switched, "" );
handler.c.backup:   for( wch = first_char; wch; wch = wch->next )
handler.c.backup:      if( wch->reply == ch )
handler.c.backup:         wch->reply = NULL;
handler.c.backup:      if( wch->retell == ch )
handler.c.backup:         wch->retell = NULL;
handler.c.backup:   if( ch->desc )
handler.c.backup:      if( ch->desc->character != ch )
handler.c.backup:         ch->desc->character = NULL;
handler.c.backup:         close_socket( ch->desc, FALSE );
handler.c.backup:         ch->desc = NULL;
handler.c.backup:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c.backup:      if( can_see( ch, rch ) && ( nifty_is_name( arg, rch->name ) || ( IS_NPC( rch ) && vnum == rch->pIndexData->vnum ) ) )
handler.c.backup:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
handler.c.backup:      if( !can_see( ch, rch ) || !nifty_is_name_prefix( arg, rch->name ) )
handler.c.backup:   for( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c.backup:      if( can_see( ch, wch ) && ( nifty_is_name( arg, wch->name ) || ( IS_NPC( wch ) && vnum == wch->pIndexData->vnum ) ) )
handler.c.backup:   for( wch = first_char; wch; wch = wch->next )
handler.c.backup:      if( can_see( ch, wch ) && ( nifty_is_name( arg, wch->name ) || ( IS_NPC( wch ) && vnum == wch->pIndexData->vnum ) ) )
handler.c.backup:   for( wch = ch->in_room->first_person; wch; wch = wch->next_in_room )
handler.c.backup:      if( !can_see( ch, wch ) || !nifty_is_name_prefix( arg, wch->name ) )
handler.c.backup:   for( wch = first_char; wch; wch = wch->next )
handler.c.backup:      if( !can_see( ch, wch ) || !nifty_is_name_prefix( arg, wch->name ) )
handler.c.backup:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c.backup:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c.backup:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c.backup:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c.backup:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c.backup:   obj = get_obj_list_rev( ch, argument, ch->in_room->last_content );
handler.c.backup:   int ms = ch->mental_state;
handler.c.backup:   int drunk = IS_NPC( ch ) ? 0 : ch->pcdata->condition[COND_DRUNK];
handler.c.backup:   for( rch = pRoomIndex->first_person; rch; rch = rch->next_in_room )
handler.c.backup:      if( !IS_NPC( rch ) && rch->pcdata && IS_IMMORTAL( rch )
handler.c.backup:          && IS_SET( rch->pcdata->flags, PCFLAG_DND ) && get_trust( ch ) < get_trust( rch ) && can_see( ch, rch ) )
handler.c.backup:   for( rch = pRoomIndex->first_person; rch; rch = rch->next_in_room )
handler.c.backup:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c.backup:      if( room_is_dark( ch->in_room ) && !IS_AFFECTED( ch, AFF_INFRARED ) )
handler.c.backup:      if( ch->pcdata->council && !str_cmp( ch->pcdata->council->name, "Newbie Council" ) )
handler.c.backup:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_HOLYLIGHT ) )
handler.c.backup:   if( IS_NPC( ch ) && ch->pIndexData->vnum == MOB_VNUM_SUPERMOB )
handler.c.backup:   if( room_is_dark( ch->in_room ) )
handler.c.backup:   if( !IS_NPC( ch ) && ch->level >= LEVEL_IMMORTAL )
handler.c.backup:   if( IS_NPC( ch ) && ch->pIndexData->vnum == MOB_VNUM_SUPERMOB )
handler.c.backup:   if( !ch->in_room || !ch->in_room->first_content )
handler.c.backup:   for( check = ch->in_room->first_content; check; check = check->next_content )
handler.c.backup:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c.backup:         for( vch = room->first_person; vch; vch = vch->next )
handler.c.backup:         for( vch = room->first_person; vch; vch = vch->next )
handler.c.backup:   ch->perm_str = UMIN( 18, ch->perm_str );
handler.c.backup:   ch->perm_wis = UMIN( 18, ch->perm_wis );
handler.c.backup:   ch->perm_dex = UMIN( 18, ch->perm_dex );
handler.c.backup:   ch->perm_int = UMIN( 18, ch->perm_int );
handler.c.backup:   ch->perm_con = UMIN( 18, ch->perm_con );
handler.c.backup:   ch->perm_cha = UMIN( 18, ch->perm_cha );
handler.c.backup:   ch->perm_lck = UMIN( 18, ch->perm_lck );
handler.c.backup:   ch->perm_str = UMAX( 9, ch->perm_str );
handler.c.backup:   ch->perm_wis = UMAX( 9, ch->perm_wis );
handler.c.backup:   ch->perm_dex = UMAX( 9, ch->perm_dex );
handler.c.backup:   ch->perm_int = UMAX( 9, ch->perm_int );
handler.c.backup:   ch->perm_con = UMAX( 9, ch->perm_con );
handler.c.backup:   ch->perm_cha = UMAX( 9, ch->perm_cha );
handler.c.backup:   ch->perm_lck = UMAX( 9, ch->perm_lck );
handler.c.backup:   for( x = 0; x < strlen( ch->name ); x++ )
handler.c.backup:      c = ch->name[x] + x;
handler.c.backup:            ch->perm_str = UMIN( 18, ch->perm_str + a );
handler.c.backup:            ch->perm_dex = UMIN( 18, ch->perm_dex + a );
handler.c.backup:            ch->perm_wis = UMIN( 18, ch->perm_wis + a );
handler.c.backup:            ch->perm_int = UMIN( 18, ch->perm_int + a );
handler.c.backup:            ch->perm_con = UMIN( 18, ch->perm_con + a );
handler.c.backup:            ch->perm_cha = UMIN( 18, ch->perm_cha + a );
handler.c.backup:            ch->perm_lck = UMIN( 18, ch->perm_lck + a );
handler.c.backup:            ch->perm_str = UMAX( 9, ch->perm_str - a );
handler.c.backup:            ch->perm_dex = UMAX( 9, ch->perm_dex - a );
handler.c.backup:            ch->perm_wis = UMAX( 9, ch->perm_wis - a );
handler.c.backup:            ch->perm_int = UMAX( 9, ch->perm_int - a );
handler.c.backup:            ch->perm_con = UMAX( 9, ch->perm_con - a );
handler.c.backup:            ch->perm_cha = UMAX( 9, ch->perm_cha - a );
handler.c.backup:            ch->perm_lck = UMAX( 9, ch->perm_lck - a );
handler.c.backup:   for( aff = ch->first_affect; aff; aff = aff->next )
handler.c.backup:   if( ch->in_room )
handler.c.backup:      for( aff = ch->in_room->first_affect; aff; aff = aff->next )
handler.c.backup:      for( aff = ch->in_room->first_permaffect; aff; aff = aff->next )
handler.c.backup:   xCLEAR_BITS( ch->affected_by );
handler.c.backup:   xSET_BITS( ch->affected_by, race_table[ch->race]->affected );
handler.c.backup:   ch->mental_state = -10;
handler.c.backup:   ch->hit = UMAX( 1, ch->hit );
handler.c.backup:   ch->mana = UMAX( 1, ch->mana );
handler.c.backup:   ch->move = UMAX( 1, ch->move );
handler.c.backup:   ch->armor = 100;
handler.c.backup:   ch->mod_str = 0;
handler.c.backup:   ch->mod_dex = 0;
handler.c.backup:   ch->mod_wis = 0;
handler.c.backup:   ch->mod_int = 0;
handler.c.backup:   ch->mod_con = 0;
handler.c.backup:   ch->mod_cha = 0;
handler.c.backup:   ch->mod_lck = 0;
handler.c.backup:   ch->damroll = 0;
handler.c.backup:   ch->hitroll = 0;
handler.c.backup:   ch->alignment = URANGE( -1000, ch->alignment, 1000 );
handler.c.backup:   ch->saving_breath = 0;
handler.c.backup:   ch->saving_wand = 0;
handler.c.backup:   ch->saving_para_petri = 0;
handler.c.backup:   ch->saving_spell_staff = 0;
handler.c.backup:   ch->saving_poison_death = 0;
handler.c.backup:   for( aff = ch->first_affect; aff; aff = aff->next )
handler.c.backup:   if( ch->in_room )
handler.c.backup:      for( aff = ch->in_room->first_affect; aff; aff = aff->next )
handler.c.backup:      for( aff = ch->in_room->first_permaffect; aff; aff = aff->next )
handler.c.backup:   ch->carry_weight = 0;
handler.c.backup:   ch->carry_number = 0;
handler.c.backup:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c.backup:         ch->carry_number += get_obj_number( obj );
handler.c.backup:         ch->carry_weight += get_obj_weight( obj );
handler.c.backup:   cur_room = ch->in_room;
handler.c.backup:   ccd->room = ch->in_room;
handler.c.backup:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c.backup:      LINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c.backup:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c.backup:   UNLINK( timer, ch->first_timer, ch->last_timer, next, prev );
handler.c.backup:   for( timer = ch->first_timer; timer; timer = timer->next )
handler.c.backup:   else if( ch->level >= tarea->low_soft_range || ch->level <= tarea->hi_soft_range )
handler.c.backup:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
handler.c.backup:       || victim->level >= ch->level + 15
handler.c.backup:       || ( IS_NPC( victim ) && saves_spell_staff( ch->level, victim ) )
handler.c.backup:   else if( ch->level >= tarea->low_hard_range && ch->level <= tarea->hi_hard_range )
handler.c.backup:    clan_factor = 1 + abs( ch->alignment - ch->pcdata->clan->alignment ) / 1000; 
handler.c.backup:      deity_factor = ch->pcdata->favor / -500;
handler.c.backup:   ms = 10 - abs( ch->mental_state );
handler.c.backup:      deity_factor = ch->pcdata->favor / -500;
handler.c.backup:   if( ch->mental_state < 0 )
handler.c.backup:      ch->mental_state = URANGE( -100, ch->mental_state + c, 0 );
handler.c.backup:   else if( ch->mental_state > 0 )
handler.c.backup:      ch->mental_state = URANGE( 0, ch->mental_state - c, 100 );
handler.c.backup:   if( !IS_NPC( ch ) && ch->pcdata->nuisance && ch->pcdata->nuisance->flags > 2 )
handler.c.backup:      c += ( int )( .4 * ( ( ch->pcdata->nuisance->flags - 2 ) * ch->pcdata->nuisance->power ) );
handler.c.backup:   if( ch->mental_state < 0 )
handler.c.backup:      ch->mental_state = URANGE( -100, ch->mental_state - c, 100 );
handler.c.backup:   else if( ch->mental_state > 0 )
handler.c.backup:      ch->mental_state = URANGE( -100, ch->mental_state + c, 100 );
handler.c.backup:      ch->mental_state -= c;
handler.c.backup:   track = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
handler.c.backup:      if( ch->pcdata->killed[x].vnum == vnum )
handler.c.backup:         if( ch->pcdata->killed[x].count < 50 )
handler.c.backup:            ++ch->pcdata->killed[x].count;
handler.c.backup:      else if( ch->pcdata->killed[x].vnum == 0 )
handler.c.backup:   memmove( ( char * )ch->pcdata->killed + sizeof( KILLED_DATA ),
handler.c.backup:            ch->pcdata->killed, ( track - 1 ) * sizeof( KILLED_DATA ) );
handler.c.backup:   ch->pcdata->killed[0].vnum = vnum;
handler.c.backup:   ch->pcdata->killed[0].count = 1;
handler.c.backup:      ch->pcdata->killed[track].vnum = 0;
handler.c.backup:   track = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
handler.c.backup:      if( ch->pcdata->killed[x].vnum == vnum )
handler.c.backup:         return ch->pcdata->killed[x].count;
handler.c.backup:      else if( ch->pcdata->killed[x].vnum == 0 )
handler.c.backup:   for( ch = first_char; ch; ch = ch->next )
handler.c.backup:   if( !ch->switched )
handler.c.backup:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
handler.c.backup:         if( !IS_NPC( ch ) && ch->pcdata->bestowments && is_name( cmd->name, ch->pcdata->bestowments )
handler.c.backup:      set_char_color( AT_BLUE, ch->switched );
handler.c.backup:      send_to_char( "You suddenly forfeit the power to switch!\n\r", ch->switched );
handler.c.backup:   do_return( ch->switched, "" );
hotboot.c:      for( rch = first_char; rch; rch = rch->next )
hotboot.c:         if( !IS_NPC( rch ) || rch == supermob || xIS_SET( rch->act, ACT_PROTOTYPE ) || xIS_SET( rch->act, ACT_PET ) )
hotboot.c:   snprintf( log_buf, MAX_STRING_LENGTH, "Hotboot initiated by %s.", ch->name );
hotboot.c:   if( ch && ch->desc )
hotboot.c:      write_to_descriptor( ch->desc, "\033[0m", 0 );
hotboot.c:                  d->can_compress, och->in_room->vnum, d->port, d->idle, och->name, d->host );
hotboot.c:         och->pcdata->hotboot = TRUE;
house.c:         if( home->vnum[x] == ch->in_room->vnum )
house.c:               if( home->vnum[y] == vch->in_room->vnum )
house.c:   if( !ch || !ch->name || vnum <= 0 )
house.c:   tmphome->name = STRALLOC( ch->name );
house.c:      if( !str_cmp( home->name, ch->name ) )
house.c:   switch ( ch->substate )
house.c:         location = ( ROOM_INDEX_DATA * ) ch->dest_buf;
house.c:            bug( "%s: sub_room_desc: NULL ch->dest_buf", __func__ );
house.c:            location = ch->in_room;
house.c:         ch->substate = ch->tempnum;
house.c:      if( !str_cmp( homedata->name, ch->name ) )
house.c:         if( ch->gold >= DEFAULT_MOB_PRICE )
house.c:         ch->gold -= DEFAULT_MOB_PRICE;
house.c:         if( homedata->vnum[i] == ch->in_room->vnum )
house.c:            location = ch->in_room;
house.c:         ch->tempnum = SUB_NONE;
house.c:         ch->substate = SUB_ROOM_DESC;
house.c:         ch->dest_buf = location;
house.c:         log_printf( "%s: house desc", capitalize( ch->name ) );
house.c:         log_printf( "%s: house %s %s", capitalize( ch->name ), arg, argument );
house.c:         if( ch->gold < ADDITIONAL_ROOM_COST )
house.c:         ch->gold -= ADDITIONAL_ROOM_COST;
house.c:         log_printf( "%s: house %s %s", capitalize( ch->name ), arg, argument );
house.c:   log_printf( "%s: house %s %s", capitalize( ch->name ), arg, argument );
house.c:   if( IS_NPC( ch ) || !ch->desc )
house.c:      if( !str_cmp( home->name, ch->name ) )
house.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL ) || xIS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) )
house.c:   switch ( ch->position )
house.c:   snprintf( buf, MAX_STRING_LENGTH, "%s disappears in a vortex of luminescent light.", ch->name );
house.c:   if( ch->mount )
house.c:      char_from_room( ch->mount );
house.c:      char_to_room( ch->mount, room );
house.c:   snprintf( buf, MAX_STRING_LENGTH, "As a vortex of luminescent light forms, %s slides gracefully into their home.\r\n", ch->name );
house.c:      log_printf( "%s: accessories %s %s", capitalize( ch->name ), arg, argument );
house.c:         if( !str_cmp( home->name, ch->name ) )
house.c:      if( ch->gold < acc->price )
house.c:         if( ch->in_room->vnum == home->vnum[i] )
house.c:            location = ch->in_room;
house.c:      ch->gold -= acc->price;
house.c:         if( !str_cmp( home->name, ch->name ) )
house.c:         if( !str_cmp( checkhome->bidder, ch->name ) )
house.c:      if( !str_cmp( homeb->seller, ch->name ) )
house.c:      if( ch->gold < bid )
house.c:      homeb->bidder = STRALLOC( ch->name );
house.c:      if( !str_cmp( home->name, ch->name ) )
house.c:   if( !ch || IS_NPC( ch ) || ch->desc != NULL || ch->switched != NULL )
house.c:   if( ch->position == POS_MOUNTED )
house.c:   if( !ch->in_room || ( get_room_index( ch->in_room->vnum ) ) == NULL )
house.c:      ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
house.c:   if( sysdata.save_pets && ch->pcdata && ch->pcdata->pet )
house.c:      extract_char( ch->pcdata->pet, TRUE );
house.c:   if( ch->pcdata && ch->pcdata->clan )
house.c:      save_clan( ch->pcdata->clan );
imm_host.c:   for( i = 0; i < strlen( ch->name ); i++ )
imm_host.c:      my_name[i] = LOWER( ch->name[i] );
interp.c:   if( IS_NPC( ch ) && ch->position > 3 ) /*Band-aid alert?  -- Blod */
interp.c:   if( ch->position < position )
interp.c:      switch ( ch->position )
interp.c:            if( !found && ch->desc && get_trust( ch ) < pw->imm_level
interp.c:                     || ( pw->player_site && !str_prefix( pw->player_site, ch->desc->host ) ) ) )
interp.c:                         t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, ch->name, logline );
interp.c:         if( ( ( pw->target_name && !str_cmp( pw->target_name, ch->name ) )
interp.c:                    && !str_prefix( pw->player_site, ch->desc->host ) ) ) && get_trust( ch ) < pw->imm_level && ch->desc )
interp.c:                      t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, ch->name, logline );
interp.c:   if( !ch->in_room )
interp.c:   if( ch->substate == SUB_REPEATCMD )
interp.c:      if( ( fun = ch->last_cmd ) == NULL )
interp.c:         ch->substate = SUB_NONE;
interp.c:       * xREMOVE_BIT( ch->affected_by, AFF_HIDE ); 
interp.c:      if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_FREEZE ) )
interp.c:                  || ( !IS_NPC( ch ) && ch->pcdata->council
interp.c:                       && is_name( cmd->name, ch->pcdata->council->powers )
interp.c:                  || ( !IS_NPC( ch ) && IS_SET( ch->pcdata->flags, PCFLAG_RETIRED )
interp.c:                  || ( !IS_NPC( ch ) && ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0'
interp.c:                       && is_name( cmd->name, ch->pcdata->bestowments ) && cmd->level <= ( trust + sysdata.bestow_dif ) ) ) )
interp.c:      if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_AFK ) && ( str_cmp( command, "AFK" ) ) )
interp.c:         xREMOVE_BIT( ch->act, PLR_AFK );
interp.c:   snprintf( lastplayercmd, ( MAX_INPUT_LENGTH * 2 ), "%s used %s", ch->name, logline );
interp.c:   if( !IS_NPC( ch ) && ch->desc && valid_watch( logline ) )
interp.c:      else if( IS_SET( ch->pcdata->flags, PCFLAG_WATCH ) )
interp.c:   if( ( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_LOG ) )
interp.c:      if( ch->desc && ch->desc->original )
interp.c:         snprintf( log_buf, MAX_STRING_LENGTH, "Log %s (%s): %s", ch->name, ch->desc->original->name, logline );
interp.c:         snprintf( log_buf, MAX_STRING_LENGTH, "Log %s: %s", ch->name, logline );
interp.c:      if( fLogAll && loglvl == LOG_NORMAL && ( IS_NPC( ch ) || !xIS_SET( ch->act, PLR_LOG ) ) )
interp.c:   if( ch->desc && ch->desc->snoop_by )
interp.c:      snprintf( logname, MAX_INPUT_LENGTH, "%s", ch->name );
interp.c:      write_to_buffer( ch->desc->snoop_by, logname, 0 );
interp.c:      write_to_buffer( ch->desc->snoop_by, "% ", 2 );
interp.c:      write_to_buffer( ch->desc->snoop_by, logline, 0 );
interp.c:      write_to_buffer( ch->desc->snoop_by, "\r\n", 2 );
interp.c:      tempsub = ch->substate;
interp.c:      ch->substate = SUB_TIMER_DO_ABORT;
interp.c:      if( ch->substate != SUB_TIMER_CANT_ABORT )
interp.c:         ch->substate = tempsub;
interp.c:         ch->substate = tempsub;
interp.c:   if( !IS_NPC( ch ) && ch->pcdata->nuisance && ch->pcdata->nuisance->flags > 9
interp.c:       && number_percent(  ) < ( ( ch->pcdata->nuisance->flags - 9 ) * 10 * ch->pcdata->nuisance->power ) )
interp.c:   ch->prev_cmd = ch->last_cmd;  /* haus, for automapping */
interp.c:   ch->last_cmd = cmd->do_fun;
interp.c:      log_printf_plus( LOG_NORMAL, get_trust( ch ), "[*****] LAG: %s: %s %s (R:%d S:%ld.%06ld)", ch->name,
interp.c:                       ch->in_room ? ch->in_room->vnum : 0, time_used.tv_sec, time_used.tv_usec );
interp.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_NO_EMOTE ) )
interp.c:   switch ( ch->position )
interp.c:   room = ch->in_room;
interp.c:   for( victim = ch->in_room->first_person; victim; victim = victim_next )
interp.c:            ch_printf( victim, "You attempt to ignore %s, but are unable to do so.\r\n", !can_see( victim, ch ) ? "Someone" : ch->name );
interp.c:   else if( ch->morph != NULL && IS_SET( cmd->flags, CMD_FLAG_POLYMORPHED ) )
liquids.c:      for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
liquids.c:   if( !IS_NPC( ch ) && ch->pcdata->condition[COND_DRUNK] > MAX_COND_VALUE - 8 )
liquids.c:                && ch->level > 5 && ch->pcdata->condition[COND_BLOODTHIRST] > ( 5 + ch->level / 10 ) )
liquids.c:            if( ch->pcdata->condition[COND_BLOODTHIRST] < ( 10 + ch->level ) )
liquids.c:               if( ch->pcdata->condition[COND_FULL] >= MAX_COND_VALUE
liquids.c:                   || ch->pcdata->condition[COND_THIRST] >= MAX_COND_VALUE )
liquids.c:            ch->pcdata->condition[COND_THIRST] = MAX_COND_VALUE;
liquids.c:         if( !IS_NPC( ch ) && ( ch->pcdata->condition[COND_THIRST] == MAX_COND_VALUE
liquids.c:                                || ch->pcdata->condition[COND_FULL] == MAX_COND_VALUE ) )
liquids.c:            ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
liquids.c:            if( ch->pcdata->condition[COND_DRUNK] > ( MAX_COND_VALUE / 2 )
liquids.c:                && ch->pcdata->condition[COND_DRUNK] < ( MAX_COND_VALUE * .4 ) )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] >= ( MAX_COND_VALUE * .4 )
liquids.c:                     && ch->pcdata->condition[COND_DRUNK] < ( MAX_COND_VALUE * .6 ) )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] >= ( MAX_COND_VALUE * .6 )
liquids.c:                     && ch->pcdata->condition[COND_DRUNK] < ( MAX_COND_VALUE * .9 ) )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] >= ( MAX_COND_VALUE * .9 )
liquids.c:                     && ch->pcdata->condition[COND_DRUNK] < MAX_COND_VALUE )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] == MAX_COND_VALUE )
liquids.c:            if( ch->pcdata->condition[COND_THIRST] > ( MAX_COND_VALUE / 2 )
liquids.c:                && ch->pcdata->condition[COND_THIRST] < ( MAX_COND_VALUE * .4 ) )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] >= ( MAX_COND_VALUE * .4 )
liquids.c:                     && ch->pcdata->condition[COND_THIRST] < ( MAX_COND_VALUE * .6 ) )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] >= ( MAX_COND_VALUE * .6 )
liquids.c:                     && ch->pcdata->condition[COND_THIRST] < ( MAX_COND_VALUE * .9 ) )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] >= ( MAX_COND_VALUE * .9 )
liquids.c:                     && ch->pcdata->condition[COND_THIRST] < MAX_COND_VALUE )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] == MAX_COND_VALUE )
liquids.c:               if( ch->pcdata->condition[COND_BLOODTHIRST] > ( MAX_COND_VALUE / 2 )
liquids.c:                   && ch->pcdata->condition[COND_BLOODTHIRST] < ( MAX_COND_VALUE * .4 ) )
liquids.c:               else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( MAX_COND_VALUE * .4 )
liquids.c:                        && ch->pcdata->condition[COND_BLOODTHIRST] < ( MAX_COND_VALUE * .6 ) )
liquids.c:               else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( MAX_COND_VALUE * .6 )
liquids.c:                        && ch->pcdata->condition[COND_BLOODTHIRST] < ( MAX_COND_VALUE * .9 ) )
liquids.c:               else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( MAX_COND_VALUE * .9 )
liquids.c:                        && ch->pcdata->condition[COND_BLOODTHIRST] < MAX_COND_VALUE )
liquids.c:            else if( !IS_VAMPIRE( ch ) && ch->pcdata->condition[COND_BLOODTHIRST] >= MAX_COND_VALUE )
liquids.c:               ch->pcdata->condition[COND_BLOODTHIRST] = MAX_COND_VALUE;
liquids.c:            ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
liquids.c:            if( ch->pcdata->condition[COND_DRUNK] > ( MAX_COND_VALUE / 2 )
liquids.c:                && ch->pcdata->condition[COND_DRUNK] < ( MAX_COND_VALUE * .4 ) )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] >= ( MAX_COND_VALUE * .4 )
liquids.c:                     && ch->pcdata->condition[COND_DRUNK] < ( MAX_COND_VALUE * .6 ) )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] >= ( MAX_COND_VALUE * .6 )
liquids.c:                     && ch->pcdata->condition[COND_DRUNK] < ( MAX_COND_VALUE * .9 ) )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] >= ( MAX_COND_VALUE * .9 )
liquids.c:                     && ch->pcdata->condition[COND_DRUNK] < MAX_COND_VALUE )
liquids.c:            else if( ch->pcdata->condition[COND_DRUNK] == MAX_COND_VALUE )
liquids.c:            if( ch->pcdata->condition[COND_THIRST] > ( MAX_COND_VALUE / 2 )
liquids.c:                && ch->pcdata->condition[COND_THIRST] < ( MAX_COND_VALUE * .4 ) )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] >= ( MAX_COND_VALUE * .4 )
liquids.c:                     && ch->pcdata->condition[COND_THIRST] < ( MAX_COND_VALUE * .6 ) )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] >= ( MAX_COND_VALUE * .6 )
liquids.c:                     && ch->pcdata->condition[COND_THIRST] < ( MAX_COND_VALUE * .9 ) )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] >= ( MAX_COND_VALUE * .9 )
liquids.c:                     && ch->pcdata->condition[COND_THIRST] < MAX_COND_VALUE )
liquids.c:            else if( ch->pcdata->condition[COND_THIRST] == MAX_COND_VALUE )
liquids.c:               if( ch->pcdata->condition[COND_BLOODTHIRST] > ( MAX_COND_VALUE / 2 )
liquids.c:                   && ch->pcdata->condition[COND_BLOODTHIRST] < ( MAX_COND_VALUE * .4 ) )
liquids.c:               else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( MAX_COND_VALUE * .4 )
liquids.c:                        && ch->pcdata->condition[COND_BLOODTHIRST] < ( MAX_COND_VALUE * .6 ) )
liquids.c:               else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( MAX_COND_VALUE * .6 )
liquids.c:                        && ch->pcdata->condition[COND_BLOODTHIRST] < ( MAX_COND_VALUE * .9 ) )
liquids.c:               else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( MAX_COND_VALUE * .9 )
liquids.c:                        && ch->pcdata->condition[COND_BLOODTHIRST] < MAX_COND_VALUE )
liquids.c:            else if( !IS_VAMPIRE( ch ) && ch->pcdata->condition[COND_BLOODTHIRST] >= MAX_COND_VALUE )
liquids.c:               ch->pcdata->condition[COND_BLOODTHIRST] = MAX_COND_VALUE;
liquids.c:      for( source = ch->in_room->first_content; source; source = src_next )
liquids.c:                || ch->carry_weight + get_obj_weight( source ) > can_carry_w( ch )
liquids.c:               ch->gold += source->value[0];
liquids.c:         if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
liquids.c:            save_house_by_vnum( ch->in_room->vnum );
liquids.c:                || ch->carry_weight + get_obj_weight( source ) > can_carry_w( ch )
liquids.c:            if( !IS_OBJ_STAT( source, ITEM_CLANCORPSE ) || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
liquids.c:               if( str_cmp( name, ch->name ) && !IS_IMMORTAL( ch ) )
liquids.c:                  for( gch = first_char; gch; gch = gch->next )
liquids.c:                     if( !IS_NPC( gch ) && is_same_group( ch, gch ) && !str_cmp( name, gch->name ) )
liquids.c:                   || ch->carry_number + otmp->count > can_carry_n( ch )
liquids.c:                   || ch->carry_weight + get_obj_weight( otmp ) > can_carry_w( ch )
liquids.c:               if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
liquids.c:                  save_house_by_vnum( ch->in_room->vnum );
liquids.c:            if( xIS_SET( ch->in_room->room_flags, ROOM_NODROP ) || xIS_SET( ch->act, PLR_LITTERBUG ) )
liquids.c:            if( xIS_SET( ch->in_room->room_flags, ROOM_NODROPALL )
liquids.c:                || xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
liquids.c:            if( empty_obj( obj, NULL, ch->in_room ) )
liquids.c:         if( ch->in_room && xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
liquids.c:            save_house_by_vnum( ch->in_room->vnum );
liquids.c:         if( xIS_SET( ch->in_room->room_flags, ROOM_CLANSTOREROOM ) )
liquids.c:               if( vault->vnum == ch->in_room->vnum )
magic.c:         return ( IS_SET( ch->immune, RIS_FIRE ) );
magic.c:         return ( IS_SET( ch->immune, RIS_COLD ) );
magic.c:         return ( IS_SET( ch->immune, RIS_ELECTRICITY ) );
magic.c:         return ( IS_SET( ch->immune, RIS_ENERGY ) );
magic.c:         return ( IS_SET( ch->immune, RIS_ACID ) );
magic.c:         return ( IS_SET( ch->immune, RIS_POISON ) );
magic.c:         return ( IS_SET( ch->immune, RIS_DRAIN ) );
magic.c:   if( ch->pcdata->learned[sn] > 0
magic.c:       && ( ch->level >= skill_table[sn]->skill_level[ch->Class] || ch->level >= skill_table[sn]->race_level[ch->race] ) )
magic.c:      if( ch->pcdata->learned[sn] > 0
magic.c:          && ch->level >= skill_table[sn]->skill_level[ch->Class]
magic.c:   if( !ch->pcdata )
magic.c:      if( !ch->pcdata->special_skills[sn] || !ch->pcdata->special_skills[sn]->name )
magic.c:      if( LOWER( name[0] ) == LOWER( ch->pcdata->special_skills[sn]->name[0] )
magic.c:          && !str_prefix( name, ch->pcdata->special_skills[sn]->name ) )
magic.c:   if( IS_NPC( ch ) || ch->Class == CLASS_MAGE )
magic.c:   for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
magic.c:         act( AT_MAGIC, ch->Class == rch->Class ? buf : buf2, ch, NULL, rch, TO_VICT );
magic.c:   if( IS_SET( ch->immune, ris ) && !IS_SET( ch->no_immune, ris ) )
magic.c:   if( IS_SET( ch->resistant, ris ) && !IS_SET( ch->no_resistant, ris ) )
magic.c:   if( IS_SET( ch->susceptible, ris ) && !IS_SET( ch->no_susceptible, ris ) )
magic.c:      if( IS_NPC( ch ) && IS_SET( ch->immune, ris ) )
magic.c:            return ch->hit;
magic.c:            return ch->mana;
magic.c:            return ch->move;
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:            if( ch->gold >= value )
magic.c:                     ch->gold -= value;
magic.c:            if( ch->hit >= value )
magic.c:                     ch->hit -= value;
magic.c:         if( !IS_NPC( ch ) && ch->pcdata->nuisance &&
magic.c:             ch->pcdata->nuisance->flags > 5
magic.c:             && number_percent(  ) < ( ( ( ch->pcdata->nuisance->flags - 5 ) * 8 ) + ch->pcdata->nuisance->power * 6 ) )
magic.c:               if( xIS_SET( ch->act, PLR_NICE ) && ch != *victim )
magic.c:            if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == *victim )
magic.c:         if( !IS_NPC( ch ) && ch->fighting && ch->pcdata->nuisance &&
magic.c:             ch->pcdata->nuisance->flags > 5
magic.c:             && number_percent(  ) < ( ( ( ch->pcdata->nuisance->flags - 5 ) * 8 ) + 6 * ch->pcdata->nuisance->power ) )
magic.c:         if( arg[0] != '\0' && !nifty_is_name( arg, ch->name ) )
magic.c:   switch ( ch->substate )
magic.c:         if( xIS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) || IS_SET( ch->in_room->area->flags, AFLAG_NOMAGIC ) )
magic.c:                || ( !IS_NPC( ch ) && ch->level < skill_table[sn]->skill_level[ch->Class] ) )
magic.c:         if( ch->position < skill->minimum_position && !IS_NPC( ch ) )
magic.c:            switch ( ch->position )
magic.c:             && skill->guild != CLASS_NONE && ( !ch->pcdata->clan || skill->guild != ch->pcdata->clan->Class ) )
magic.c:         if( !ch->in_room || ( skill->spell_sector && !IS_SET( skill->spell_sector, ( 1 << ch->in_room->sector_type ) ) ) )
magic.c:         mana = IS_NPC( ch ) ? 0 : UMAX( skill->min_mana, 100 / ( 2 + ch->level - skill->skill_level[ch->Class] ) );
magic.c:            if( ch->pcdata->condition[COND_BLOODTHIRST] < blood )
magic.c:         else if( !IS_NPC( ch ) && ch->mana < mana )
magic.c:         ch->alloc_ptr = str_dup( staticbuf );
magic.c:         ch->tempnum = sn;
magic.c:         DISPOSE( ch->alloc_ptr );
magic.c:         if( IS_VALID_SN( ( sn = ch->tempnum ) ) )
magic.c:            mana = IS_NPC( ch ) ? 0 : UMAX( skill->min_mana, 100 / ( 2 + ch->level - skill->skill_level[ch->Class] ) );
magic.c:            else if( ch->level < LEVEL_IMMORTAL )  /* so imms dont lose mana */
magic.c:               ch->mana -= mana / 3;
magic.c:         sn = ch->tempnum;
magic.c:         if( !ch->alloc_ptr || !IS_VALID_SN( sn ) || skill->type != SKILL_SPELL )
magic.c:            bug( "do_cast: ch->alloc_ptr NULL or bad sn (%d)", sn );
magic.c:         mana = IS_NPC( ch ) ? 0 : UMAX( skill->min_mana, 100 / ( 2 + ch->level - skill->skill_level[ch->Class] ) );
magic.c:         mudstrlcpy( staticbuf, ch->alloc_ptr, MAX_INPUT_LENGTH );
magic.c:         DISPOSE( ch->alloc_ptr );
magic.c:         ch->substate = SUB_NONE;
magic.c:            for( tmp = ch->in_room->first_person; tmp; tmp = tmp->next_in_room )
magic.c:               for( tmp = ch->in_room->first_person; tmp; tmp = tmp->next_in_room )
magic.c:               else if( ch->level < LEVEL_IMMORTAL )  /* so imms dont lose mana */
magic.c:                  ch->mana -= mana / 2;
magic.c:      else if( ch->level < LEVEL_IMMORTAL )  /* so imms dont lose mana */
magic.c:         ch->mana -= mana / 2;
magic.c:   if( !IS_NPC( ch ) && ( number_percent(  ) + skill->difficulty * 5 ) > ch->pcdata->learned[sn] )
magic.c:            if( ch->fighting )
magic.c:            if( ch->fighting )
magic.c:      else if( ch->level < LEVEL_IMMORTAL )  /* so imms dont lose mana */
magic.c:         ch->mana -= mana / 2;
magic.c:         ch->mana -= mana;
magic.c:         retcode = ( *skill->spell_fun ) ( sn, ch->level, ch, vo );
magic.c:   if( ch->in_room && IS_SET( ch->in_room->area->flags, AFLAG_SPELLLIMIT ) )
magic.c:      ch->in_room->area->curr_spell_count++;
magic.c:      for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:         vch_next = vch->next_in_room;
magic.c:            if( vch->master != ch && !vch->fighting )
magic.c:   int levdiff = ch->level - level;
magic.c:   if( !ch->in_room || xIS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) || IS_SET( ch->in_room->area->flags, AFLAG_NOMAGIC ) )
magic.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) && skill->target == TAR_CHAR_OFFENSIVE )
magic.c:         if( skill->type != SKILL_HERB && IS_SET( ch->immune, RIS_MAGIC ) )
magic.c:      for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:         vch_next = vch->next_in_room;
magic.c:         if( victim == vch && !vch->fighting && vch->master != ch )
magic.c:   struct WeatherCell *cell = getWeatherCell( ch->in_room->area );
magic.c:   where = ch->in_room;
magic.c:      if( !vch->in_room )
magic.c:      if( vch->in_room == where )
magic.c:         if( IS_NPC( vch ) && xIS_SET( vch->act, ACT_MOBINVIS ) )
magic.c:         if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:      else if( vch->in_room->area == where->area && IS_OUTSIDE( vch ) && IS_AWAKE( vch ) && number_bits( 2 ) == 0 )
magic.c:   if( ( ( get_curr_cha( ch ) / 3 ) + 1 ) > ch->pcdata->charmies )
magic.c:   log_printf_plus( LOG_NORMAL, ch->level, "%s has charmed %s.", ch->name, victim->name );
magic.c:      ch->pcdata->charmies++;
magic.c:   struct WeatherCell *cell = getWeatherCell( ch->in_room->area );
magic.c:   change = URANGE( 5, number_range( 5, 15 ) + ( ch->level / 10 ), 15 );
magic.c:   mushroom = obj_to_room( mushroom, ch->in_room );
magic.c:   struct WeatherCell *cell = getWeatherCell( ch->in_room->area );
magic.c:   if( ch->alignment < 350 )
magic.c:   if( IS_SET( ch->immune, RIS_MAGIC ) )
magic.c:   if( IS_NPC( ch ) || ch->Class == CLASS_MAGE )
magic.c:      if( ch->first_affect )
magic.c:         while( ch->first_affect )
magic.c:            affect_remove( ch, ch->first_affect );
magic.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   where = ch->in_room;
magic.c:      if( !vch->in_room )
magic.c:      if( vch->in_room == where )
magic.c:         if( IS_NPC( vch ) && xIS_SET( vch->act, ACT_MOBINVIS ) )
magic.c:         if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:      else if( vch->in_room->area == where->area && number_bits( 2 ) == 0 )
magic.c:   ch->alignment = UMAX( -1000, ch->alignment - 200 );
magic.c:      dam = ch->hit + 1;
magic.c:      ch->hit += dam;
magic.c:   if( ch->hit > ch->max_hit )
magic.c:      ch->hit = ch->max_hit;
magic.c:   for( ich = ch->in_room->first_person; ich; ich = ich->next_in_room )
magic.c:      if( !IS_NPC( ich ) && xIS_SET( ich->act, PLR_WIZINVIS ) )
magic.c:      xREMOVE_BIT( ich->affected_by, AFF_HIDE );
magic.c:      xREMOVE_BIT( ich->affected_by, AFF_INVISIBLE );
magic.c:      xREMOVE_BIT( ich->affected_by, AFF_SNEAK );
magic.c:   char_to_room( create_mobile( temp ), ch->in_room );
magic.c:                    name, ( ch->level > victim->level + 10 ) ? victim->name : "someone else" );
magic.c:      if( ( chance( ch, 50 ) && ch->level >= victim->level + 10 ) || IS_IMMORTAL( ch ) )
magic.c:   if( !ch->in_room->first_content )
magic.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
magic.c:      snprintf( log_buf, MAX_STRING_LENGTH, "%s has cast sleep on %s.", ch->name, victim->name );
magic.c:      log_string_plus( log_buf, LOG_NORMAL, ch->level );
magic.c:      to_channel( log_buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level ) );
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_ASTRAL )
magic.c:       || !in_hard_range( victim, ch->in_room->area )
magic.c:       || ( IS_SET( ch->in_room->area->flags, AFLAG_NOPKILL ) && IS_PKILL( victim ) )
magic.c:   if( ch->in_room->area != victim->in_room->area )
magic.c:      ch->position = POS_STUNNED;
magic.c:      snprintf( buf, MAX_STRING_LENGTH, "%s summoned %s to room %d.", ch->name, victim->name, ch->in_room->vnum );
magic.c:      log_string_plus( buf, LOG_NORMAL, ch->level );
magic.c:      to_channel( buf, CHANNEL_MONITOR, "Monitor", UMAX( LEVEL_IMMORTAL, ch->level ) );
magic.c:   char_to_room( victim, ch->in_room );
magic.c:   ROOM_INDEX_DATA *start = ch->in_room;
magic.c:      nch_next = nch->next_in_room;
magic.c:   ROOM_INDEX_DATA *start = ch->in_room, *pRoomIndex;
magic.c:   if( !IS_NPC( ch ) && ch->mana < mana )
magic.c:      nch_next = nch->next_in_room;
magic.c:   snprintf( buf3, MAX_STRING_LENGTH, "%s makes %s say '%s'.\r\n", capitalize( ch->name ), speaker, target_name );
magic.c:   for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
magic.c:      if( !is_name( speaker, vch->name ) )
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   for( vch = ch->in_room->first_person; vch; vch = trvch_next( loop_ctrl ) )
magic.c:      if( IS_NPC( vch ) && xIS_SET( vch->act, ACT_MOBINVIS ) )
magic.c:      if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:         hpch = UMAX( 10, ch->hit );
magic.c:   hpch = UMAX( 10, ch->hit );
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:   if( victim->in_room == ch->in_room )
magic.c:   for( obj = ch->in_room->first_content; obj; obj = obj_next )
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_ASTRAL )
magic.c:       || IS_SET( ch->in_room->area->flags, AFLAG_NOPORTALOUT )
magic.c:       || IS_SET( ch->in_room->area->flags, AFLAG_NOASTRAL )
magic.c:   if( victim->in_room == ch->in_room )
magic.c:   fromRoom = ch->in_room;
magic.c:   snprintf( buf, MAX_STRING_LENGTH, "a portal created by %s", ch->name );
magic.c:   portalObj = obj_to_room( portalObj, ch->in_room );
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:   original = ch->in_room;
magic.c:      else if( chance( ch, 50 - ( ch->level / 2 ) ) )
magic.c:       || IS_SET( ch->in_room->area->flags, AFLAG_NOASTRAL )
magic.c:       || ( ch->in_room->sector_type != SECT_FOREST
magic.c:            && ch->in_room->sector_type != SECT_FIELD )
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:   if( ch->in_room->sector_type == SECT_FOREST )
magic.c:   if( ch->in_room->sector_type == SECT_FOREST )
magic.c:   if( IS_PKILL( ch ) && ch->pcdata->condition[COND_BLOODTHIRST] > 22 )
magic.c:       || IS_SET( ch->in_room->area->flags, AFLAG_NOASTRAL )
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:   struct WeatherCell *cell = getWeatherCell( ch->in_room->area );
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:       || IS_SET( ch->in_room->area->flags, AFLAG_NOASTRAL )
magic.c:            if( chance( ch, 50 ) && ch->level + 10 < victim->level )
magic.c:            if( chance( ch, 50 ) && ch->level + 15 < victim->level )
magic.c:   for( corpse = ch->in_room->first_content; corpse; corpse = corpse_next )
magic.c:         if( !IS_IMMORTAL( ch ) && ch->pcdata->condition[COND_BLOODTHIRST] - ( pMobIndex->level / 3 ) < 0 )
magic.c:      else if( ch->mana - ( pMobIndex->level * 4 ) < 0 )
magic.c:         ch->mana -= ( pMobIndex->level * 4 );
magic.c:   if( IS_IMMORTAL( ch ) || ( chance( ch, 75 ) && pMobIndex->level - ch->level < 10 ) )
magic.c:      char_to_room( mob, ch->in_room );
magic.c:      mob->level = UMIN( ch->level / 2, pMobIndex->level );
magic.c:                                   ( mob->max_hit * corpse->value[3] ) / 100, ch->level * dice( 20, 10 ) ), 1 );
magic.c:      mob->damroll = ch->level / 8;
magic.c:      mob->hitroll = ch->level / 6;
magic.c:      mob->alignment = ch->alignment;
magic.c:   if( !ch->desc || ch->desc->original )
magic.c:   af.duration = 20 + ( ch->level - victim->level ) / 2;
magic.c:   ch->desc->character = victim;
magic.c:   ch->desc->original = ch;
magic.c:   victim->desc = ch->desc;
magic.c:   ch->desc = NULL;
magic.c:   ch->switched = victim;
magic.c:   if( pexit->rexit && pexit->rexit->to_room == ch->in_room )
magic.c:   if( !( victim = get_char_world( ch, arg ) ) || victim->in_room->area != ch->in_room->area )
magic.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   for( vch = ch->in_room->first_person; vch; vch = trvch_next( lc ) )
magic.c:      if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:         hpch = UMAX( 10, ch->hit );
magic.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
magic.c:       || IS_SET( ch->in_room->area->flags, AFLAG_NOASTRAL )
magic.c:            if( ( dam > 0 && ch->fighting && ch->fighting->who == victim )
magic.c:               int xp = ch->fighting ? ch->fighting->xp : victim->fighting->xp;
magic.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
magic.c:   for( vch = ch->in_room->first_person; vch; vch = vch_next )
magic.c:      vch_next = vch->next_in_room;
magic.c:      if( IS_NPC( vch ) && xIS_SET( vch->act, ACT_MOBINVIS ) )
magic.c:      if( !IS_NPC( vch ) && xIS_SET( vch->act, PLR_WIZINVIS ) && vch->pcdata->wizinvis >= LEVEL_IMMORTAL )
magic.c:               vch->hit = URANGE( 0, vch->hit + dam, vch->max_hit );
magic.c:               if( ( dam > 0 && ch->fighting && ch->fighting->who == vch )
magic.c:                   || ( dam > 0 && vch->fighting && vch->fighting->who == ch ) )
magic.c:                  int xp = ch->fighting ? ch->fighting->xp : vch->fighting->xp;
magic.c:                  int xp_gain = ( int )( xp * dam * 2 ) / vch->max_hit;
magic.c:               if( ( af.modifier > 0 && ch->fighting && ch->fighting->who == victim )
magic.c:                  int xp = ch->fighting ? ch->fighting->xp : victim->fighting->xp;
magic.c:         victim = ch->in_room->first_person;
magic.c:   struct WeatherCell *cell = getWeatherCell( ch->in_room->area );
magic.c:               if( ch->level - obj->level < 10 || obj->cost > ch->level * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:               if( ch->level - obj->level < 20 || obj->cost > ch->level * get_curr_int( ch ) / 5 )
magic.c:               if( ch->level - obj->level < 5 || obj->cost > ch->level * 10 * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:               if( ch->level - obj->level < 0 || obj->cost > ch->level * 50 * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:      obj_to_room( obj, ch->in_room );
magic.c:   char_to_room( mob, ch->in_room );
magic.c:             ( ch->position == POS_FIGHTING
magic.c:               || ch->position == POS_EVASIVE
magic.c:               || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK ) )
magic.c:   ch->gold += val;
makeobjs.c:      if( ch && ch->in_room )
makeobjs.c:      name = ch->short_descr;
makeobjs.c:      if( ch->gold > 0 )
makeobjs.c:         if( ch->in_room )
makeobjs.c:            ch->in_room->area->gold_looted += ch->gold;
makeobjs.c:            sysdata.global_looted += ch->gold / 100;
makeobjs.c:         obj_to_obj( create_money( ch->gold ), corpse );
makeobjs.c:         ch->gold = 0;
makeobjs.c:	corpse->value[0] = (int)ch->pIndexData->vnum;
makeobjs.c:	corpse->value[1] = (int)ch->max_hit;
makeobjs.c:      corpse->cost = ( -( int )ch->pIndexData->vnum );
makeobjs.c:      name = ch->name;
makeobjs.c:      corpse->value[4] = ch->level;
makeobjs.c:   for( obj = ch->first_carrying; obj; obj = obj_next )
makeobjs.c:         obj_to_room( obj, ch->in_room );
makeobjs.c:   return obj_to_room( corpse, ch->in_room );
makeobjs.c:   for(obj = ch->in_room->first_content; obj; obj = obj->next_content )
makeobjs.c:      obj_to_room( obj, ch->in_room );
makeobjs.c:   for( obj = ch->in_room->first_content; obj; obj = obj_next )
makeobjs.c:         obj->value[1] += number_range( 3, UMIN( 5, ch->level ) );
makeobjs.c:   obj->value[1] = number_range( 3, UMIN( 5, ch->level ) );
makeobjs.c:   obj_to_room( obj, ch->in_room );
makeobjs.c:   obj_to_room( obj, ch->in_room );
mapout.c:   if( !ch->pnote )
mapout.c:      bug( "%s", "map_stats: ch->pnote == NULL!" );
mapout.c:   l = ch->pnote->text;
mapout.c:   if( !ch->desc )
mapout.c:   switch ( ch->substate )
mapout.c:         if( ch->dest_buf != ch->pnote )
mapout.c:            bug( "%s", "do_mapout: sub_writing_map: ch->dest_buf != ch->pnote" );
mapout.c:         STRFREE( ch->pnote->text );
mapout.c:         ch->pnote->text = copy_buffer( ch );
mapout.c:      if( !ch->pnote )
mapout.c:      ch->substate = SUB_WRITING_NOTE;
mapout.c:      ch->dest_buf = ch->pnote;
mapout.c:      start_editing( ch, ch->pnote->text );
mapout.c:      if( !ch->pnote )
mapout.c:      STRFREE( ch->pnote->text );
mapout.c:      STRFREE( ch->pnote->subject );
mapout.c:      STRFREE( ch->pnote->to_list );
mapout.c:      STRFREE( ch->pnote->date );
mapout.c:      STRFREE( ch->pnote->sender );
mapout.c:      DISPOSE( ch->pnote );
mapout.c:      ch->pnote = NULL;
mapout.c:      if( !ch->pnote )
mapout.c:      send_to_char( ch->pnote->text, ch );
mapout.c:      if( !ch->pnote )
mapout.c:         ed->description = QUICKLINK( ch->pnote->text );
mapout.c:   for( i = ch->pcdata->area->low_r_vnum; i <= ch->pcdata->area->hi_r_vnum; i++ )
mapout.c:         if( !( location = make_room( i, ch->pcdata->area ) ) )
mapout.c:         location->area = ch->pcdata->area;
mapout.c:   for( i = ch->pcdata->area->low_r_vnum; i <= ch->pcdata->area->hi_r_vnum; i++ )
mapout.c:/* This function takes the character string in ch->pnote and
mapout.c:   if( !ch->pnote )
mapout.c:      bug( "%s: ch->pnote==NULL!", __func__ );
mapout.c:   newmap = check_map( ch->pnote->text );
mapout.c:   STRFREE( ch->pnote->text );
mapout.c:   ch->pnote->text = STRALLOC( newmap );
mapout.c:      for( i = ch->pcdata->area->low_r_vnum; i <= ch->pcdata->area->hi_r_vnum; i++ )
mapout.c:   l = ch->pnote->text;
mapper.c:   for( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
mapper.c:   if( xIS_SET( ch->act, PLR_AUTOEXIT ) )
mapper.c:   dmap[x][y].vnum = ch->in_room->vnum;
mapper.c:   map_exits( ch, ch->in_room, x, y, 0 );
mccp.c:   if( !ch->desc )
mccp.c:   if( !ch->desc->mccp->out_compress )
mccp.c:      if( !compressStart( ch->desc ) )
mccp.c:      compressEnd( ch->desc );
mccp.c:      ch->desc->can_compress = FALSE;
misc.c:   if( IS_NPC( ch ) || ch->pcdata->condition[COND_FULL] > 5 )
misc.c:      if( !IS_NPC( ch ) && ch->pcdata->condition[COND_FULL] > 40 )
misc.c:   if( !IS_NPC( ch ) && ( !IS_PKILL( ch ) || ( IS_PKILL( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_HIGHGAG ) ) ) )
misc.c:   if( ch->fighting && number_percent(  ) > ( get_curr_dex( ch ) * 2 + 47 ) )
misc.c:                ( ch->in_room->sector_type == SECT_UNDERWATER ||
misc.c:                  ch->in_room->sector_type == SECT_WATER_SWIM ||
misc.c:                  ch->in_room->sector_type == SECT_WATER_NOSWIM ) ? "dissolves in the water" :
misc.c:                ( ch->in_room->sector_type == SECT_AIR ||
misc.c:                  xIS_SET( ch->in_room->room_flags, ROOM_NOFLOOR ) ) ? "falls far below" : "is trampled underfoot" );
misc.c:               condition = ch->pcdata->condition[COND_FULL];
misc.c:               if( condition <= 1 && ch->pcdata->condition[COND_FULL] > 1 )
misc.c:               else if( ch->pcdata->condition[COND_FULL] > 40 )
misc.c:                  ch->mental_state = URANGE( 20, ch->mental_state + 5, 100 );
misc.c:                  ch->mental_state = URANGE( 15, ch->mental_state + 5, 100 );
misc.c:               condition = ch->pcdata->condition[COND_FULL];
misc.c:               if( condition <= 1 && ch->pcdata->condition[COND_FULL] > 1 )
misc.c:               else if( ch->pcdata->condition[COND_FULL] > 40 )
misc.c:   if( !IS_NPC( ch ) && ( ch->pcdata->condition[COND_FULL] >= 48 || ch->pcdata->condition[COND_THIRST] >= 48 ) )
misc.c:   if( !IS_NPC( ch ) && ch->pcdata->nuisance &&
misc.c:       ch->pcdata->nuisance->flags > 3
misc.c:       && ( ch->pcdata->condition[COND_FULL] >= ( 48 - ( 3 * ch->pcdata->nuisance->flags ) + ch->pcdata->nuisance->power )
misc.c:            || ch->pcdata->condition[COND_THIRST] >= ( 48 - ( ch->pcdata->nuisance->flags ) + ch->pcdata->nuisance->power ) ) )
misc.c:   if( !IS_NPC( ch ) && ( !IS_PKILL( ch ) || ( IS_PKILL( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_HIGHGAG ) ) ) )
misc.c:   if( ch->fighting && number_percent(  ) > ( get_curr_dex( ch ) * 2 + 48 ) )
misc.c:      if( !IS_NPC( ch ) && ch->pcdata->condition[COND_THIRST] > 43 )
misc.c:   if( ( scroll->pIndexData->vnum == OBJ_VNUM_SCROLL_SCRIBING ) && ( ch->level + 10 < scroll->value[0] ) )
misc.c:      for( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:      snprintf( buf, MAX_STRING_LENGTH, "%s hit a DEATH TRIGGER in room %d!", ch->name, ch->in_room->vnum );
misc.c:            obj_to_room( tobj, ch->in_room );
misc.c:      room = ch->in_room;
misc.c:      obj_cast_spell( obj->value[1], URANGE( 1, ( obj->value[2] > 0 ) ? obj->value[2] : ch->level, MAX_LEVEL ), ch, ch,
misc.c:      for( container = ch->in_room->first_content; container; container = container->next_content )
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:         for( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:            for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
misc.c:         for( rch = room->first_person; rch; rch = rch->next_in_room )
misc.c:         if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:            for( rch = pexit->to_room->first_person; rch; rch = rch->next_in_room )
misc.c:   if( ch->fighting )
misc.c:      if( ( to_room = pexit->to_room ) != NULL && ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
misc.c:         for( rch = to_room->first_person; rch; rch = rch->next_in_room )
misc.c:            obj_cast_spell( sn, UMIN( skill->min_level, ch->level ), ch, ch, NULL );
misc.c:   for( tinder = ch->last_carrying; tinder; tinder = tinder->prev_content )
misc.c:         if( ( obj = get_obj_list_rev( ch, arg, ch->in_room->last_content ) ) == NULL )
misc.c:         if( ( obj = get_obj_list_rev( ch, arg, ch->in_room->last_content ) ) == NULL )
misc.c:   if( ch->fighting )
modifier:handler.c:      xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c:      xREMOVE_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c:         bug( "%s: unknown location %d. (%s)", __func__, paf->location, ch->name );
modifier:handler.c:      bug( "%s (%s, %d): no affect.", __func__, ch->name, paf ? paf->type : 0 );
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:   xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c:         SET_BIT( ch->affected_by.bits[0], paf->modifier );
modifier:handler.c:         SET_BIT( ch->resistant, paf->modifier );
modifier:handler.c:         SET_BIT( ch->susceptible, paf->modifier );
modifier:handler.c:         SET_BIT( ch->immune, paf->modifier );
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c.backup:      xREMOVE_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c.backup:         bug( "%s: unknown location %d. (%s)", __func__, paf->location, ch->name );
modifier:handler.c.backup:      bug( "%s (%s, %d): no affect.", __func__, ch->name, paf ? paf->type : 0 );
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c.backup:         SET_BIT( ch->affected_by.bits[0], paf->modifier );
modifier:handler.c.backup:         SET_BIT( ch->resistant, paf->modifier );
modifier:handler.c.backup:         SET_BIT( ch->susceptible, paf->modifier );
modifier:handler.c.backup:         SET_BIT( ch->immune, paf->modifier );
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
modifier:player.c:      for( paf = ch->first_affect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:save.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:update.c:                     if( ( *skill->spell_fun ) ( paf->modifier, ch->level, ch, ch ) == rCHAR_DIED || char_died( ch ) )
modifier:handler.c:      xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c:      xREMOVE_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c:         bug( "%s: unknown location %d. (%s)", __func__, paf->location, ch->name );
modifier:handler.c:      bug( "%s (%s, %d): no affect.", __func__, ch->name, paf ? paf->type : 0 );
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:   xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c:         SET_BIT( ch->affected_by.bits[0], paf->modifier );
modifier:handler.c:         SET_BIT( ch->resistant, paf->modifier );
modifier:handler.c:         SET_BIT( ch->susceptible, paf->modifier );
modifier:handler.c:         SET_BIT( ch->immune, paf->modifier );
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c.backup:      xREMOVE_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c.backup:         bug( "%s: unknown location %d. (%s)", __func__, paf->location, ch->name );
modifier:handler.c.backup:      bug( "%s (%s, %d): no affect.", __func__, ch->name, paf ? paf->type : 0 );
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   xSET_BITS( ch->affected_by, paf->bitvector );
modifier:handler.c.backup:         SET_BIT( ch->affected_by.bits[0], paf->modifier );
modifier:handler.c.backup:         SET_BIT( ch->resistant, paf->modifier );
modifier:handler.c.backup:         SET_BIT( ch->susceptible, paf->modifier );
modifier:handler.c.backup:         SET_BIT( ch->immune, paf->modifier );
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:handler.c.backup:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:handler.c.backup:      for( paf = ch->switched->first_affect; paf; paf = paf->next )
modifier:player.c:      for( paf = ch->first_affect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
modifier:save.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
modifier:save.c:   for( paf = ch->first_affect; paf; paf = paf->next )
modifier:update.c:                     if( ( *skill->spell_fun ) ( paf->modifier, ch->level, ch, ch ) == rCHAR_DIED || char_died( ch ) )
mpxset.c:   if( !IS_NPC( ch ) || IS_AFFECTED( ch, AFF_CHARM ) || ch->desc )
mpxset.c:      snprintf( log_buf, MAX_STRING_LENGTH, "%s raising glory of %s by %d ...", ch->name, victim->name, value );
mpxset.c:   if( !IS_NPC( ch ) || IS_AFFECTED( ch, AFF_CHARM ) || ch->desc )
mud.h:#define WAIT_STATE(ch, npulse) ((ch)->wait=(!IS_NPC(ch)&&ch->pcdata->nuisance&&\
mud.h:			      (ch->pcdata->nuisance->flags>4))?UMAX((ch)->wait,\
mud.h:               		      ch->pcdata->nuisance->power)): \
mud.h:#define IS_PACIFIST(ch)		(IS_NPC(ch) && xIS_SET(ch->act, ACT_PACIFIST))
mud.h:#define IS_RETIRED(ch) (ch->pcdata && IS_SET(ch->pcdata->flags,PCFLAG_RETIRED))
mud.h:#define IS_GUEST(ch) (ch->pcdata && IS_SET(ch->pcdata->flags,PCFLAG_GUEST))
mud.h:#define NOT_AUTHED(ch)		(!IS_NPC(ch) && ch->pcdata->auth_state <= 3  \
mud.h:			      && IS_SET(ch->pcdata->flags, PCFLAG_UNAUTHED) )
mud.h:#define IS_WAITING_FOR_AUTH(ch) (!IS_NPC(ch) && ch->desc		     \
mud.h:			      && ch->pcdata->auth_state == 1		     \
mud.h:			      && IS_SET(ch->pcdata->flags, PCFLAG_UNAUTHED) )
mud.h.backup:#define WAIT_STATE(ch, npulse) ((ch)->wait=(!IS_NPC(ch)&&ch->pcdata->nuisance&&\
mud.h.backup:			      (ch->pcdata->nuisance->flags>4))?UMAX((ch)->wait,\
mud.h.backup:               		      ch->pcdata->nuisance->power)): \
mud.h.backup:#define IS_PACIFIST(ch)		(IS_NPC(ch) && xIS_SET(ch->act, ACT_PACIFIST))
mud.h.backup:#define IS_RETIRED(ch) (ch->pcdata && IS_SET(ch->pcdata->flags,PCFLAG_RETIRED))
mud.h.backup:#define IS_GUEST(ch) (ch->pcdata && IS_SET(ch->pcdata->flags,PCFLAG_GUEST))
mud.h.backup:#define NOT_AUTHED(ch)		(!IS_NPC(ch) && ch->pcdata->auth_state <= 3  \
mud.h.backup:			      && IS_SET(ch->pcdata->flags, PCFLAG_UNAUTHED) )
mud.h.backup:#define IS_WAITING_FOR_AUTH(ch) (!IS_NPC(ch) && ch->desc		     \
mud.h.backup:			      && ch->pcdata->auth_state == 1		     \
mud.h.backup:			      && IS_SET(ch->pcdata->flags, PCFLAG_UNAUTHED) )
mud_comm.c:   if( xIS_EMPTY( ch->in_room->progtypes ) )
mud_comm.c:      ch_printf( ch, "No programs on room:  %s - #%d\r\n", ch->in_room->name, ch->in_room->vnum );
mud_comm.c:   ch_printf( ch, "Name: %s.  Vnum: %d.\r\n", ch->in_room->name, ch->in_room->vnum );
mud_comm.c:   for( mprg = ch->in_room->mudprogs; mprg; mprg = mprg->next )
mud_comm.c:   if( ch->position == POS_FIGHTING
mud_comm.c:       || ch->position == POS_EVASIVE
mud_comm.c:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
mud_comm.c:      for( obj = ch->first_carrying; obj; obj = obj_next )
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   was_in_room = ch->in_room;
mud_comm.c:         ch->in_room = pexit->to_room;
mud_comm.c:   ch->act = actflags;
mud_comm.c:   ch->in_room = was_in_room;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:   ch->act = actflags;
mud_comm.c:   if( ch->pIndexData == pMobIndex )
mud_comm.c:      victim->resetvnum = ch->resetvnum;
mud_comm.c:      victim->resetnum = ch->resetnum;
mud_comm.c:      ch->loadedself = true;
mud_comm.c:   char_to_room( victim, ch->in_room );
mud_comm.c:      obj_to_room( obj, ch->in_room );
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:      for( victim = ch->in_room->first_person; victim; victim = vnext )
mud_comm.c:      while( ch->in_room->first_content )
mud_comm.c:         extract_obj( ch->in_room->first_content );
mud_comm.c:      ch->mobinvis = level;
mud_comm.c:   if( ch->mobinvis < 2 )
mud_comm.c:      ch->mobinvis = ch->level;
mud_comm.c:   if( xIS_SET( ch->act, ACT_MOBINVIS ) )
mud_comm.c:      xREMOVE_BIT( ch->act, ACT_MOBINVIS );
mud_comm.c:      xSET_BIT( ch->act, ACT_MOBINVIS );
mud_comm.c:   in_room = ch->in_room;
mud_comm.c:   if( ch->fighting )
mud_comm.c:      fch_next = fch->next_in_room;
mud_comm.c:      if( fch->mount && fch->mount == ch )
mud_comm.c:   original = ch->in_room;
mud_comm.c:   if( victim->level > ch->level )
mud_comm.c:   if( !ch->in_room )
mud_comm.c:      destination = ch->in_room;
mud_comm.c:      for( victim = ch->in_room->last_person; victim; victim = ChNext )
mud_comm.c:             || ch->in_room->area != d->character->in_room->area
mud_comm.c:      for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
mud_comm.c:            mst = vch->mental_state;
mud_comm.c:            vch->mental_state = 0;
mud_comm.c:               drunk = vch->pcdata->condition[COND_DRUNK];
mud_comm.c:               vch->pcdata->condition[COND_DRUNK] = 0;
mud_comm.c:            vch->mental_state = mst;
mud_comm.c:               vch->pcdata->condition[COND_DRUNK] = drunk;
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !ch->pcdata->nuisance )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   actflags = ch->act;
mud_comm.c:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c:      vch_next = vch->next;
mud_comm.c:      if( vch->in_room->area == ch->in_room->area && !IS_NPC( vch ) && IS_AWAKE( vch ) )
mud_comm.c:   ch->act = actflags;
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:      for( victim = ch->in_room->first_person; victim; victim = nextinroom )
mud_comm.c:             t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, ch->short_descr, argument );
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || IS_AFFECTED( ch, AFF_CHARM ) || ch->desc )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( gold <= ch->gold && ch->in_room )
mud_comm.c:      ch->gold -= gold;
mud_comm.c:      boost_economy( ch->in_room->area, gold );
mud_comm.c:   if( ch->gold < 1000000000 && gold < 1000000000 && ch->in_room && economy_has( ch->in_room->area, gold ) )
mud_comm.c:      ch->gold += gold;
mud_comm.c:      lower_economy( ch->in_room->area, gold );
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:      for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
mud_comm.c:         if( rch->fighting )
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c:                   victim->name, victim->level, ( IS_NPC( ch ) ? ch->short_descr : ch->name ), victim->in_room->vnum );
mud_comm.c:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( xIS_EMPTY( ch->in_room->progtypes ) )
mud_comm.c.backup:      ch_printf( ch, "No programs on room:  %s - #%d\r\n", ch->in_room->name, ch->in_room->vnum );
mud_comm.c.backup:   ch_printf( ch, "Name: %s.  Vnum: %d.\r\n", ch->in_room->name, ch->in_room->vnum );
mud_comm.c.backup:   for( mprg = ch->in_room->mudprogs; mprg; mprg = mprg->next )
mud_comm.c.backup:   if( ch->position == POS_FIGHTING
mud_comm.c.backup:       || ch->position == POS_EVASIVE
mud_comm.c.backup:       || ch->position == POS_DEFENSIVE || ch->position == POS_AGGRESSIVE || ch->position == POS_BERSERK )
mud_comm.c.backup:      for( obj = ch->first_carrying; obj; obj = obj_next )
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   was_in_room = ch->in_room;
mud_comm.c.backup:         ch->in_room = pexit->to_room;
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   ch->in_room = was_in_room;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   if( ch->pIndexData == pMobIndex )
mud_comm.c.backup:      victim->resetvnum = ch->resetvnum;
mud_comm.c.backup:      victim->resetnum = ch->resetnum;
mud_comm.c.backup:      ch->loadedself = true;
mud_comm.c.backup:   char_to_room( victim, ch->in_room );
mud_comm.c.backup:      obj_to_room( obj, ch->in_room );
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:      for( victim = ch->in_room->first_person; victim; victim = vnext )
mud_comm.c.backup:      while( ch->in_room->first_content )
mud_comm.c.backup:         extract_obj( ch->in_room->first_content );
mud_comm.c.backup:      ch->mobinvis = level;
mud_comm.c.backup:   if( ch->mobinvis < 2 )
mud_comm.c.backup:      ch->mobinvis = ch->level;
mud_comm.c.backup:   if( xIS_SET( ch->act, ACT_MOBINVIS ) )
mud_comm.c.backup:      xREMOVE_BIT( ch->act, ACT_MOBINVIS );
mud_comm.c.backup:      xSET_BIT( ch->act, ACT_MOBINVIS );
mud_comm.c.backup:   in_room = ch->in_room;
mud_comm.c.backup:   if( ch->fighting )
mud_comm.c.backup:      fch_next = fch->next_in_room;
mud_comm.c.backup:      if( fch->mount && fch->mount == ch )
mud_comm.c.backup:   original = ch->in_room;
mud_comm.c.backup:   if( victim->level > ch->level )
mud_comm.c.backup:   if( !ch->in_room )
mud_comm.c.backup:      destination = ch->in_room;
mud_comm.c.backup:      for( victim = ch->in_room->last_person; victim; victim = ChNext )
mud_comm.c.backup:             || ch->in_room->area != d->character->in_room->area
mud_comm.c.backup:      for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
mud_comm.c.backup:            mst = vch->mental_state;
mud_comm.c.backup:            vch->mental_state = 0;
mud_comm.c.backup:               drunk = vch->pcdata->condition[COND_DRUNK];
mud_comm.c.backup:               vch->pcdata->condition[COND_DRUNK] = 0;
mud_comm.c.backup:            vch->mental_state = mst;
mud_comm.c.backup:               vch->pcdata->condition[COND_DRUNK] = drunk;
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !ch->pcdata->nuisance )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   actflags = ch->act;
mud_comm.c.backup:   xREMOVE_BIT( ch->act, ACT_SECRETIVE );
mud_comm.c.backup:      vch_next = vch->next;
mud_comm.c.backup:      if( vch->in_room->area == ch->in_room->area && !IS_NPC( vch ) && IS_AWAKE( vch ) )
mud_comm.c.backup:   ch->act = actflags;
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:      for( victim = ch->in_room->first_person; victim; victim = nextinroom )
mud_comm.c.backup:             t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, ch->short_descr, argument );
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || IS_AFFECTED( ch, AFF_CHARM ) || ch->desc )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( gold <= ch->gold && ch->in_room )
mud_comm.c.backup:      ch->gold -= gold;
mud_comm.c.backup:      boost_economy( ch->in_room->area, gold );
mud_comm.c.backup:   if( ch->gold < 1000000000 && gold < 1000000000 && ch->in_room && economy_has( ch->in_room->area, gold ) )
mud_comm.c.backup:      ch->gold += gold;
mud_comm.c.backup:      lower_economy( ch->in_room->area, gold );
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:      for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
mud_comm.c.backup:         if( rch->fighting )
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_comm.c.backup:                   victim->name, victim->level, ( IS_NPC( ch ) ? ch->short_descr : ch->name ), victim->in_room->vnum );
mud_comm.c.backup:   if( !IS_NPC( ch ) || ch->desc || IS_AFFECTED( ch, AFF_CHARM ) )
mud_prog.c:         for( ch = first_char; ch; ch = ch->next )
mud_prog.c:                && ch->in_room
mud_prog.c:                && ch->in_room->area == chkchar->in_room->area
mud_prog.c:                && ch->desc && chkchar->desc && !str_cmp( ch->desc->host, chkchar->desc->host ) )
mud_prog.c:         for( ch = first_char; ch; ch = ch->next )
mud_prog.c:                && ch->desc && chkchar->desc && !str_cmp( ch->desc->host, chkchar->desc->host ) )
mud_prog.c:      for( ch = mob->in_room->first_person; ch; ch = ch->next_in_room )
mud_prog.c:         if( ( !IS_NPC( ch ) ) && get_trust( ch ) < LEVEL_IMMORTAL && nifty_is_name( ch->name, cvar ) )
mud_prog.c:      for( ch = first_char; ch; ch = ch->next )
mud_prog.c:             && ch->in_room->area == mob->in_room->area
mud_prog.c:             && get_trust( ch ) < LEVEL_IMMORTAL && nifty_is_name( ch->name, cvar ) )
mud_prog.c:      for( tch = room ? room->first_person : NULL; tch; tch = tch->next_in_room )
mud_prog.c:      for( tch = room ? room->first_person : NULL; tch; tch = tch->next_in_room )
mud_prog.c:      for( tch = room ? room->first_person : NULL; tch; tch = tch->next_in_room )
mud_prog.c:   for( vch = mob->in_room->first_person; vch; vch = vch->next_in_room )
mud_prog.c:      for( vch = mob->in_room->first_person; vch; vch = vch->next_in_room )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:   for( vmob = ch->in_room->first_person; vmob; vmob = vmob_next )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == vmob->pIndexData )
mud_prog.c:   for( vmob = ch->in_room->first_person; vmob; vmob = vmob_next )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == vmob->pIndexData )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == mob->pIndexData )
mud_prog.c:   for( vmob = ch->in_room->first_person; vmob; vmob = trvch_next( loop_ctrl ) )
mud_prog.c:      if( IS_NPC( ch ) && ch->pIndexData == vmob->pIndexData )
mud_prog.c:      log_printf( "Greet_prog: too many mobs in room %d.", ch->in_room->vnum );
mud_prog.c:   for( vobj = ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:   for( vobj = ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:   for( vobj = ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:   if( HAS_PROG( ch->in_room, LEAVE_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, LOGIN_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, VOID_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, ENTER_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, IMMINFO_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, SLEEP_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, REST_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, RFIGHT_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, RDEATH_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, SPEECH_PROG ) )
mud_prog.c:      rprog_wordlist_check( txt, supermob, ch, NULL, NULL, NULL, SPEECH_PROG, ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, CMD_PROG ) )
mud_prog.c:      if( rprog_wordlist_check( txt, supermob, ch, NULL, NULL, NULL, CMD_PROG, ch->in_room ) )
mud_prog.c:   if( HAS_PROG( ch->in_room, RAND_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:   if( HAS_PROG( ch->in_room, TIME_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:      rprog_time_check( supermob, NULL, NULL, ch->in_room, TIME_PROG );
mud_prog.c:   if( HAS_PROG( ch->in_room, HOUR_PROG ) )
mud_prog.c:      rset_supermob( ch->in_room );
mud_prog.c:      rprog_time_check( supermob, NULL, NULL, ch->in_room, HOUR_PROG );
mud_prog.c:         if( mpact->ch->in_room == room )
news.c:   switch ( ch->substate )
news.c:         news = ( NEWS * ) ch->dest_buf;
news.c:         ch->substate = ch->tempnum;
news.c:         news = ( NEWS * ) ch->dest_buf;
news.c:         ch->substate = ch->tempnum;
news.c:      news->name = STRALLOC( ch->name );
news.c:      if( ch->substate == SUB_REPEATCMD )
news.c:         ch->tempnum = SUB_REPEATCMD;
news.c:         ch->tempnum = SUB_NONE;
news.c:      ch->substate = SUB_NEWS_POST;
news.c:      ch->dest_buf = news;
news.c:      if( ch->substate == SUB_REPEATCMD )
news.c:         ch->tempnum = SUB_REPEATCMD;
news.c:         ch->tempnum = SUB_NONE;
news.c:      ch->substate = SUB_NEWS_EDIT;
news.c:      ch->dest_buf = news;
player.c:   ch_printf( ch, "You have %s gold pieces.\r\n", num_punct( ch->gold ) );
player.c:   pager_printf( ch, "\r\nWorth for %s%s.\r\n", ch->name, ch->pcdata->title );
player.c:   if( !ch->pcdata->deity )
player.c:   else if( ch->pcdata->favor > 2250 )
player.c:   else if( ch->pcdata->favor > 2000 )
player.c:   else if( ch->pcdata->favor > 1750 )
player.c:   else if( ch->pcdata->favor > 1500 )
player.c:   else if( ch->pcdata->favor > 1250 )
player.c:   else if( ch->pcdata->favor > 1000 )
player.c:   else if( ch->pcdata->favor > 750 )
player.c:   else if( ch->pcdata->favor > 250 )
player.c:   else if( ch->pcdata->favor > -250 )
player.c:   else if( ch->pcdata->favor > -750 )
player.c:   else if( ch->pcdata->favor > -1000 )
player.c:   else if( ch->pcdata->favor > -1250 )
player.c:   else if( ch->pcdata->favor > -1500 )
player.c:   else if( ch->pcdata->favor > -1750 )
player.c:   else if( ch->pcdata->favor > -2000 )
player.c:   else if( ch->pcdata->favor > -2250 )
player.c:   if( ch->level < 10 )
player.c:      if( ch->alignment > 900 )
player.c:      else if( ch->alignment > 700 )
player.c:      else if( ch->alignment > 350 )
player.c:      else if( ch->alignment > 100 )
player.c:      else if( ch->alignment > -100 )
player.c:      else if( ch->alignment > -350 )
player.c:      else if( ch->alignment > -700 )
player.c:      else if( ch->alignment > -900 )
player.c:      snprintf( buf2, MAX_STRING_LENGTH, "%d", ch->alignment );
player.c:   pager_printf( ch, "|Level: %-4d |Favor: %-10s |Alignment: %-9s |Experience: %-9d|\r\n", ch->level, buf, buf2, ch->exp );
player.c:   switch ( ch->style )
player.c:                 ch->pcdata->quest_curr, ch->carry_weight, buf, num_punct( ch->gold ) );
player.c:   if( ch->level < 15 && !IS_PKILL( ch ) )
player.c:   if( IS_NPC( ch ) && ch->Class < MAX_NPC_CLASS && ch->Class >= 0 )
player.c:      return ( npc_class[ch->Class] );
player.c:   else if( !IS_NPC( ch ) && ch->Class < MAX_PC_CLASS && ch->Class >= 0 )
player.c:      return class_table[ch->Class]->who_name;
player.c:   if( ch->race < MAX_PC_RACE && ch->race >= 0 )
player.c:      return ( race_table[ch->race]->race_name );
player.c:   if( ch->race < MAX_NPC_RACE && ch->race >= 0 )
player.c:      return ( npc_race[ch->race] );
player.c:   if( ch->level == 1 )
player.c:      lowlvl = UMAX( 2, ch->level - 5 );
player.c:   hilvl = URANGE( ch->level, ch->level + 5, MAX_LEVEL );
player.c:   snprintf( buf, MAX_STRING_LENGTH, " exp  (Current: %12s)", num_punct( ch->exp ) );
player.c:   snprintf( buf2, MAX_STRING_LENGTH, " exp  (Needed:  %12s)", num_punct( exp_level( ch, ch->level + 1 ) - ch->exp ) );
player.c:                 ( x == ch->level ) ? buf : ( x == ch->level + 1 ) ? buf2 : " exp" );
player.c:   if( !ch->pcdata->deity )
player.c:   if( ch->pcdata->favor < ch->level * 2 )
player.c:   pager_printf( ch, "%s appears in a vision, revealing that your remains... ", ch->pcdata->deity->name );
player.c:   snprintf( buf, MAX_STRING_LENGTH, "the corpse of %s", ch->name );
player.c:      ch->pcdata->favor -= ch->level * 2;
player.c:      ch_printf_color( ch, "&C%s\r\n", !xIS_EMPTY( ch->affected_by ) ? affect_bit_name( &ch->affected_by ) : "nothing" );
player.c:      if( ch->level >= 20 )
player.c:         if( ch->resistant > 0 )
player.c:            ch_printf_color( ch, "&C%s\r\n", flag_string( ch->resistant, ris_flags ) );
player.c:         if( ch->immune > 0 )
player.c:            ch_printf_color( ch, "&C%s\r\n", flag_string( ch->immune, ris_flags ) );
player.c:         if( ch->susceptible > 0 )
player.c:            ch_printf_color( ch, "&C%s\r\n", flag_string( ch->susceptible, ris_flags ) );
player.c:   if( !ch->first_affect )
player.c:      for( paf = ch->first_affect; paf; paf = paf->next )
player.c:            if( ch->level >= 20 || IS_PKILL( ch ) )
player.c:   STRFREE( ch->pcdata->title );
player.c:   ch->pcdata->title = STRALLOC( buf );
player.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOTITLE ) )
player.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOCPOSE ) )
player.c:      if( !ch->pcdata->cpose )
player.c:         ch->pcdata->cpose = str_dup( "" );
player.c:      ch_printf( ch, "Your cpose is: %s\r\n", show_tilde( ch->pcdata->cpose ) );
player.c:      if( ch->pcdata->cpose )
player.c:         DISPOSE( ch->pcdata->cpose );
player.c:      ch->pcdata->cpose = str_dup( "" );
player.c:   if( ch->pcdata->cpose )
player.c:      DISPOSE( ch->pcdata->cpose );
player.c:   ch->pcdata->cpose = str_dup( buf );
player.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NODESC ) )
player.c:   if( !ch->desc )
player.c:   switch ( ch->substate )
player.c:         ch->substate = SUB_PERSONAL_DESC;
player.c:         ch->dest_buf = ch;
player.c:         start_editing( ch, ch->description );
player.c:         STRFREE( ch->description );
player.c:         ch->description = copy_buffer( ch );
player.c:   if( IS_SET( ch->pcdata->flags, PCFLAG_NOBIO ) )
player.c:   if( !ch->desc )
player.c:   switch ( ch->substate )
player.c:         ch->substate = SUB_PERSONAL_BIO;
player.c:         ch->dest_buf = ch;
player.c:         start_editing( ch, ch->pcdata->bio );
player.c:         STRFREE( ch->pcdata->bio );
player.c:         ch->pcdata->bio = copy_buffer( ch );
player.c:                 ch->hit, ch->max_hit, ch->pcdata->condition[COND_BLOODTHIRST],
player.c:                 10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:                ch->hit, ch->max_hit, ch->pcdata->condition[COND_BLOODTHIRST],
player.c:                10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:                 ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:                ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:              ch->perm_str, ch->perm_wis, ch->perm_int, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
player.c:             ch->perm_str, ch->perm_wis, ch->perm_int, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
player.c:                 ch->hit, ch->max_hit, ch->pcdata->condition[COND_BLOODTHIRST],
player.c:                 10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:                 ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:              ch->perm_str, ch->perm_wis, ch->perm_int, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
player.c:   if( IS_NPC( ch ) && ch->fighting )
player.c:                 ch->hit, ch->max_hit,
player.c:                 ch->pcdata->condition[COND_BLOODTHIRST], 10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:                 ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:                ch->hit, ch->max_hit,
player.c:                ch->pcdata->condition[COND_BLOODTHIRST], 10 + ch->level, ch->move, ch->max_move, ch->exp );
player.c:                ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp );
player.c:      ch_printf( ch, "%s\r\n", !str_cmp( ch->pcdata->fprompt, "" ) ? "(default prompt)" : ch->pcdata->fprompt );
player.c:   ch_printf( ch, "%s\r\n", !str_cmp( ch->pcdata->fprompt, "" ) ? "(default prompt)" : ch->pcdata->fprompt );
player.c:   if( ch->pcdata->fprompt )
player.c:      STRFREE( ch->pcdata->fprompt );
player.c:      ch->pcdata->fprompt = STRALLOC( "" );
player.c:      ch->pcdata->fprompt = STRALLOC( ch->pcdata->prompt );
player.c:      ch->pcdata->fprompt = STRALLOC( argument );
player.c:      ch_printf( ch, "%s\r\n", !str_cmp( ch->pcdata->prompt, "" ) ? "(default prompt)" : ch->pcdata->prompt );
player.c:   ch_printf( ch, "%s\r\n", !str_cmp( ch->pcdata->prompt, "" ) ? "(default prompt)" : ch->pcdata->prompt );
player.c:   if( ch->pcdata->prompt )
player.c:      STRFREE( ch->pcdata->prompt );
player.c:      ch->pcdata->prompt = STRALLOC( "" );
player.c:      ch->pcdata->prompt = STRALLOC( ch->pcdata->fprompt );
player.c:      ch->pcdata->prompt = STRALLOC( argument );
player.c:      if( xIS_SET( ch->act, PLR_COMPASS ) )
player.c:         xREMOVE_BIT( ch->act, PLR_COMPASS );
player.c:         xSET_BIT( ch->act, PLR_COMPASS );
player.c:   if( !ch->pcdata->deity )
player.c:   else if( ch->pcdata->favor > 2250 )
player.c:   else if( ch->pcdata->favor > 2000 )
player.c:   else if( ch->pcdata->favor > 1750 )
player.c:   else if( ch->pcdata->favor > 1500 )
player.c:   else if( ch->pcdata->favor > 1250 )
player.c:   else if( ch->pcdata->favor > 1000 )
player.c:   else if( ch->pcdata->favor > 750 )
player.c:   else if( ch->pcdata->favor > 250 )
player.c:   else if( ch->pcdata->favor > -250 )
player.c:   else if( ch->pcdata->favor > -750 )
player.c:   else if( ch->pcdata->favor > -1000 )
player.c:   else if( ch->pcdata->favor > -1250 )
player.c:   else if( ch->pcdata->favor > -1500 )
player.c:   else if( ch->pcdata->favor > -1750 )
player.c:   else if( ch->pcdata->favor > -2000 )
player.c:   else if( ch->pcdata->favor > -2250 )
player.c:   ch_printf( ch, "%s considers you to be %s.\n\r", ch->pcdata->deity->name, buf );
polymorph.c:   if( ch->level < morph->level )
polymorph.c:   if( morph->sex != -1 && morph->sex != ch->sex )
polymorph.c:   if( morph->Class != 0 && !IS_SET( morph->Class, ( 1 << ch->Class ) ) )
polymorph.c:   if( morph->race != 0 && IS_SET( morph->race, ( 1 << ch->race ) ) )
polymorph.c:   if( morph->deity && ( !ch->pcdata->deity || !get_deity( morph->deity ) ) )
polymorph.c:   if( !ch->desc )
polymorph.c:   switch ( ch->substate )
polymorph.c:         if( !ch->dest_buf )
polymorph.c:            bug( "%s", "do_morphset: sub_morph_desc: NULL ch->dest_buf" );
polymorph.c:            ch->substate = SUB_NONE;
polymorph.c:         morph = ( MORPH_DATA * ) ch->dest_buf;
polymorph.c:         ch->substate = ch->tempnum;
polymorph.c:         if( ch->substate == SUB_REPEATCMD )
polymorph.c:            ch->dest_buf = morph;
polymorph.c:         if( !ch->dest_buf )
polymorph.c:            bug( "%s", "do_morphset: sub_morph_help: NULL ch->dest_buf" );
polymorph.c:            ch->substate = SUB_NONE;
polymorph.c:         morph = ( MORPH_DATA * ) ch->dest_buf;
polymorph.c:         ch->substate = ch->tempnum;
polymorph.c:         if( ch->substate == SUB_REPEATCMD )
polymorph.c:            ch->dest_buf = morph;
polymorph.c:   if( ch->substate == SUB_REPEATCMD )
polymorph.c:      morph = ( MORPH_DATA * ) ch->dest_buf;
polymorph.c:         ch->substate = SUB_NONE;
polymorph.c:         ch->dest_buf = NULL;
polymorph.c:         STRFREE( ch->pcdata->subprompt );
polymorph.c:   if( ch->substate != SUB_REPEATCMD && arg1[0] != '\0' && !str_cmp( arg1, "save" ) )
polymorph.c:   if( arg1[0] == '\0' || ( arg2[0] == '\0' && ch->substate != SUB_REPEATCMD ) || !str_cmp( arg1, "?" ) )
polymorph.c:      if( ch->substate == SUB_REPEATCMD )
polymorph.c:      ch->substate = SUB_REPEATCMD;
polymorph.c:      ch->dest_buf = morph;
polymorph.c:      STRFREE( ch->pcdata->subprompt );
polymorph.c:      ch->pcdata->subprompt = STRALLOC( buf );
polymorph.c:      if( ch->substate == SUB_REPEATCMD )
polymorph.c:         ch->tempnum = SUB_REPEATCMD;
polymorph.c:         ch->tempnum = SUB_NONE;
polymorph.c:      ch->substate = SUB_MORPH_DESC;
polymorph.c:      ch->dest_buf = morph;
polymorph.c:      if( ch->substate == SUB_REPEATCMD )
polymorph.c:         ch->tempnum = SUB_REPEATCMD;
polymorph.c:         ch->tempnum = SUB_NONE;
polymorph.c:      ch->substate = SUB_MORPH_HELP;
polymorph.c:      ch->dest_buf = morph;
polymorph.c:   else if( ch->substate == SUB_REPEATCMD )
polymorph.c:      ch->substate = SUB_RESTRICTED;
polymorph.c:      ch->substate = SUB_REPEATCMD;
polymorph.c:      ch->last_cmd = do_morphset;
polymorph.c:   if( ch->morph )
polymorph.c:   ch->armor += morph->ac;
polymorph.c:   ch->mod_str += morph->str;
polymorph.c:   ch->mod_int += morph->inte;
polymorph.c:   ch->mod_wis += morph->wis;
polymorph.c:   ch->mod_dex += morph->dex;
polymorph.c:   ch->mod_cha += morph->cha;
polymorph.c:   ch->mod_lck += morph->lck;
polymorph.c:   ch->saving_breath += morph->saving_breath;
polymorph.c:   ch->saving_para_petri += morph->saving_para_petri;
polymorph.c:   ch->saving_poison_death += morph->saving_poison_death;
polymorph.c:   ch->saving_spell_staff += morph->saving_spell_staff;
polymorph.c:   ch->saving_wand += morph->saving_wand;
polymorph.c:   ch->hitroll += ch_morph->hitroll;
polymorph.c:   ch->damroll += ch_morph->damroll;
polymorph.c:   if( ( ch->hit + ch_morph->hit ) > 32700 )
polymorph.c:      ch_morph->hit = ( 32700 - ch->hit );
polymorph.c:   ch->hit += ch_morph->hit;
polymorph.c:   if( ( ch->move + ch_morph->move ) > 32700 )
polymorph.c:      ch_morph->move = ( 32700 - ch->move );
polymorph.c:   ch->move += ch_morph->move;
polymorph.c:   if( ( ch->mana + ch_morph->mana ) > 32700 )
polymorph.c:      ch_morph->mana = ( 32700 - ch->mana );
polymorph.c:   ch->mana += ch_morph->mana;
polymorph.c:   xSET_BITS( ch->affected_by, morph->affected_by );
polymorph.c:   SET_BIT( ch->immune, morph->immune );
polymorph.c:   SET_BIT( ch->resistant, morph->resistant );
polymorph.c:   SET_BIT( ch->susceptible, morph->suscept );
polymorph.c:   xREMOVE_BITS( ch->affected_by, morph->no_affected_by );
polymorph.c:   REMOVE_BIT( ch->immune, morph->no_immune );
polymorph.c:   REMOVE_BIT( ch->resistant, morph->no_resistant );
polymorph.c:   REMOVE_BIT( ch->susceptible, morph->no_suscept );
polymorph.c:   ch->morph = ch_morph;
polymorph.c:   if( ch->morph )
polymorph.c:      if( ch->hit < morph->hpused )
polymorph.c:         ch->hit -= morph->hpused;
polymorph.c:      if( ch->move < morph->moveused )
polymorph.c:         ch->move -= morph->moveused;
polymorph.c:      if( ch->mana < morph->manaused )
polymorph.c:         ch->mana -= morph->manaused;
polymorph.c:      if( IS_NPC( ch ) || !ch->pcdata->deity || ch->pcdata->favor < morph->favourused )
polymorph.c:         ch->pcdata->favor -= morph->favourused;
polymorph.c:   if( ( morph = ch->morph ) == NULL )
polymorph.c:   ch->armor -= morph->ac;
polymorph.c:   ch->mod_str -= morph->str;
polymorph.c:   ch->mod_int -= morph->inte;
polymorph.c:   ch->mod_wis -= morph->wis;
polymorph.c:   ch->mod_dex -= morph->dex;
polymorph.c:   ch->mod_cha -= morph->cha;
polymorph.c:   ch->mod_lck -= morph->lck;
polymorph.c:   ch->saving_breath -= morph->saving_breath;
polymorph.c:   ch->saving_para_petri -= morph->saving_para_petri;
polymorph.c:   ch->saving_poison_death -= morph->saving_poison_death;
polymorph.c:   ch->saving_spell_staff -= morph->saving_spell_staff;
polymorph.c:   ch->saving_wand -= morph->saving_wand;
polymorph.c:   ch->hitroll -= morph->hitroll;
polymorph.c:   ch->damroll -= morph->damroll;
polymorph.c:   ch->hit -= morph->hit;
polymorph.c:   ch->move -= morph->move;
polymorph.c:   ch->mana -= morph->mana;
polymorph.c:   if( ch->mana > ch->max_mana )
polymorph.c:      ch->mana = ch->max_mana;
polymorph.c:   xREMOVE_BITS( ch->affected_by, morph->affected_by );
polymorph.c:   REMOVE_BIT( ch->immune, morph->immune );
polymorph.c:   REMOVE_BIT( ch->resistant, morph->resistant );
polymorph.c:   REMOVE_BIT( ch->susceptible, morph->suscept );
polymorph.c:   DISPOSE( ch->morph );
polymorph.c:   if( !ch->morph )
polymorph.c:   temp = ch->morph->morph;
polymorph.c:   if( !ch->morph )
polymorph.c:   for( vch = first_char; vch; vch = vch->next )
polymorph.c:      if( vch->morph == NULL || vch->morph->morph == NULL || vch->morph->morph != morph )
polymorph.c:   if( ch->morph == NULL )
polymorph.c:   morph = ch->morph;
polymorph.c:   ch->morph = morph;
renumber.c:   if( ch->level < LEVEL_SAVIOR )
renumber.c:   if( ch->level == LEVEL_SAVIOR )
renumber.c:      if( area->low_r_vnum < ch->pcdata->r_range_lo || area->hi_r_vnum > ch->pcdata->r_range_hi ||
renumber.c:          area->low_m_vnum < ch->pcdata->m_range_lo || area->hi_m_vnum > ch->pcdata->m_range_hi ||
renumber.c:          area->low_o_vnum < ch->pcdata->o_range_lo || area->hi_o_vnum > ch->pcdata->o_range_hi )
renumber.c:   if( ch->level == LEVEL_SAVIOR )
renumber.c:      if( r_area->low_room < ch->pcdata->r_range_lo || r_area->hi_room > ch->pcdata->r_range_hi ||
renumber.c:          r_area->low_obj < ch->pcdata->o_range_lo || r_area->hi_obj > ch->pcdata->o_range_hi ||
renumber.c:          r_area->low_mob < ch->pcdata->m_range_lo || r_area->hi_mob > ch->pcdata->m_range_hi )
reset.c:   for( rch = pRoom->first_person; rch; rch = rch->next_in_room )
reset.c:      add_reset( pRoom, 'M', 1, rch->pIndexData->vnum, rch->pIndexData->count, pRoom->vnum );
reset.c:      for( obj = rch->first_carrying; obj; obj = obj->next_content )
reset.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_SAVIOR || !ch->pcdata->area )
reset.c:   if( !can_rmodify( ch, ch->in_room ) )
reset.c:   if( ch->in_room->area != ch->pcdata->area && get_trust( ch ) < LEVEL_GREATER )
reset.c:   if( ch->in_room->first_reset )
reset.c:      wipe_resets( ch->in_room );
reset.c:   instaroom( ch->in_room, dodoors );
reset.c:   if( IS_NPC( ch ) || get_trust( ch ) < LEVEL_SAVIOR || !ch->pcdata->area )
reset.c:   pArea = ch->pcdata->area;
reset.c:      reset_area( ch->in_room->area );
reset.c:      for( room = ch->in_room->area->first_room; room; room = room->next_aroom )
reset.c:      for( pReset = ch->in_room->first_reset; pReset; pReset = pReset_next )
reset.c:            UNLINK( pReset, ch->in_room->first_reset, ch->in_room->last_reset, next, prev );
reset.c:      pReset = make_reset( 'R', 0, ch->in_room->vnum, door, 0 );
reset.c:      pReset->next = ch->in_room->first_reset;
reset.c:      if( ch->in_room->first_reset )
reset.c:         ch->in_room->first_reset->prev = pReset;
reset.c:      ch->in_room->first_reset = pReset;
reset.c:      if( !ch->in_room->last_reset )
reset.c:         ch->in_room->last_reset = pReset;
reset.c:         vnum = ch->in_room->vnum;
reset.c:         if( !( pReset = find_oreset( ch->in_room, oname ) ) )
reset.c:         tReset->next = ch->in_room->first_reset;
reset.c:         if( ch->in_room->first_reset )
reset.c:            ch->in_room->first_reset->prev = tReset;
reset.c:         ch->in_room->first_reset = tReset;
reset.c:         if( !ch->in_room->last_reset )
reset.c:            ch->in_room->last_reset = tReset;
reset.c:      if( !( pReset = find_oreset( ch->in_room, argument ) ) )
reset.c:         tReset->next = ch->in_room->first_reset;
reset.c:         if( ch->in_room->first_reset )
reset.c:            ch->in_room->first_reset->prev = tReset;
reset.c:         ch->in_room->first_reset = tReset;
reset.c:         if( !ch->in_room->last_reset )
reset.c:            ch->in_room->last_reset = tReset;
reset.c:   if( ch->loadedself )
reset.c:   if( !( room = get_room_index( ch->resetvnum ) ) )
reset.c:      if( ++nfind == ch->resetnum )
reset.c:         if( ++nfind == ch->resetnum )
reset.c:            if( ++nfind == ch->resetnum )
save.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
save.c:                    ch->name, MAX_LAYERS, obj->wear_loc, obj->name );
save.c:            bug( "%s had on %s:  ch->level = %d  obj->level = %d", ch->name, obj->name, ch->level, obj->level );
save.c:   if( ch->in_room )
save.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
save.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
save.c:   if( ch->in_room )
save.c:      for( paf = ch->in_room->first_affect; paf; paf = paf->next )
save.c:      for( paf = ch->in_room->first_permaffect; paf; paf = paf->next )
save.c:   age = ch->played / 86400;   /* Calculate realtime number of days played */
save.c:   ch->pcdata->day = ( number_range( 1, sysdata.dayspermonth ) - 1 );   /* Assign random day of birth */
save.c:   ch->pcdata->month = ( number_range( 1, sysdata.monthsperyear ) - 1 );   /* Assign random month of birth */
save.c:   ch->pcdata->year = time_info.year - age;  /* Assign birth year based on calculations above */
save.c:   if( IS_NPC( ch ) || ch->level < 2 )
save.c:   if( ch->desc && ch->desc->original )
save.c:      ch = ch->desc->original;
save.c:   ch->save_time = current_time;
save.c:   snprintf( strsave, MAX_INPUT_LENGTH, "%s%c/%s", PLAYER_DIR, tolower( ch->pcdata->filename[0] ),
save.c:             capitalize( ch->pcdata->filename ) );
save.c:      snprintf( strback, MAX_INPUT_LENGTH, "%s%c/%s", BACKUP_DIR, tolower( ch->pcdata->filename[0] ),
save.c:                capitalize( ch->pcdata->filename ) );
save.c:   if( ch->level >= LEVEL_IMMORTAL || IS_SET( ch->pcdata->flags, PCFLAG_RETIRED ) )
save.c:      snprintf( strback, MAX_INPUT_LENGTH, "%s%s", GOD_DIR, capitalize( ch->pcdata->filename ) );
save.c:         fprintf( fp, "Level        %d\n", ch->level );
save.c:         fprintf( fp, "Pcflags      %d\n", ch->pcdata->flags );
save.c:         if( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
save.c:            fprintf( fp, "RoomRange    %d %d\n", ch->pcdata->r_range_lo, ch->pcdata->r_range_hi );
save.c:         if( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
save.c:            fprintf( fp, "ObjRange     %d %d\n", ch->pcdata->o_range_lo, ch->pcdata->o_range_hi );
save.c:         if( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
save.c:            fprintf( fp, "MobRange     %d %d\n", ch->pcdata->m_range_lo, ch->pcdata->m_range_hi );
save.c:      if( ch->morph )
save.c:      if( ch->first_carrying )
save.c:         fwrite_obj( ch, ch->last_carrying, fp, 0, OS_CARRY, ch->pcdata->hotboot );
save.c:      if( sysdata.save_pets && ch->pcdata->pet )
save.c:         fwrite_mobile( fp, ch->pcdata->pet );
save.c:      if( ch->variables )
save.c:      if( ch->comments )   /* comments */
save.c:   fprintf( fp, "Name         %s~\n", ch->name );
save.c:   if( ch->description[0] != '\0' )
save.c:      fprintf( fp, "Description  %s~\n", ch->description );
save.c:   fprintf( fp, "Sex          %d\n", ch->sex );
save.c:   fprintf( fp, "Class        %d\n", ch->Class );
save.c:   fprintf( fp, "Race         %d\n", ch->race );
save.c:            ch->pcdata->age_bonus, ch->pcdata->day, ch->pcdata->month, ch->pcdata->year );
save.c:   fprintf( fp, "Languages    %d %d\n", ch->speaks, ch->speaking );
save.c:   fprintf( fp, "Level        %d\n", ch->level );
save.c:   fprintf( fp, "Played       %d\n", ch->played + ( int )( current_time - ch->logon ) );
save.c:            ( ch->in_room == get_room_index( ROOM_VNUM_LIMBO )
save.c:              && ch->was_in_room ) ? ch->was_in_room->vnum : ch->in_room->vnum );
save.c:   fprintf( fp, "HpManaMove   %d %d %d %d %d %d\n", ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move );
save.c:   fprintf( fp, "Gold         %d\n", ch->gold );
save.c:   fprintf( fp, "Exp          %d\n", ch->exp );
save.c:   fprintf( fp, "Height          %d\n", ch->height );
save.c:   fprintf( fp, "Weight          %d\n", ch->weight );
save.c:   fprintf( fp, "Str          %d\n", ch->pcdata->str );
save.c:   fprintf( fp, "Intel          %d\n", ch->pcdata->intel );
save.c:   fprintf( fp, "Dex         %d\n", ch->pcdata->dex );
save.c:   fprintf( fp, "Lck          %d\n", ch->pcdata->lck );
save.c:   fprintf( fp, "Att          %d\n", ch->pcdata->att );
save.c:   fprintf( fp, "Def          %d\n", ch->pcdata->def );
save.c:   fprintf( fp, "Matt          %d\n", ch->pcdata->matt );
save.c:   fprintf( fp, "Mdef          %d\n", ch->pcdata->mdef );
save.c:   fprintf( fp, "strplus          %d\n", ch->pcdata->strplus );
save.c:   fprintf( fp, "intplus          %d\n", ch->pcdata->intplus );
save.c:   fprintf( fp, "dexplus          %d\n", ch->pcdata->dexplus );
save.c:   fprintf( fp, "lckplus          %d\n", ch->pcdata->lckplus );
save.c:   fprintf( fp, "attplus          %d\n", ch->pcdata->attplus );
save.c:   fprintf( fp, "defplus          %d\n", ch->pcdata->defplus );
save.c:   fprintf( fp, "mattplus          %d\n", ch->pcdata->mattplus );
save.c:   fprintf( fp, "mdefplus          %d\n", ch->pcdata->mdefplus );
save.c:   fprintf( fp, "mlevel          %d\n", ch->pcdata->mlevel );
save.c:   fprintf( fp, "deflevel          %d\n", ch->pcdata->deflevel );
save.c:   fprintf( fp, "attlevel          %d\n", ch->pcdata->attlevel );
save.c:   if( !xIS_EMPTY( ch->act ) )
save.c:      fprintf( fp, "Act          %s\n", print_bitvector( &ch->act ) );
save.c:   if( !xIS_EMPTY( ch->affected_by ) )
save.c:      fprintf( fp, "AffectedBy   %s\n", print_bitvector( &ch->affected_by ) );
save.c:   if( !xIS_EMPTY( ch->no_affected_by ) )
save.c:      fprintf( fp, "NoAffectedBy %s\n", print_bitvector( &ch->no_affected_by ) );
save.c:   pos = ch->position;
save.c:   fprintf( fp, "Style     %d\n", ch->style );
save.c:   fprintf( fp, "Practice     %d\n", ch->practice );
save.c:            ch->saving_poison_death, ch->saving_wand, ch->saving_para_petri, ch->saving_breath, ch->saving_spell_staff );
save.c:   fprintf( fp, "Alignment    %d\n", ch->alignment );
save.c:   fprintf( fp, "Favor        %d\n", ch->pcdata->favor );
save.c:   fprintf( fp, "Balance      %d\n", ch->pcdata->balance );
save.c:   fprintf( fp, "Glory        %d\n", ch->pcdata->quest_curr );
save.c:   fprintf( fp, "MGlory       %d\n", ch->pcdata->quest_accum );
save.c:   fprintf( fp, "Ap        %d\n", ch->pcdata->ap );   
save.c:   fprintf( fp, "Tier        %d\n", ch->pcdata->tier );   
save.c:   fprintf( fp, "Hitroll      %d\n", ch->hitroll );
save.c:   fprintf( fp, "Damroll      %d\n", ch->damroll );
save.c:   fprintf( fp, "Armor        %d\n", ch->armor );
save.c:   if( ch->wimpy )
save.c:      fprintf( fp, "Wimpy        %d\n", ch->wimpy );
save.c:   if( ch->deaf )
save.c:      fprintf( fp, "Deaf         %d\n", ch->deaf );
save.c:   if( ch->resistant )
save.c:      fprintf( fp, "Resistant    %d\n", ch->resistant );
save.c:   if( ch->no_resistant )
save.c:      fprintf( fp, "NoResistant  %d\n", ch->no_resistant );
save.c:   if( ch->immune )
save.c:      fprintf( fp, "Immune       %d\n", ch->immune );
save.c:   if( ch->no_immune )
save.c:      fprintf( fp, "NoImmune     %d\n", ch->no_immune );
save.c:   if( ch->susceptible )
save.c:      fprintf( fp, "Susceptible  %d\n", ch->susceptible );
save.c:   if( ch->no_susceptible )
save.c:      fprintf( fp, "NoSusceptible  %d\n", ch->no_susceptible );
save.c:   if( ch->pcdata && ch->pcdata->outcast_time )
save.c:      fprintf( fp, "Outcast_time %ld\n", ch->pcdata->outcast_time );
save.c:   if( ch->pcdata && ch->pcdata->nuisance )
save.c:      fprintf( fp, "NuisanceNew %ld %ld %d %d\n", ch->pcdata->nuisance->set_time,
save.c:               ch->pcdata->nuisance->max_time, ch->pcdata->nuisance->flags, ch->pcdata->nuisance->power );
save.c:   if( ch->mental_state != -10 )
save.c:      fprintf( fp, "Mentalstate  %d\n", ch->mental_state );
save.c:   fprintf( fp, "Password     %s~\n", ch->pcdata->pwd );
save.c:   if( ch->pcdata->rank && ch->pcdata->rank[0] != '\0' )
save.c:      fprintf( fp, "Rank         %s~\n", ch->pcdata->rank );
save.c:   if( ch->pcdata->bestowments && ch->pcdata->bestowments[0] != '\0' )
save.c:      fprintf( fp, "Bestowments  %s~\n", ch->pcdata->bestowments );
save.c:   fprintf( fp, "Title        %s~\n", ch->pcdata->title );
save.c:   fprintf( fp, "Cpose        %s~\n", ch->pcdata->cpose );
save.c:   fprintf( fp, "Hometown        %s~\n", ch->pcdata->hometown );
save.c:   fprintf( fp, "Customclass        %s~\n", ch->pcdata->customclass );
save.c:   if( ch->pcdata->homepage && ch->pcdata->homepage[0] != '\0' )
save.c:      fprintf( fp, "Homepage     %s~\n", ch->pcdata->homepage );
save.c:   if( ch->pcdata->bio && ch->pcdata->bio[0] != '\0' )
save.c:      fprintf( fp, "Bio          %s~\n", ch->pcdata->bio );
save.c:   if( ch->pcdata->authed_by && ch->pcdata->authed_by[0] != '\0' )
save.c:      fprintf( fp, "AuthedBy     %s~\n", ch->pcdata->authed_by );
save.c:   if( ch->pcdata->min_snoop )
save.c:      fprintf( fp, "Minsnoop     %d\n", ch->pcdata->min_snoop );
save.c:   if( ch->pcdata->prompt && *ch->pcdata->prompt )
save.c:      fprintf( fp, "Prompt       %s~\n", ch->pcdata->prompt );
save.c:   if( ch->pcdata->fprompt && *ch->pcdata->fprompt )
save.c:      fprintf( fp, "FPrompt	     %s~\n", ch->pcdata->fprompt );
save.c:   if( ch->pcdata->pagerlen != 24 )
save.c:      fprintf( fp, "Pagerlen     %d\n", ch->pcdata->pagerlen );
save.c:      for( temp = ch->pcdata->first_ignored; temp; temp = temp->next )
save.c:      if( ch->pcdata->bamfin && ch->pcdata->bamfin[0] != '\0' )
save.c:         fprintf( fp, "Bamfin       %s~\n", ch->pcdata->bamfin );
save.c:      if( ch->pcdata->bamfout && ch->pcdata->bamfout[0] != '\0' )
save.c:         fprintf( fp, "Bamfout      %s~\n", ch->pcdata->bamfout );
save.c:      if( ch->trust )
save.c:         fprintf( fp, "Trust        %d\n", ch->trust );
save.c:      if( ch->pcdata && ch->pcdata->restore_time )
save.c:         fprintf( fp, "Restore_time %ld\n", ch->pcdata->restore_time );
save.c:      fprintf( fp, "WizInvis     %d\n", ch->pcdata->wizinvis );
save.c:      if( ch->pcdata->r_range_lo && ch->pcdata->r_range_hi )
save.c:         fprintf( fp, "RoomRange    %d %d\n", ch->pcdata->r_range_lo, ch->pcdata->r_range_hi );
save.c:      if( ch->pcdata->o_range_lo && ch->pcdata->o_range_hi )
save.c:         fprintf( fp, "ObjRange     %d %d\n", ch->pcdata->o_range_lo, ch->pcdata->o_range_hi );
save.c:      if( ch->pcdata->m_range_lo && ch->pcdata->m_range_hi )
save.c:         fprintf( fp, "MobRange     %d %d\n", ch->pcdata->m_range_lo, ch->pcdata->m_range_hi );
save.c:   if( ch->pcdata->council )
save.c:      fprintf( fp, "Council      %s~\n", ch->pcdata->council_name );
save.c:   if( ch->pcdata->deity_name && ch->pcdata->deity_name[0] != '\0' )
save.c:      fprintf( fp, "Deity	     %s~\n", ch->pcdata->deity_name );
save.c:   if( ch->pcdata->clan_name && ch->pcdata->clan_name[0] != '\0' )
save.c:      fprintf( fp, "Clan         %s~\n", ch->pcdata->clan_name );
save.c:   fprintf( fp, "Flags        %d\n", ch->pcdata->flags );
save.c:   if( ch->pcdata->release_date )
save.c:      fprintf( fp, "Helled       %d %s~\n", ( int )ch->pcdata->release_date, ch->pcdata->helled_by );
save.c:   fprintf( fp, "PKills       %d\n", ch->pcdata->pkills );
save.c:   fprintf( fp, "PDeaths      %d\n", ch->pcdata->pdeaths );
save.c:   fprintf( fp, "MKills       %d\n", ch->pcdata->mkills );
save.c:   fprintf( fp, "MDeaths      %d\n", ch->pcdata->mdeaths );
save.c:   fprintf( fp, "IllegalPK    %d\n", ch->pcdata->illegal_pk );
save.c:   fprintf( fp, "Timezone     %d\n", ch->pcdata->timezone );
save.c:            ch->perm_str, ch->perm_int, ch->perm_wis, ch->perm_dex, ch->perm_con, ch->perm_cha, ch->perm_lck );
save.c:            ch->mod_str, ch->mod_int, ch->mod_wis, ch->mod_dex, ch->mod_con, ch->mod_cha, ch->mod_lck );
save.c:            ch->pcdata->condition[0], ch->pcdata->condition[1], ch->pcdata->condition[2], ch->pcdata->condition[3] );
save.c:   if( ch->pcdata->recent_site )
save.c:      fprintf( fp, "Site         %s\n", ch->pcdata->recent_site );
save.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) && !IS_IMMORTAL( ch ) )
save.c:            if( tmphome->vnum[i] == ch->in_room->vnum )
save.c:         if( ch->in_room->vnum == tmphb->vnum )
save.c:      if( skill_table[sn]->name && ch->pcdata->learned[sn] > 0 )
save.c:               fprintf( fp, "Skill        %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:               fprintf( fp, "Ability      %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:               fprintf( fp, "Spell        %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:               fprintf( fp, "Weapon       %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:               fprintf( fp, "Tongue       %d '%s'\n", ch->pcdata->learned[sn], skill_table[sn]->name );
save.c:   for( paf = ch->first_affect; paf; paf = paf->next )
save.c:   track = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
save.c:      if( ch->pcdata->killed[sn].vnum == 0 )
save.c:      fprintf( fp, "Killed       %d %d\n", ch->pcdata->killed[sn].vnum, ch->pcdata->killed[sn].count );
save.c:         fprintf( fp, "%d ", ch->colors[x] );
save.c:      if( (ch && ch->level < obj->level)
save.c:   CREATE( ch->pcdata, PC_DATA, 1 );
save.c:   ch->desc = d;
save.c:   ch->pcdata->filename = STRALLOC( name );
save.c:   ch->name = NULL;
save.c:      ch->pcdata->recent_site = STRALLOC( d->host );
save.c:   ch->act = multimeb( PLR_BLANK, PLR_COMBINE, PLR_PROMPT, -1 );
save.c:   ch->perm_str = 13;
save.c:   ch->perm_int = 13;
save.c:   ch->perm_wis = 13;
save.c:   ch->perm_dex = 13;
save.c:   ch->perm_con = 13;
save.c:   ch->perm_cha = 13;
save.c:   ch->perm_lck = 13;
save.c:   ch->no_resistant = 0;
save.c:   ch->no_susceptible = 0;
save.c:   ch->no_immune = 0;
save.c:   ch->was_in_room = NULL;
save.c:   xCLEAR_BITS( ch->no_affected_by );
save.c:   ch->pcdata->condition[COND_THIRST] = 48;
save.c:   ch->pcdata->condition[COND_FULL] = 48;
save.c:   ch->pcdata->condition[COND_BLOODTHIRST] = 10;
save.c:   ch->pcdata->nuisance = NULL;
save.c:   ch->pcdata->wizinvis = 0;
save.c:   ch->pcdata->balance = 0;
save.c:   ch->pcdata->charmies = 0;
save.c:   ch->mental_state = -10;
save.c:   ch->mobinvis = 0;
save.c:      ch->pcdata->learned[i] = 0;
save.c:   ch->pcdata->release_date = 0;
save.c:   ch->pcdata->helled_by = NULL;
save.c:   ch->saving_poison_death = 0;
save.c:   ch->saving_wand = 0;
save.c:   ch->saving_para_petri = 0;
save.c:   ch->saving_breath = 0;
save.c:   ch->saving_spell_staff = 0;
save.c:   ch->style = STYLE_FIGHTING;
save.c:   ch->comments = NULL; /* comments */
save.c:   ch->pcdata->pagerlen = 24;
save.c:   ch->pcdata->first_ignored = NULL;   /* Ignore list */
save.c:   ch->pcdata->last_ignored = NULL;
save.c:   ch->pcdata->tell_history = NULL; /* imm only lasttell cmnd */
save.c:   ch->pcdata->lt_index = 0;  /* last tell index */
save.c:   ch->morph = NULL;
save.c:   ch->pcdata->hotboot = FALSE;  /* Never changed except when PC is saved during hotboot save */
save.c:                          preload ? "Preloading" : "Loading", ch->pcdata->filename, ( int )fst.st_size / 1024 );
save.c:               ch->pcdata->pet = mob;
save.c:               bug( "%s: Deleted mob saved on %s - skipping", __func__, ch->name );
save.c:      ch->name = STRALLOC( name );
save.c:      ch->short_descr = STRALLOC( "" );
save.c:      ch->long_descr = STRALLOC( "" );
save.c:      ch->description = STRALLOC( "" );
save.c:      ch->editor = NULL;
save.c:      ch->pcdata->clan_name = STRALLOC( "" );
save.c:      ch->pcdata->clan = NULL;
save.c:      ch->pcdata->council_name = STRALLOC( "" );
save.c:      ch->pcdata->council = NULL;
save.c:      ch->pcdata->deity_name = STRALLOC( "" );
save.c:      ch->pcdata->deity = NULL;
save.c:      ch->pcdata->pet = NULL;
save.c:      ch->pcdata->pwd = str_dup( "" );
save.c:      ch->pcdata->bamfin = str_dup( "" );
save.c:      ch->pcdata->bamfout = str_dup( "" );
save.c:      ch->pcdata->rank = str_dup( "" );
save.c:      ch->pcdata->bestowments = str_dup( "" );
save.c:      ch->pcdata->title = STRALLOC( "" );
save.c:      ch->pcdata->customclass = STRALLOC( "" );
save.c:      ch->pcdata->homepage = str_dup( "" );
save.c:      ch->pcdata->bio = STRALLOC( "" );
save.c:      ch->pcdata->authed_by = STRALLOC( "" );
save.c:      ch->pcdata->prompt = STRALLOC( "" );
save.c:      ch->pcdata->fprompt = STRALLOC( "" );
save.c:      ch->pcdata->r_range_lo = 0;
save.c:      ch->pcdata->r_range_hi = 0;
save.c:      ch->pcdata->m_range_lo = 0;
save.c:      ch->pcdata->m_range_hi = 0;
save.c:      ch->pcdata->o_range_lo = 0;
save.c:      ch->pcdata->o_range_hi = 0;
save.c:      ch->pcdata->wizinvis = 0;
save.c:      ch->pcdata->timezone = -1;
save.c:      if( !ch->name )
save.c:         ch->name = STRALLOC( name );
save.c:      if( !ch->pcdata->clan_name )
save.c:         ch->pcdata->clan_name = STRALLOC( "" );
save.c:         ch->pcdata->clan = NULL;
save.c:      if( !ch->pcdata->council_name )
save.c:         ch->pcdata->council_name = STRALLOC( "" );
save.c:         ch->pcdata->council = NULL;
save.c:      if( !ch->pcdata->deity_name )
save.c:         ch->pcdata->deity_name = STRALLOC( "" );
save.c:         ch->pcdata->deity = NULL;
save.c:      if( !ch->pcdata->bio )
save.c:         ch->pcdata->bio = STRALLOC( "" );
save.c:      if( !ch->pcdata->authed_by )
save.c:         ch->pcdata->authed_by = STRALLOC( "" );
save.c:      if( xIS_SET( ch->act, PLR_FLEE ) )
save.c:         xREMOVE_BIT( ch->act, PLR_FLEE );
save.c:         if( ch->pcdata->wizinvis < 2 )
save.c:            ch->pcdata->wizinvis = ch->level;
save.c:   memcpy( &ch->colors, &default_set, sizeof( default_set ) );
save.c:            KEY( "Act", ch->act, fread_bitvector( fp ) );
save.c:            KEY( "AffectedBy", ch->affected_by, fread_bitvector( fp ) );
save.c:            KEY( "Alignment", ch->alignment, fread_number( fp ) );
save.c:            KEY( "Armor", ch->armor, fread_number( fp ) );
save.c:                     KEY( "Att", ch->pcdata->att, fread_number( fp ) );
save.c:                     KEY( "Attplus", ch->pcdata->attplus, fread_number( fp ) );
save.c:                     KEY( "Attlevel", ch->pcdata->attlevel, fread_number( fp ) );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                     if( ch->level < LEVEL_IMMORTAL )
save.c:                        if( skill_table[sn]->race_level[ch->race] >= LEVEL_IMMORTAL )
save.c:                           ch->pcdata->learned[sn] = 0;
save.c:                           ++ch->practice;
save.c:               LINK( paf, ch->first_affect, ch->last_affect, next, prev );
save.c:                  ch->pcdata->age_bonus = x1;
save.c:                  ch->pcdata->day = x2;
save.c:                  ch->pcdata->month = x3;
save.c:                  ch->pcdata->year = x4;
save.c:               ch->mod_str = x1;
save.c:               ch->mod_int = x2;
save.c:               ch->mod_wis = x3;
save.c:               ch->mod_dex = x4;
save.c:               ch->mod_con = x5;
save.c:               ch->mod_cha = x6;
save.c:               ch->mod_lck = x7;
save.c:                  ch->mod_lck = 0;
save.c:               ch->perm_str = x1;
save.c:               ch->perm_int = x2;
save.c:               ch->perm_wis = x3;
save.c:               ch->perm_dex = x4;
save.c:               ch->perm_con = x5;
save.c:               ch->perm_cha = x6;
save.c:               ch->perm_lck = x7;
save.c:                  ch->perm_lck = 13;
save.c:            KEY( "Ap", ch->pcdata->ap, fread_number( fp ) );
save.c:            KEY( "AuthedBy", ch->pcdata->authed_by, fread_string( fp ) );
save.c:            KEY( "Balance", ch->pcdata->balance, fread_number( fp ) );
save.c:            KEY( "Bamfin", ch->pcdata->bamfin, fread_string_nohash( fp ) );
save.c:            KEY( "Bamfout", ch->pcdata->bamfout, fread_string_nohash( fp ) );
save.c:            KEY( "Bestowments", ch->pcdata->bestowments, fread_string_nohash( fp ) );
save.c:            KEY( "Bio", ch->pcdata->bio, fread_string( fp ) );
save.c:               ch->pcdata->clan_name = fread_string( fp );
save.c:                   && ch->pcdata->clan_name[0] != '\0' && ( ch->pcdata->clan = get_clan( ch->pcdata->clan_name ) ) == NULL )
save.c:                     ch->pcdata->clan_name );
save.c:                  add_loginmsg( ch->name, 18, buf );
save.c:                  STRFREE( ch->pcdata->clan_name );
save.c:                  ch->pcdata->clan_name = STRALLOC( "" );
save.c:            KEY( "Class", ch->Class, fread_number( fp ) );
save.c:            KEY( "Customclass", ch->pcdata->customclass, fread_string( fp ) );
save.c:                  ch->colors[x] = fread_number( fp );
save.c:               ch->pcdata->condition[0] = x1;
save.c:               ch->pcdata->condition[1] = x2;
save.c:               ch->pcdata->condition[2] = x3;
save.c:               ch->pcdata->condition[3] = x4;
save.c:               ch->pcdata->council_name = fread_string( fp );
save.c:                   && ch->pcdata->council_name[0] != '\0'
save.c:                   && ( ch->pcdata->council = get_council( ch->pcdata->council_name ) ) == NULL )
save.c:                     ch->pcdata->council_name );
save.c:                  add_loginmsg( ch->name, 18, buf );
save.c:                  STRFREE( ch->pcdata->council_name );
save.c:                  ch->pcdata->council_name = STRALLOC( "" );
save.c:               ch->pcdata->cpose = fread_string( fp );
save.c:               if( isalpha( ch->pcdata->cpose[0] ) || isdigit( ch->pcdata->cpose[0] ) )
save.c:                  snprintf( buf, MAX_STRING_LENGTH, " %s", ch->pcdata->cpose );
save.c:                  if( ch->pcdata->cpose )
save.c:                     STRFREE( ch->pcdata->cpose );
save.c:                  ch->pcdata->cpose = STRALLOC( buf );
save.c:                     KEY( "Dex", ch->pcdata->dex, fread_number( fp ) );
save.c:                     KEY( "Def", ch->pcdata->def, fread_number( fp ) );
save.c:                     KEY( "Dexplus", ch->pcdata->dexplus, fread_number( fp ) );
save.c:                     KEY( "Defplus", ch->pcdata->defplus, fread_number( fp ) );
save.c:                     KEY( "Deflevel", ch->pcdata->deflevel, fread_number( fp ) );
save.c:            KEY( "Damroll", ch->damroll, fread_number( fp ) );
save.c:            KEY( "Deaf", ch->deaf, fread_number( fp ) );
save.c:               ch->pcdata->deity_name = fread_string( fp );
save.c:                   && ch->pcdata->deity_name[0] != '\0'
save.c:                   && ( ch->pcdata->deity = get_deity( ch->pcdata->deity_name ) ) == NULL )
save.c:                  snprintf( buf, MAX_STRING_LENGTH, "&R\r\nYour deity, %s, has met its demise!\r\n", ch->pcdata->deity_name );
save.c:                  add_loginmsg( ch->name, 18, buf );
save.c:                  STRFREE( ch->pcdata->deity_name );
save.c:                  ch->pcdata->deity_name = STRALLOC( "" );
save.c:                  ch->pcdata->favor = 0;
save.c:            KEY( "Description", ch->description, fread_string( fp ) );
save.c:            KEY( "Favor", ch->pcdata->favor, fread_number( fp ) );
save.c:            KEY( "Flags", ch->pcdata->flags, fread_number( fp ) );
save.c:            KEY( "FPrompt", ch->pcdata->fprompt, fread_string( fp ) );
save.c:            KEY( "Glory", ch->pcdata->quest_curr, fread_number( fp ) );
save.c:            KEY( "Gold", ch->gold, fread_number( fp ) );
save.c:               ch->pcdata->clan_name = fread_string( fp );
save.c:                   && ch->pcdata->clan_name[0] != '\0' && ( ch->pcdata->clan = get_clan( ch->pcdata->clan_name ) ) == NULL )
save.c:                     ch->pcdata->clan_name );
save.c:                  add_loginmsg( ch->name, 18, buf );
save.c:                  STRFREE( ch->pcdata->clan_name );
save.c:                  ch->pcdata->clan_name = STRALLOC( "" );
save.c:            KEY( "Height", ch->height, fread_number( fp ) );
save.c:               ch->pcdata->release_date = fread_number( fp );
save.c:               ch->pcdata->helled_by = fread_string( fp );
save.c:            KEY( "Hitroll", ch->hitroll, fread_number( fp ) );
save.c:            KEY( "Homepage", ch->pcdata->homepage, fread_string_nohash( fp ) );
save.c:               if( ch->in_room && xIS_SET( ch->in_room->room_flags, ROOM_HOUSE ) )
save.c:                        if( tmphome->vnum[i] == ch->in_room->vnum )
save.c:                              ch->in_room = get_room_index( ROOM_VNUM_TEMPLE );
save.c:               ch->pcdata->hometown = fread_string( fp );
save.c:               if( isalpha( ch->pcdata->hometown[0] ) || isdigit( ch->pcdata->hometown[0] ) )
save.c:                  snprintf( buf, MAX_STRING_LENGTH, " %s", ch->pcdata->hometown );
save.c:                  if( ch->pcdata->hometown )
save.c:                     STRFREE( ch->pcdata->hometown );
save.c:                  ch->pcdata->hometown = STRALLOC( buf );
save.c:               ch->hit = fread_number( fp );
save.c:               ch->max_hit = fread_number( fp );
save.c:               ch->mana = fread_number( fp );
save.c:               ch->max_mana = fread_number( fp );
save.c:               ch->move = fread_number( fp );
save.c:               ch->max_move = fread_number( fp );
save.c:               for( ign = 0, inode = ch->pcdata->first_ignored; inode; inode = inode->next )
save.c:                  LINK( inode, ch->pcdata->first_ignored, ch->pcdata->last_ignored, next, prev );
save.c:            KEY( "IllegalPK", ch->pcdata->illegal_pk, fread_number( fp ) );
save.c:            KEY( "Immune", ch->immune, fread_number( fp ) );
save.c:                   KEY( "Intel", ch->pcdata->intel, fread_number( fp ) );
save.c:                   KEY( "Intplus", ch->pcdata->intplus, fread_number( fp ) );
save.c:                  ch->pcdata->killed[killcnt].vnum = fread_number( fp );
save.c:                  ch->pcdata->killed[killcnt++].count = fread_number( fp );
save.c:                     KEY( "Lck", ch->pcdata->lck, fread_number( fp ) );
save.c:                     KEY( "Lckplus", ch->pcdata->lckplus, fread_number( fp ) );
save.c:            KEY( "Level", ch->level, fread_number( fp ) );
save.c:            KEY( "LongDescr", ch->long_descr, fread_string( fp ) );
save.c:               ch->speaks = fread_number( fp );
save.c:               ch->speaking = fread_number( fp );
save.c:                   KEY( "Matt", ch->pcdata->matt, fread_number( fp ) );
save.c:                   KEY( "Mdef", ch->pcdata->mdef, fread_number( fp ) );
save.c:                   KEY( "Mattplus", ch->pcdata->mattplus, fread_number( fp ) );
save.c:                   KEY( "Mdefplus", ch->pcdata->mdefplus, fread_number( fp ) );
save.c:                   KEY( "Mlevel", ch->pcdata->mlevel, fread_number( fp ) );
save.c:            KEY( "MDeaths", ch->pcdata->mdeaths, fread_number( fp ) );
save.c:            KEY( "Mentalstate", ch->mental_state, fread_number( fp ) );
save.c:            KEY( "MGlory", ch->pcdata->quest_accum, fread_number( fp ) );
save.c:            KEY( "Minsnoop", ch->pcdata->min_snoop, fread_number( fp ) );
save.c:            KEY( "MKills", ch->pcdata->mkills, fread_number( fp ) );
save.c:            KEY( "Mobinvis", ch->mobinvis, fread_number( fp ) );
save.c:               ch->pcdata->m_range_lo = fread_number( fp );
save.c:               ch->pcdata->m_range_hi = fread_number( fp );
save.c:            KEY( "Name", ch->name, fread_string( fp ) );
save.c:            KEY( "NoAffectedBy", ch->no_affected_by, fread_bitvector( fp ) );
save.c:            KEY( "NoImmune", ch->no_immune, fread_number( fp ) );
save.c:            KEY( "NoResistant", ch->no_resistant, fread_number( fp ) );
save.c:            KEY( "NoSusceptible", ch->no_susceptible, fread_number( fp ) );
save.c:               CREATE( ch->pcdata->nuisance, NUISANCE_DATA, 1 );
save.c:               ch->pcdata->nuisance->set_time = fread_number( fp );
save.c:               ch->pcdata->nuisance->max_time = fread_number( fp );
save.c:               ch->pcdata->nuisance->flags = fread_number( fp );
save.c:               ch->pcdata->nuisance->power = 1;
save.c:               CREATE( ch->pcdata->nuisance, NUISANCE_DATA, 1 );
save.c:               ch->pcdata->nuisance->set_time = fread_number( fp );
save.c:               ch->pcdata->nuisance->max_time = fread_number( fp );
save.c:               ch->pcdata->nuisance->flags = fread_number( fp );
save.c:               ch->pcdata->nuisance->power = fread_number( fp );
save.c:            KEY( "Outcast_time", ch->pcdata->outcast_time, fread_number( fp ) );
save.c:               ch->pcdata->o_range_lo = fread_number( fp );
save.c:               ch->pcdata->o_range_hi = fread_number( fp );
save.c:            KEY( "Pagerlen", ch->pcdata->pagerlen, fread_number( fp ) );
save.c:            KEY( "Password", ch->pcdata->pwd, fread_string_nohash( fp ) );
save.c:            KEY( "PDeaths", ch->pcdata->pdeaths, fread_number( fp ) );
save.c:            KEY( "PKills", ch->pcdata->pkills, fread_number( fp ) );
save.c:            KEY( "Played", ch->played, fread_number( fp ) );
save.c:               ch->position = fread_number( fp );
save.c:               if( ch->position < 100 )
save.c:                  switch ( ch->position )
save.c:                        ch->position = 6;
save.c:                        ch->position = 8;
save.c:                        ch->position = 9;
save.c:                        ch->position = 12;
save.c:                        ch->position = 13;
save.c:                        ch->position = 14;
save.c:                        ch->position = 15;
save.c:                  ch->position -= 100;
save.c:            KEY( "Practice", ch->practice, fread_number( fp ) );
save.c:            KEY( "Prompt", ch->pcdata->prompt, fread_string( fp ) );
save.c:            KEY( "Race", ch->race, fread_number( fp ) );
save.c:            KEY( "Rank", ch->pcdata->rank, fread_string_nohash( fp ) );
save.c:            KEY( "Resistant", ch->resistant, fread_number( fp ) );
save.c:            KEY( "Restore_time", ch->pcdata->restore_time, fread_number( fp ) );
save.c:               ch->in_room = get_room_index( fread_number( fp ) );
save.c:               if( !ch->in_room )
save.c:                  ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
save.c:               ch->pcdata->r_range_lo = fread_number( fp );
save.c:               ch->pcdata->r_range_hi = fread_number( fp );
save.c:                   KEY( "Str", ch->pcdata->str, fread_number( fp ) );
save.c:                   KEY( "Strplus", ch->pcdata->strplus, fread_number( fp ) );
save.c:            KEY( "Sex", ch->sex, fread_number( fp ) );
save.c:            KEY( "ShortDescr", ch->short_descr, fread_string( fp ) );
save.c:            KEY( "Style", ch->style, fread_number( fp ) );
save.c:            KEY( "Susceptible", ch->susceptible, fread_number( fp ) );
save.c:               ch->saving_wand = fread_number( fp );
save.c:               ch->saving_poison_death = ch->saving_wand;
save.c:               ch->saving_para_petri = ch->saving_wand;
save.c:               ch->saving_breath = ch->saving_wand;
save.c:               ch->saving_spell_staff = ch->saving_wand;
save.c:               ch->saving_poison_death = fread_number( fp );
save.c:               ch->saving_wand = fread_number( fp );
save.c:               ch->saving_para_petri = fread_number( fp );
save.c:               ch->saving_breath = fread_number( fp );
save.c:               ch->saving_spell_staff = fread_number( fp );
save.c:                  ch->pcdata->prev_site = STRALLOC( fread_word( fp ) );
save.c:                  ch_printf( ch, "Last connected from: %s\r\n", ch->pcdata->prev_site );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                     if( ch->level < LEVEL_IMMORTAL )
save.c:                        if( skill_table[sn]->skill_level[ch->Class] >= LEVEL_IMMORTAL )
save.c:                           ch->pcdata->learned[sn] = 0;
save.c:                           ++ch->practice;
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                     if( ch->level < LEVEL_IMMORTAL )
save.c:                        if( skill_table[sn]->skill_level[ch->Class] >= LEVEL_IMMORTAL )
save.c:                           ch->pcdata->learned[sn] = 0;
save.c:                           ++ch->practice;
save.c:               if( !ch->short_descr )
save.c:                  ch->short_descr = STRALLOC( "" );
save.c:               if( !ch->long_descr )
save.c:                  ch->long_descr = STRALLOC( "" );
save.c:               if( !ch->description )
save.c:                  ch->description = STRALLOC( "" );
save.c:               if( !ch->pcdata->pwd )
save.c:                  ch->pcdata->pwd = str_dup( "" );
save.c:               if( !ch->pcdata->bamfin )
save.c:                  ch->pcdata->bamfin = str_dup( "" );
save.c:               if( !ch->pcdata->bamfout )
save.c:                  ch->pcdata->bamfout = str_dup( "" );
save.c:               if( !ch->pcdata->bio )
save.c:                  ch->pcdata->bio = STRALLOC( "" );
save.c:               if( !ch->pcdata->rank )
save.c:                  ch->pcdata->rank = str_dup( "" );
save.c:               if( !ch->pcdata->bestowments )
save.c:                  ch->pcdata->bestowments = str_dup( "" );
save.c:               if( !ch->pcdata->title )
save.c:                  ch->pcdata->title = STRALLOC( "" );
save.c:               if( !ch->pcdata->customclass )
save.c:                  ch->pcdata->customclass = STRALLOC( "" );
save.c:               if( !ch->pcdata->cpose )
save.c:                  ch->pcdata->cpose = STRALLOC( "" );
save.c:               if( !ch->pcdata->hometown )
save.c:                  ch->pcdata->hometown = STRALLOC( "" );
save.c:               if( !ch->pcdata->homepage )
save.c:                  ch->pcdata->homepage = str_dup( "" );
save.c:               if( !ch->pcdata->authed_by )
save.c:                  ch->pcdata->authed_by = STRALLOC( "" );
save.c:               if( !ch->pcdata->prompt )
save.c:                  ch->pcdata->prompt = STRALLOC( "" );
save.c:               if( !ch->pcdata->fprompt )
save.c:                  ch->pcdata->fprompt = STRALLOC( "" );
save.c:               ch->editor = NULL;
save.c:               killcnt = URANGE( 2, ( ( ch->level + 3 ) * MAX_KILLTRACK ) / LEVEL_AVATAR, MAX_KILLTRACK );
save.c:                  ch->pcdata->killed[killcnt].vnum = 0;
save.c:               if( !IS_IMMORTAL( ch ) && !ch->speaking )
save.c:                  ch->speaking = LANG_COMMON;
save.c:                * ch->speaking = race_table[ch->race]->language; 
save.c:                  ch->speaks = ~0;
save.c:                  if( ch->speaking == 0 )
save.c:                     ch->speaking = ~0;
save.c:                  CREATE( ch->pcdata->tell_history, const char *, 26 );
save.c:                     ch->pcdata->tell_history[i] = NULL;
save.c:               if( !ch->pcdata->prompt )
save.c:                  ch->pcdata->prompt = STRALLOC( "" );
save.c:               if( ch->height == 72 )
save.c:                  ch->height =
save.c:                     number_range( ( int )( race_table[ch->race]->height * .9 ),
save.c:                                   ( int )( race_table[ch->race]->height * 1.1 ) );
save.c:               if( ch->weight == 180 )
save.c:                  ch->weight =
save.c:                     number_range( ( int )( race_table[ch->race]->weight * .9 ),
save.c:                                   ( int )( race_table[ch->race]->weight * 1.1 ) );
save.c:               if( ch->pcdata->clan )
save.c:            KEY( "Exp", ch->exp, fread_number( fp ) );
save.c:                     KEY( "Tier", ch->pcdata->tier, fread_number( fp ) );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                     if( ch->level < LEVEL_IMMORTAL )
save.c:                        if( skill_table[sn]->skill_level[ch->Class] >= LEVEL_IMMORTAL )
save.c:                           ch->pcdata->learned[sn] = 0;
save.c:                           ch->practice++;
save.c:            KEY( "Trust", ch->trust, fread_number( fp ) );
save.c:            KEY( "Timezone", ch->pcdata->timezone, fread_number( fp )); 
save.c:            ch->trust = UMIN( ch->trust, MAX_LEVEL - 1 );
save.c:               ch->pcdata->title = fread_string( fp );
save.c:               if( isalpha( ch->pcdata->title[0] ) || isdigit( ch->pcdata->title[0] ) )
save.c:                  snprintf( buf, MAX_STRING_LENGTH, " %s", ch->pcdata->title );
save.c:                  if( ch->pcdata->title )
save.c:                     STRFREE( ch->pcdata->title );
save.c:                  ch->pcdata->title = STRALLOC( buf );
save.c:            KEY( "Weight", ch->weight, fread_number( fp ) );
save.c:                     ch->pcdata->learned[sn] = value;
save.c:                     if( ch->level < LEVEL_IMMORTAL )
save.c:                        if( skill_table[sn]->skill_level[ch->Class] >= LEVEL_IMMORTAL )
save.c:                           ch->pcdata->learned[sn] = 0;
save.c:                           ++ch->practice;
save.c:            KEY( "Wimpy", ch->wimpy, fread_number( fp ) );
save.c:            KEY( "WizInvis", ch->pcdata->wizinvis, fread_number( fp ) );
save.c:      room = ch->in_room;
save.c:      if( ch->tempnum == -9999 )
save.c:                     obj->owner = QUICKLINK( ch->name );
save.c:      name = ch->name;
save.c:   if( IS_NPC( ch ) || !ch->pcdata->pet )
save.c:   mob = ch->pcdata->pet;
shops.c:   for( keeper = ch->in_room->first_person; keeper; keeper = keeper->next_in_room )
shops.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_KILLER ) )
shops.c:      snprintf( buf, MAX_STRING_LENGTH, "%s the KILLER is over here!\r\n", ch->name );
shops.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_THIEF ) )
shops.c:      snprintf( buf, MAX_STRING_LENGTH, "%s the THIEF is over here!\r\n", ch->name );
shops.c:   speakswell = UMIN( knows_language( keeper, ch->speaking, ch ), knows_language( ch, ch->speaking, keeper ) );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s Could you repeat that?  I didn't quite catch it.", ch->name );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s Could you say that a little more clearly please?", ch->name );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s Sorry... What was that you wanted?", ch->name );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s I can't understand you.", ch->name );
shops.c:   for( keeper = ch->in_room->first_person; keeper; keeper = keeper->next_in_room )
shops.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_KILLER ) )
shops.c:      snprintf( buf, MAX_STRING_LENGTH, "%s the KILLER is over here!\r\n", ch->name );
shops.c:   if( !IS_NPC( ch ) && xIS_SET( ch->act, PLR_THIEF ) )
shops.c:      snprintf( buf, MAX_STRING_LENGTH, "%s the THIEF is over here!\r\n", ch->name );
shops.c:   speakswell = UMIN( knows_language( keeper, ch->speaking, ch ), knows_language( ch, ch->speaking, keeper ) );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s Could you repeat that?  I didn't quite catch it.", ch->name );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s Could you say that a little more clearly please?", ch->name );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s Sorry... What was that you wanted?", ch->name );
shops.c:         snprintf( buf, MAX_STRING_LENGTH, "%s I can't understand you.", ch->name );
shops.c:   if( ch->gold > ( ch->level * ch->level * 100000 ) )
shops.c:         + ( ( URANGE( 5, ch->level, LEVEL_AVATAR ) - 20 ) / 2 );
shops.c:      cost = ( int )( cost * ( 80 + UMIN( ch->level, LEVEL_AVATAR ) ) ) / 100;
shops.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_PET_SHOP ) )
shops.c:      pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
shops.c:         bug( "%s: bad pet shop at vnum %d.", __func__, ch->in_room->vnum );
shops.c:      in_room = ch->in_room;
shops.c:      ch->in_room = pRoomIndexNext;
shops.c:      ch->in_room = in_room;
shops.c:      if( xIS_SET( ch->act, PLR_BOUGHT_PET ) )
shops.c:      if( ch->gold < 10 * pet->level * pet->level )
shops.c:      if( ch->level < pet->level )
shops.c:      ch->gold -= maxgold;
shops.c:      boost_economy( ch->in_room->area, maxgold );
shops.c:      xSET_BIT( ch->act, PLR_BOUGHT_PET );
shops.c:      snprintf( buf, MAX_STRING_LENGTH, "%sA neck tag says 'I belong to %s'.\r\n", pet->description, ch->name );
shops.c:      char_to_room( pet, ch->in_room );
shops.c:            ch->reply = keeper;
shops.c:         ch->reply = keeper;
shops.c:         ch->reply = keeper;
shops.c:      if( ch->gold < cost )
shops.c:         ch->reply = keeper;
shops.c:      if( obj->level > ch->level )
shops.c:         ch->reply = keeper;
shops.c:         ch->reply = keeper;
shops.c:      if( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
shops.c:      if( ch->carry_weight + ( get_obj_weight( obj ) * noi ) + ( noi > 1 ? 2 : 0 ) > can_carry_w( ch ) )
shops.c:      ch->gold -= cost;
shops.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_PET_SHOP ) )
shops.c:      pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
shops.c:         bug( "Do_list: bad pet shop at vnum %d.", ch->in_room->vnum );
shops.c:      ch->reply = keeper;
shops.c:   ch->gold += cost;
shops.c:      ch->reply = keeper;
shops.c:   ch->reply = keeper;
shops.c:   else if( ( cost = strcmp( "all", arg ) ? cost : 11 * cost / 10 ) > ch->gold )
shops.c:      ch->gold -= cost;
shops.c:      for( obj = ch->first_carrying; obj; obj = obj->next_content )
shops.c:      ch->reply = keeper;
shops.c:   for( obj = ch->first_carrying; obj != NULL; obj = obj->next_content )
shops.c:      ch->reply = keeper;
shops.c:   if( cost > ch->gold )
skills.c:   if( ch->pcdata->clan && ch->pcdata->clan == vch->pcdata->clan )
skills.c:                                  100 / ( 2 + ch->level - skill_table[sn]->race_level[ch->race] ) );
skills.c:         if( ch->pcdata->condition[COND_BLOODTHIRST] < blood )
skills.c:      else if( !IS_NPC( ch ) && ch->mana < mana )
skills.c:                  if( xIS_SET( ch->act, PLR_NICE ) )
skills.c:               if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
skills.c:               ch->mana -= mana / 2;
skills.c:            ch->mana -= mana;
skills.c:      retcode = ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, vo );
skills.c:         for( vch = ch->in_room->first_person; vch; vch = vch_next )
skills.c:            vch_next = vch->next_in_room;
skills.c:         ch->mana -= mana;
skills.c:   ch->prev_cmd = ch->last_cmd;  /* haus, for automapping */
skills.c:   ch->last_cmd = skill_table[sn]->skill_fun;
skills.c:                                      100 / ( 2 + ch->level - skill_table[sn]->skill_level[ch->Class] ) );
skills.c:         if( ch->pcdata->condition[COND_BLOODTHIRST] < blood )
skills.c:      else if( !IS_NPC( ch ) && ch->mana < mana )
skills.c:               if( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
skills.c:               ch->mana -= mana / 2;
skills.c:            ch->mana -= mana;
skills.c:      retcode = ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, vo );
skills.c:         for( vch = ch->in_room->first_person; vch; vch = vch_next )
skills.c:            vch_next = vch->next_in_room;
skills.c:         ch->mana -= mana;
skills.c:   ch->prev_cmd = ch->last_cmd;  /* haus, for automapping */
skills.c:   ch->last_cmd = skill_table[sn]->skill_fun;
skills.c:   if( IS_NPC( ch ) || ch->pcdata->learned[sn] <= 0 )
skills.c:   adept = skill_table[sn]->race_adept[ch->race];
skills.c:   sklvl = skill_table[sn]->race_level[ch->race];
skills.c:      sklvl = ch->level;
skills.c:   if( ch->pcdata->learned[sn] < adept )
skills.c:      schance = ch->pcdata->learned[sn] + ( 5 * skill_table[sn]->difficulty );
skills.c:      ch->pcdata->learned[sn] = UMIN( adept, ch->pcdata->learned[sn] + learn );
skills.c:      if( ch->pcdata->learned[sn] == adept ) /* fully learned! */
skills.c:         if( !ch->fighting && sn != gsn_hide && sn != gsn_sneak )
skills.c:   if( IS_NPC( ch ) || ch->pcdata->learned[sn] <= 0 )
skills.c:   sklvl = skill_table[sn]->skill_level[ch->Class];
skills.c:      sklvl = ch->level;
skills.c:   if( ch->pcdata->learned[sn] < adept )
skills.c:      schance = ch->pcdata->learned[sn] + ( 5 * skill_table[sn]->difficulty );
skills.c:      ch->pcdata->learned[sn] = UMIN( adept, ch->pcdata->learned[sn] + learn );
skills.c:      if( ch->pcdata->learned[sn] == adept ) /* fully learned! */
skills.c:         if( ch->Class == CLASS_MAGE )
skills.c:         if( ch->Class == CLASS_CLERIC )
skills.c:         if( ch->Class == CLASS_MAGE )
skills.c:         if( ch->Class == CLASS_CLERIC )
skills.c:         if( !ch->fighting && sn != gsn_hide && sn != gsn_sneak )
skills.c:   if( IS_NPC( ch ) || ch->pcdata->learned[sn] <= 0 )
skills.c:   schance = ch->pcdata->learned[sn] + ( 5 * skill_table[sn]->difficulty );
skills.c:   if( ch->pcdata->learned[sn] < ( adept - 1 ) )
skills.c:      ch->pcdata->learned[sn] = UMIN( adept, ch->pcdata->learned[sn] + 1 );
skills.c:   if( ch->mount )
skills.c:   if( !ch->fighting && victim->in_room == ch->in_room )
skills.c:   if( !victim->fighting && ch->in_room == victim->in_room )
skills.c:   if( ch->mount )
skills.c:      dam = number_range( 5, ch->level );
skills.c:               af.duration = ( ch->level + 10 ) / get_curr_con( victim );
skills.c:               af.duration = 3 + ( ch->level / 15 );
skills.c:   switch ( ch->substate )
skills.c:         if( ch->mount )
skills.c:         if( !ch->in_room->first_content )
skills.c:         for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
skills.c:         ch->alloc_ptr = str_dup( obj->name );
skills.c:         if( !ch->alloc_ptr )
skills.c:            bug( "%s", "do_detrap: ch->alloc_ptr NULL!" );
skills.c:         mudstrlcpy( arg, ch->alloc_ptr, MAX_INPUT_LENGTH );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->alloc_ptr = NULL;
skills.c:         ch->substate = SUB_NONE;
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->substate = SUB_NONE;
skills.c:   if( !ch->in_room->first_content )
skills.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
skills.c:   percent = number_percent(  ) - ( ch->level / 15 ) - ( get_curr_lck( ch ) - 16 );
skills.c:   switch ( ch->substate )
skills.c:         if( ch->mount )
skills.c:            switch ( ch->in_room->sector_type )
skills.c:         ch->alloc_ptr = str_dup( arg );
skills.c:         if( !ch->alloc_ptr )
skills.c:         mudstrlcpy( arg, ch->alloc_ptr, MAX_INPUT_LENGTH );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->substate = SUB_NONE;
skills.c:   ch->substate = SUB_NONE;
skills.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
skills.c:   startobj = ch->in_room->first_content;
skills.c:	    (IS_NPC(ch) ? 80 : ch->pcdata->learned[gsn_dig]) )
skills.c:   switch ( ch->substate )
skills.c:         if( ch->mount )
skills.c:         ch->alloc_ptr = str_dup( arg );
skills.c:         if( !ch->alloc_ptr )
skills.c:         mudstrlcpy( arg, ch->alloc_ptr, MAX_INPUT_LENGTH );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->substate = SUB_NONE;
skills.c:   ch->substate = SUB_NONE;
skills.c:      startobj = ch->in_room->first_content;
skills.c:   percent = number_percent(  ) + number_percent(  ) - ( ch->level / 10 );
skills.c:      if( ( pexit = get_exit( ch->in_room, door ) ) != NULL
skills.c:   if( ch->mount )
skills.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:   if( ch->level + 10 < victim->level )
skills.c:      snprintf( buf, MAX_STRING_LENGTH, "%s is a bloody thief!", ch->name );
skills.c:               if( ( mst = ch->master ) == NULL )
skills.c:      ch->gold += amount;
skills.c:       || IS_OBJ_STAT( obj, ITEM_INVENTORY ) || IS_OBJ_STAT( obj, ITEM_PROTOTYPE ) || obj->level > ch->level )
skills.c:   if( ch->carry_number + ( get_obj_number( obj ) / obj->count ) > can_carry_n( ch ) )
skills.c:   if( ch->carry_weight + ( get_obj_weight( obj ) / obj->count ) > can_carry_w( ch ) )
skills.c:   if( ch->mount )
skills.c:   if( ch->mount )
skills.c:   if( !IS_NPC( ch ) && !IS_NPC( victim ) && xIS_SET( ch->act, PLR_NICE ) )
skills.c:   if( ch->mount )
skills.c:   if( !ch->fighting )
skills.c:   if( ch->fighting )
skills.c:   int managain = ( ch->Class == CLASS_DRUID ? 0 : 22 );
skills.c:   switch ( ch->substate )
skills.c:         ch->alloc_ptr = str_dup( argument );
skills.c:         if( !ch->alloc_ptr )
skills.c:         arg = str_dup( ch->alloc_ptr );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->substate = SUB_NONE;
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:   switch ( ch->in_room->sector_type )
skills.c:         if( ch->Class == CLASS_DRUID )
skills.c:         if( ch->race == RACE_SEA_ELF )
skills.c:         if( ch->race == RACE_PIXIE )
skills.c:      ch->mana = UMIN( ch->max_mana, ch->mana + managain );
skills.c:   if( ch->mana < ch->max_mana )
skills.c:      ch->alloc_ptr = str_dup( arg );
skills.c:      ch->substate = SUB_NONE;
skills.c:   int managain = ( ch->Class == CLASS_DRUID ? 0 : 50 );
skills.c:   switch ( ch->substate )
skills.c:         ch->alloc_ptr = str_dup( argument );
skills.c:         if( !ch->alloc_ptr )
skills.c:         arg = str_dup( ch->alloc_ptr );
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:         ch->substate = SUB_NONE;
skills.c:         DISPOSE( ch->alloc_ptr );
skills.c:   switch ( ch->in_room->sector_type )
skills.c:         if( ch->Class == CLASS_DRUID )
skills.c:         if( ch->race == RACE_SEA_ELF )
skills.c:         if( ch->race == RACE_PIXIE )
skills.c:      ch->mana = UMIN( ch->max_mana, ch->mana + managain );
skills.c:   if( ch->mana < ch->max_mana )
skills.c:      ch->alloc_ptr = str_dup( arg );
skills.c:      ch->substate = SUB_NONE;
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_kick]->skill_level[ch->Class] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_kick );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_punch]->skill_level[ch->Class] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_punch );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_bite]->skill_level[ch->Class] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_bite );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_claw]->skill_level[ch->Class] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_claw );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_sting]->skill_level[ch->Class] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_sting );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_tail]->skill_level[ch->Class] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_tail );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_bash]->skill_level[ch->Class] )
skills.c:      global_retcode = damage( ch, victim, number_range( 1, ch->level ), gsn_bash );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_stun]->skill_level[ch->Class] )
skills.c:   if( !IS_NPC( ch ) && ch->move < ch->max_move / 10 )
skills.c:   schance = ris_save( victim, ch->level, RIS_PARALYSIS );
skills.c:         ch->move -= ch->max_move / 10;
skills.c:         ch->move -= ch->max_move / 15;
skills.c:   if( ch->fighting )
skills.c:   if( ch->pcdata->condition[COND_BLOODTHIRST] < 10 )
skills.c:      obj_to_room( obj, ch->in_room );
skills.c:      damage( ch, ch, ch->level / 5, gsn_bloodlet );
skills.c:   if( ch->mount )
skills.c:      dam = number_range( 1, ch->level );
skills.c:          && ch->fighting && ch->pcdata->condition[COND_BLOODTHIRST] < ( 10 + ch->level ) )
skills.c:                         UMIN( number_range( 1, ( ch->level + victim->level / 20 ) + 3 ),
skills.c:                               ( 10 + ch->level ) - ch->pcdata->condition[COND_BLOODTHIRST] ) );
skills.c:         if( ch->pcdata->condition[COND_FULL] <= 37 )
skills.c:         temphit = ch->hit;
skills.c:         ch->hit += 1 + ch->level / 5;
skills.c:         if( ch->hit > ch->max_hit )
skills.c:            ch->hit = ch->max_hit;
skills.c:         if( ch->hit < temphit )
skills.c:            ch->hit = temphit;
skills.c:          && ch->fighting && ch->pcdata->condition[COND_BLOODTHIRST] < ( 10 + ch->level ) )
skills.c:      snprintf( buf, MAX_STRING_LENGTH, "%s %s", ch->name, victim->name );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_disarm]->skill_level[ch->Class] )
skills.c:   percent = number_percent(  ) + victim->level - ch->level - ( get_curr_lck( ch ) - 15 ) + ( get_curr_lck( victim ) - 15 );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_cleave]->skill_level[ch->Class] )
skills.c:   if( ch->mount )
skills.c:   if( IS_PKILL( ch ) && ch->pcdata->condition[COND_BLOODTHIRST] > 22 )
skills.c:       || xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
skills.c:       || victim->level >= ch->level + 15
skills.c:       || ( IS_NPC( victim ) && saves_spell_staff( ch->level, victim ) )
skills.c:   if( ch->mount )
skills.c:      if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
skills.c:   if( ch->mount )
skills.c:   for( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
skills.c:      if( IS_NPC( gch ) && IS_AWAKE( gch ) && ch->level + 5 < gch->level )
skills.c:/*        for ( gch = ch->in_room->first_person; gch; gch = gch->next_in_room )
skills.c:          if ( IS_NPC(gch) && IS_AWAKE(gch) && xIS_SET(gch->act, ACT_GUARDIAN ) )
skills.c:      if( ( pexit_rev = pexit->rexit ) != NULL && pexit_rev->to_room == ch->in_room )
skills.c:   if( ch->mount )
skills.c:      af.duration = ( int )( ch->level * DUR_CONV );
skills.c:   if( ch->mount )
skills.c:      xREMOVE_BIT( ch->affected_by, AFF_HIDE );
skills.c:      xSET_BIT( ch->affected_by, AFF_HIDE );
skills.c:   xREMOVE_BIT( ch->affected_by, AFF_HIDE );
skills.c:   xREMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
skills.c:   xREMOVE_BIT( ch->affected_by, AFF_SNEAK );
skills.c:   if( !IS_NPC( ch ) && ch->pcdata->clan )
skills.c:      location = get_room_index( ch->pcdata->clan->recall );
skills.c:   if( !IS_NPC( ch ) && !location && ch->level >= 5 && IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
skills.c:      location = get_room_index( race_table[ch->race]->race_recall );
skills.c:   if( ch->in_room == location )
skills.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_NO_RECALL ) )
skills.c:         lose = ( int )( ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.1 );
skills.c:         if( ch->desc )
skills.c:      lose = ( int )( ( exp_level( ch, ch->level + 1 ) - exp_level( ch, ch->level ) ) * 0.2 );
skills.c:      if( ch->desc )
skills.c:   if( ch->mount )
skills.c:      char_from_room( ch->mount );
skills.c:      char_to_room( ch->mount, location );
skills.c:   if( ch->mount )
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_mount]->skill_level[ch->Class] )
skills.c:   if( ch->mount )
skills.c:      ch->mount = victim;
skills.c:      ch->position = POS_MOUNTED;
skills.c:   if( ( victim = ch->mount ) == NULL )
skills.c:      ch->mount = NULL;
skills.c:      ch->position = POS_STANDING;
skills.c:      ch->mount = NULL;
skills.c:      ch->position = POS_SITTING;
skills.c:   if( !chance( victim, chances + victim->level - ch->level ) )
skills.c:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) )   /* SB */
skills.c:   if( !chance( victim, chances + victim->level - ch->level ) )
skills.c:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) )
skills.c:   if( !chance( victim, chances + victim->level - ch->level ) )
skills.c:   if( !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_GAG ) )
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_poison_weapon]->skill_level[ch->Class] )
skills.c:   if( ch->fighting )
skills.c:   for( pobj = ch->first_carrying; pobj; pobj = pobj->next_content )
skills.c:   for( wobj = ch->first_carrying; wobj; wobj = wobj->next_content )
skills.c:   if( !IS_NPC( ch ) && ( ( get_curr_dex( ch ) < 17 ) || ch->pcdata->condition[COND_DRUNK] > 0 ) )
skills.c:      damage( ch, ch, ch->level, gsn_poison_weapon );
skills.c:   obj->timer = UMIN( obj->level, ch->level );
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_scribe]->skill_level[ch->Class] )
skills.c:                                   100 / ( 2 + ch->level - skill_table[sn]->skill_level[ch->Class] ) );
skills.c:   if( !IS_NPC( ch ) && ch->mana < mana )
skills.c:      ch->mana -= ( mana / 2 );
skills.c:      ch->mana -= ( mana / 2 );
skills.c:   scroll->value[0] = ch->level;
skills.c:   ch->mana -= mana;
skills.c:   if( !IS_NPC( ch ) && ch->level < skill_table[gsn_brew]->skill_level[ch->Class] )
skills.c:                                   100 / ( 2 + ch->level - skill_table[sn]->skill_level[ch->Class] ) );
skills.c:   if( !IS_NPC( ch ) && ch->mana < mana )
skills.c:   for( fire = ch->in_room->first_content; fire; fire = fire->next_content )
skills.c:      ch->mana -= ( mana / 2 );
skills.c:      ch->mana -= ( mana / 2 );
skills.c:   potion->value[0] = ch->level;
skills.c:   ch->mana -= mana;
skills.c:   if( number_percent(  ) >= schance + victim->level - ch->level )
skills.c:   if( ch->mount )
skills.c:   if( !ch->fighting )
skills.c:   if( !ch->fighting )
skills.c:   af.duration = number_range( ch->level / 5, ch->level * 2 / 5 );
skills.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:   if( !ch->in_room->first_person )
skills.c:   for( vch = ch->in_room->first_person; vch; vch = vch_next )
skills.c:      vch_next = vch->next_in_room;
skills.c:      if( ++nvict > ch->level / 5 )
skills.c:   ch->move = UMAX( 0, ch->move - nvict * 3 + nhit );
skills.c:            || ch->level - victim->level > 10
skills.c:            || !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
skills.c:          && ( ch->in_room->vnum < 29 || ch->in_room->vnum > 43 ) && ch != victim )
skills.c:          * (IS_NPC(ch) ? ch->short_descr : ch->name),
skills.c:                                         ( !IS_NPC( ch ) && !xIS_SET( ch->act, PLR_HOLYLIGHT ) ) ) )
skills.c:   was_in_room = ch->in_room;
skills.c:   if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:   if( ch->level < 50 )
skills.c:   if( ch->level < 40 )
skills.c:   if( ch->level < 30 )
skills.c:      if( room_is_private( pexit->to_room ) && ch->level < LEVEL_GREATER )
skills.c:      send_to_char( ch->in_room->name, ch );
skills.c:      show_list_to_char( ch->in_room->first_content, ch, FALSE, FALSE );
skills.c:      show_char_to_char( ch->in_room->first_person, ch );
skills.c:      switch ( ch->in_room->sector_type )
skills.c:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:   was_in_room = ch->in_room;
skills.c:   if( ch->level < 50 )
skills.c:   if( ch->level < 40 )
skills.c:   if( ch->level < 30 )
skills.c:      if( room_is_private( pexit->to_room ) && ch->level < LEVEL_GREATER )
skills.c:      switch ( ch->in_room->sector_type )
skills.c:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
skills.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:   if( IS_NPC( victim ) && xIS_SET( victim->act, ACT_SENTINEL ) && ch->in_room != victim->in_room )
skills.c:         global_retcode = spell_attack( dt, ch->level, ch, victim );
skills.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_PRIVATE ) || xIS_SET( ch->in_room->room_flags, ROOM_SOLITARY ) )
skills.c:      if( ch->in_room->tunnel > 0 )
skills.c:         for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
skills.c:         if( count >= ch->in_room->tunnel )
skills.c:       * if ( IS_NPC(vch) && xIS_SET(vch->act, ACT_STAY_AREA)
skills.c:       * &&   ch->in_room->area != vch->in_room->area) )
skills.c:      if( xIS_SET( vch->in_room->room_flags, ROOM_NOMISSILE ) )
skills.c:      if( vch->num_fighting > MAX_FIGHT )
skills.c:      if( !IS_NPC( vch ) && !IS_NPC( ch ) && xIS_SET( ch->act, PLR_NICE ) )
skills.c:   was_in_room = ch->in_room;
skills.c:         for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
skills.c:      if( victim && ch->in_room == victim->in_room )
skills.c:            obj_to_room( projectile, ch->in_room );
skills.c:      if( ( pexit = get_exit( ch->in_room, dir ) ) == NULL )
skills.c:            obj_to_room( projectile, ch->in_room );
skills.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
skills.c:  for ( throw_obj = ch->last_carrying; throw_obj;
skills.c:  if ( ch->fighting )
skills.c:    victim = ch->fighting;
skills.c:   if( !IS_NPC( ch ) && !IS_IMMORTAL( ch ) && ch->level < skill_table[gsn_slice]->skill_level[ch->Class] )
skills.c:         damage( ch, ch, ch->level, gsn_slice );
skills.c:                       ch->style == STYLE_BERSERK ? "&Rberserk" :
skills.c:                       ch->style == STYLE_AGGRESSIVE ? "&Raggressive" :
skills.c:                       ch->style == STYLE_DEFENSIVE ? "&Ydefensive" :
skills.c:                       ch->style == STYLE_EVASIVE ? "&Yevasive" : "standard" );
skills.c:      if( ch->level < skill_table[gsn_style_evasive]->skill_level[ch->Class] )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_EVASIVE;
skills.c:         ch->style = STYLE_EVASIVE;
skills.c:      if( ch->level < skill_table[gsn_style_defensive]->skill_level[ch->Class] )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_DEFENSIVE;
skills.c:         ch->style = STYLE_DEFENSIVE;
skills.c:      if( ch->level < skill_table[gsn_style_standard]->skill_level[ch->Class] )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_FIGHTING;
skills.c:         ch->style = STYLE_FIGHTING;
skills.c:      if( ch->level < skill_table[gsn_style_aggressive]->skill_level[ch->Class] )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_AGGRESSIVE;
skills.c:         ch->style = STYLE_AGGRESSIVE;
skills.c:      if( ch->level < skill_table[gsn_style_berserk]->skill_level[ch->Class] )
skills.c:         if( ch->fighting )
skills.c:            ch->position = POS_BERSERK;
skills.c:         ch->style = STYLE_BERSERK;
skills.c:   else if( ch->morph && ch->morph->morph && ch->morph->morph->skills &&
skills.c:            ch->morph->morph->skills[0] != '\0' &&
skills.c:            is_name( skill_table[gsn]->name, ch->morph->morph->skills ) && percent < 85 )
skills.c:   if( ch->morph && ch->morph->morph && ch->morph->morph->no_skills &&
skills.c:       ch->morph->morph->no_skills[0] != '\0' && is_name( skill_table[gsn]->name, ch->morph->morph->no_skills ) )
skills.c:   if( skill_table[gsn]->guild == 99 && !IS_NPC( ch ) && !IS_SET( ch->pcdata->flags, PCFLAG_DEADLY ) )
skills.c:   if( IS_NPC( ch ) || ch->level < skill_table[gsn_cook]->skill_level[ch->Class] )
skills.c:   for( fire = ch->in_room->first_content; fire; fire = fire->next_content )
Binary file smaug.exe matches
special.c:   if( ch->position <= POS_SLEEPING )
special.c:   if( ch->fighting || ch->fearing || !ch->hating || xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
special.c:   if( ch->hunting )
special.c:   one_argument( ch->hating->name, name );
special.c:      if( !str_cmp( ch->hating->name, victim->name ) )
special.c:   if( ch->in_room == victim->in_room )
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, victim );
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, NULL );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:         spell_smaug( skill_lookup( "armor" ), ch->level, ch, victim );
special.c:         spell_smaug( skill_lookup( "bless" ), ch->level, ch, victim );
special.c:         spell_cure_blindness( skill_lookup( "cure blindness" ), ch->level, ch, victim );
special.c:         spell_smaug( skill_lookup( "cure light" ), ch->level, ch, victim );
special.c:         spell_cure_poison( skill_lookup( "cure poison" ), ch->level, ch, victim );
special.c:         spell_smaug( skill_lookup( "refresh" ), ch->level, ch, victim );
special.c:         spell_smaug( skill_lookup( "cure serious" ), ch->level, ch, victim );
special.c:         spell_remove_curse( skill_lookup( "remove curse" ), ch->level, ch, victim );
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      if( ch->level >= min_level )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, victim );
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      if( ch->level >= min_level )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, victim );
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      if( ch->level >= min_level )
special.c:   ( *skill_table[sn]->spell_fun ) ( sn, ch->level, ch, victim );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
special.c:   char_to_room( create_mobile( cityguard ), ch->in_room );
special.c:   char_to_room( create_mobile( cityguard ), ch->in_room );
special.c:   for( corpse = ch->in_room->first_content; corpse; corpse = c_next )
special.c:         obj_to_room( obj, ch->in_room );
special.c:   if( !IS_AWAKE( ch ) || ch->fighting )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:   if( victim && xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
special.c:   for( trash = ch->in_room->first_content; trash; trash = trash_next )
special.c:      if( IS_OBJ_STAT( trash, ITEM_PROTOTYPE ) && !xIS_SET( ch->act, ACT_PROTOTYPE ) )
special.c:   if( ch->fighting )
special.c:   if( !move || ch->position < POS_SLEEPING )
special.c:         move_char( ch, get_exit( ch->in_room, path[pos] - '0' ), 0 );
special.c:         ch->position = POS_STANDING;
special.c:         ch->position = POS_SLEEPING;
special.c:   if( ch->position != POS_FIGHTING
special.c:       && ch->position != POS_EVASIVE
special.c:       && ch->position != POS_DEFENSIVE && ch->position != POS_AGGRESSIVE && ch->position != POS_BERSERK )
special.c:   if( ( victim = who_fighting( ch ) ) == NULL || number_percent(  ) > 2 * ch->level )
special.c:   spell_poison( gsn_poison, ch->level, ch, victim );
special.c:   if( ch->position != POS_STANDING )
special.c:   for( victim = ch->in_room->first_person; victim; victim = v_next )
special.c:      if( IS_AWAKE( victim ) && number_range( 0, ch->level ) == 0 )
special.c:         maxgold = ch->level * ch->level * 1000;
special.c:         gold = victim->gold * number_range( 1, URANGE( 2, ch->level / 4, 10 ) ) / 100;
special.c:         ch->gold += 9 * gold / 10;
special.c:         if( ch->gold > maxgold )
special.c:            boost_economy( ch->in_room->area, ch->gold - maxgold / 2 );
special.c:            ch->gold = maxgold / 2;
special.c:   was_in_room = ch->in_room;
special.c:   if( ( pexit = ch->in_room->first_exit ) != NULL )
special.c:      for( trash = ch->in_room->first_content; trash; trash = trash_next )
special.c:            if( ch->level < trash->level )
special.c:               for( obj2 = ch->first_carrying; obj2; obj2 = obj2->next_content )
special.c:                  if( ( pexit = get_exit( ch->in_room, door ) ) != NULL
special.c:                        for( vch = pexit->to_room->first_person; vch; vch = vch->next_in_room )
special.c:                           if( !str_cmp( vch->spec_funname, "spec_wanderer" ) )
track.c:   if( !IS_NPC( ch ) && ch->pcdata->learned[gsn_track] <= 0 )
track.c:   maxdist = 100 + ch->level * 30;
track.c:   dir = find_first_step( ch->in_room, vict->in_room, maxdist );
track.c:   if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
track.c:   if( !ch || !ch->hunting || ch->position < 5 )
track.c:      if( ch->hunting->who == tmp )
track.c:   if( ch->in_room == ch->hunting->who->in_room )
track.c:      if( ch->fighting )
track.c:      found_prey( ch, ch->hunting->who );
track.c:   ret = find_first_step( ch->in_room, ch->hunting->who->in_room, 500 + ch->level * 25 );
track.c:      if( ( pexit = get_exit( ch->in_room, ret ) ) == NULL )
track.c:      if( !ch->hunting )
track.c:         if( !ch->in_room )
track.c:            bug( "Hunt_victim: no ch->in_room!  Mob #%d, name: %s.  Placing mob in limbo.", ch->pIndexData->vnum, ch->name );
track.c:      if( ch->in_room == ch->hunting->who->in_room )
track.c:         found_prey( ch, ch->hunting->who );
track.c:         if( ( vch = scan_for_victim( ch, pexit, ch->hunting->name ) ) != NULL )
track.c:            if( !mob_fire( ch, ch->hunting->who->name ) )
update.c:   snprintf( buf, MAX_STRING_LENGTH, "the %s", title_table[ch->Class][ch->level][ch->sex == SEX_FEMALE ? 1 : 0] );
update.c:   add_hp = con_app[get_curr_con( ch )].hitp + number_range( class_table[ch->Class]->hp_min, class_table[ch->Class]->hp_max );
update.c:   add_mana = class_table[ch->Class]->fMana ? number_range( 2, ( 2 * get_curr_int( ch ) + get_curr_wis( ch ) ) / 8 ) : 0;
update.c:   add_hp = UMAX( 1, add_hp ) + ( ch->pcdata->lck * .3 );
update.c:   add_mana = UMAX( 0, add_mana ) + ( (ch->pcdata->lck * .4) + ch->pcdata->intel );
update.c:   add_move = UMAX( 10, add_move ) + (( ch->pcdata->lck * .5 ) + ch->pcdata->dex );
update.c:   ch->max_hit += add_hp;
update.c:   ch->max_mana += add_mana;
update.c:   ch->max_move += add_move;
update.c:   ch->practice += add_prac;
update.c:   ch->pcdata->str += 1;
update.c:   ch->pcdata->intel += 1;
update.c:   ch->pcdata->dex += 1;
update.c:   ch->pcdata->lck += 1;
update.c:   ch->pcdata->def += 1;
update.c:   ch->pcdata->mdef += 1;
update.c:   ch->pcdata->att += 1;
update.c:      xREMOVE_BIT( ch->act, PLR_BOUGHT_PET );
update.c:   if( ch->level == LEVEL_AVATAR )
update.c:            ch_printf( d->character, "%s has attained the rank of Avatar!\r\n", ch->name );
update.c:   ch->hit = ch->max_hit;
update.c:   ch->mana = ch->max_mana;
update.c:   ch->move = ch->max_move;
update.c:   if( ch->level < LEVEL_IMMORTAL )
update.c:                   add_hp, ch->max_hit, add_mana, ch->max_mana, add_move, ch->max_move, add_prac, ch->practice );
update.c:   if( IS_NPC( ch ) || ch->level >= LEVEL_AVATAR )
update.c:   if( modgain > 0 && IS_PKILL( ch ) && ch->level < 17 )
update.c:      if( ch->level <= 6 )
update.c:      if( ch->level <= 10 && ch->level >= 7 )
update.c:      if( ch->level <= 13 && ch->level >= 11 )
update.c:      if( ch->level <= 16 && ch->level >= 14 )
update.c:   modgain *= ( race_table[ch->race]->exp_multiplier / 100.0 );
update.c:      if( ch->exp + modgain < exp_level( ch, ch->level ) )
update.c:         modgain = exp_level( ch, ch->level ) - ch->exp;
update.c:   modgain = UMIN( (int)modgain, exp_level( ch, ch->level + 2 ) - exp_level( ch, ch->level + 1 ) );
update.c:   ch->exp = UMAX( 0, ch->exp + ( int )modgain );
update.c:   if( NOT_AUTHED( ch ) && ch->exp >= exp_level( ch, ch->level + 1 ) )
update.c:      ch->exp = ( exp_level( ch, ( ch->level + 1 ) ) - 1 );
update.c:   while( ch->level < LEVEL_AVATAR && ch->exp >= exp_level( ch, ch->level + 1 ) )
update.c:      ch->level += 1;
update.c:      ch_printf( ch, "You have now obtained experience level %d!\r\n", ch->level );
update.c:      gain = ch->level * 3 / 2;
update.c:      gain = UMIN( 5, ch->level );
update.c:      switch ( ch->position )
update.c:         if( ch->pcdata->condition[COND_BLOODTHIRST] <= 1 )
update.c:         else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( 8 + ch->level ) )
update.c:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:   return UMIN( gain, ch->max_hit - ch->hit );
update.c:      gain = ch->level;
update.c:      gain = UMIN( 5, ch->level / 2 );
update.c:      if( ch->position < POS_SLEEPING )
update.c:      switch ( ch->position )
update.c:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:   return UMIN( gain, ch->max_mana - ch->mana );
update.c:      gain = ch->level;
update.c:      gain = UMAX( 15, 2 * ch->level );
update.c:      switch ( ch->position )
update.c:         if( ch->pcdata->condition[COND_BLOODTHIRST] <= 1 )
update.c:         else if( ch->pcdata->condition[COND_BLOODTHIRST] >= ( 8 + ch->level ) )
update.c:      if( ch->pcdata->condition[COND_FULL] == 0 )
update.c:      if( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:   return UMIN( gain, ch->max_move - ch->move );
update.c:   if( value == 0 || IS_NPC( ch ) || ch->level >= LEVEL_IMMORTAL || NOT_AUTHED( ch ) )
update.c:   condition = ch->pcdata->condition[iCond];
update.c:      ch->pcdata->condition[iCond] = URANGE( 0, condition + value, 10 + ch->level );
update.c:      ch->pcdata->condition[iCond] = URANGE( 0, condition + value, 48 );
update.c:   if( ch->pcdata->condition[iCond] == 0 )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR )
update.c:               retcode = damage( ch, ch, ch->max_hit / 20, TYPE_UNDEFINED );
update.c:   if( ch->pcdata->condition[iCond] == 1 )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR )
update.c:   if( ch->pcdata->condition[iCond] == 2 )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR )
update.c:   if( ch->pcdata->condition[iCond] == 3 )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR && ch->Class != CLASS_VAMPIRE )
update.c:            if( ch->level < LEVEL_AVATAR )
update.c:   if( ch->alignment < race_table[ch->race]->minalign )
update.c:   if( ch->alignment > race_table[ch->race]->maxalign )
update.c:   if( ch->Class == CLASS_PALADIN )
update.c:      if( ch->alignment < 250 )
update.c:      if( ch->alignment < 500 )
update.c:      if( !ch->in_room || IS_AFFECTED( ch, AFF_CHARM ) || IS_AFFECTED( ch, AFF_PARALYSIS ) || IS_AFFECTED( ch, AFF_POSSESS ) )
update.c:      if( ch->pIndexData->vnum == MOB_VNUM_ANIMATED_CORPSE && !IS_AFFECTED( ch, AFF_CHARM ) )
update.c:         if( ch->in_room->first_person )
update.c:      if( !xIS_SET( ch->act, ACT_RUNNING ) && !xIS_SET( ch->act, ACT_SENTINEL ) && !ch->fighting && ch->hunting )
update.c:      if( !xIS_SET( ch->act, ACT_RUNNING ) && ch->spec_fun && !IS_AFFECTED( ch, AFF_POSSESS ) )
update.c:         if( ( *ch->spec_fun ) ( ch ) )
update.c:      if( HAS_PROG( ch->pIndexData, SCRIPT_PROG ) && !xIS_SET( ch->act, ACT_STOP_SCRIPT ) )
update.c:      if( ch->position != POS_STANDING )
update.c:      if( xIS_SET( ch->act, ACT_MOUNTED ) )
update.c:         if( xIS_SET( ch->act, ACT_AGGRESSIVE ) || xIS_SET( ch->act, ACT_META_AGGR ) )
update.c:      if( xIS_SET( ch->in_room->room_flags, ROOM_SAFE )
update.c:          && ( xIS_SET( ch->act, ACT_AGGRESSIVE ) || xIS_SET( ch->act, ACT_META_AGGR ) ) )
update.c:      if( ch->in_room->area->nplayer > 0 )
update.c:         if( ch->position < POS_STANDING )
update.c:      if( ch->position < POS_STANDING )
update.c:      if( xIS_SET( ch->act, ACT_SCAVENGER ) && ch->in_room->first_content && number_bits( 2 ) == 0 )
update.c:         for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
update.c:            if( IS_OBJ_STAT( obj, ITEM_PROTOTYPE ) && !xIS_SET( ch->act, ACT_PROTOTYPE ) )
update.c:      if( !xIS_SET( ch->act, ACT_RUNNING )
update.c:          && !xIS_SET( ch->act, ACT_SENTINEL )
update.c:          && !xIS_SET( ch->act, ACT_PROTOTYPE )
update.c:          && ( pexit = get_exit( ch->in_room, door ) ) != NULL
update.c:          && ( !xIS_SET( ch->act, ACT_STAY_AREA ) || pexit->to_room->area == ch->in_room->area ) )
update.c:         if( retcode != rNONE || xIS_SET( ch->act, ACT_SENTINEL ) || ch->position < POS_STANDING )
update.c:      if( ch->hit < ch->max_hit / 2
update.c:          && ( pexit = get_exit( ch->in_room, door ) ) != NULL
update.c:          && ( !xIS_SET( ch->act, ACT_STAY_AREA ) || pexit->to_room->area == ch->in_room->area ) )
update.c:         for( rch = ch->in_room->first_person; rch; rch = rch->next_in_room )
update.c:                     snprintf( buf, MAX_STRING_LENGTH, "Get away from me, %s!", rch->name );
update.c:                     snprintf( buf, MAX_STRING_LENGTH, "Leave me be, %s!", rch->name );
update.c:                     snprintf( buf, MAX_STRING_LENGTH, "%s is trying to kill me!  Help!", rch->name );
update.c:                     snprintf( buf, MAX_STRING_LENGTH, "Someone save me from %s!", rch->name );
update.c:         if( ch->in_room && ch->level > 3 )
update.c:            gain_condition( ch, COND_FULL, -1 + race_table[ch->race]->hunger_mod );
update.c:         if( ch->in_room && ch->level > 3 )
update.c:            sector = ch->in_room->sector_type;
update.c:                  gain_condition( ch, COND_THIRST, -1 + race_table[ch->race]->thirst_mod );
update.c:                  gain_condition( ch, COND_THIRST, -3 + race_table[ch->race]->thirst_mod );
update.c:                     gain_condition( ch, COND_THIRST, -1 + race_table[ch->race]->thirst_mod );
update.c:          && ( !ch->desc || ch->desc->connected == CON_PLAYING )
update.c:          && ch->level >= 2 && current_time - ch->save_time > ( sysdata.save_frequency * 60 ) )
update.c:      if( ch->position >= POS_STUNNED )
update.c:         if( ch->hit < ch->max_hit )
update.c:            ch->hit += hit_gain( ch );
update.c:         if( ch->mana < ch->max_mana )
update.c:            ch->mana += mana_gain( ch );
update.c:         if( ch->move < ch->max_move )
update.c:            ch->move += move_gain( ch );
update.c:      if( ch->position == POS_STUNNED )
update.c:      if( ch->variables )
update.c:         for( vd = ch->variables; vd; vd = vd_next )
update.c:               if( vd == ch->variables )
update.c:                  ch->variables = vd_next;
update.c:      if( ch->morph )
update.c:         if( ch->morph->timer > 0 )
update.c:            --ch->morph->timer;
update.c:            if( ch->morph->timer == 0 )
update.c:      if( !IS_NPC( ch ) && ch->pcdata->nuisance )
update.c:         if( ch->pcdata->nuisance->flags < MAX_NUISANCE_STAGE )
update.c:            temp = ch->pcdata->nuisance->max_time - ch->pcdata->nuisance->set_time;
update.c:            temp *= ch->pcdata->nuisance->flags;
update.c:            temp += ch->pcdata->nuisance->set_time;
update.c:               ++ch->pcdata->nuisance->flags;
update.c:      if( !IS_NPC( ch ) && ch->level < LEVEL_IMMORTAL )
update.c:         if( ++ch->timer >= 12 )
update.c:                * ch->was_in_room = ch->in_room;
update.c:               if( ch->fighting )
update.c:               SET_BIT( ch->pcdata->flags, PCFLAG_IDLE );
update.c:         if( ch->pcdata->condition[COND_DRUNK] > 8 )
update.c:            worsen_mental_state( ch, ch->pcdata->condition[COND_DRUNK] / 8 );
update.c:         if( ch->pcdata->condition[COND_FULL] > 1 )
update.c:            switch ( ch->position )
update.c:         if( ch->pcdata->condition[COND_THIRST] > 1 )
update.c:            switch ( ch->position )
update.c:         gain_condition( ch, COND_FULL, -1 + race_table[ch->race]->hunger_mod );
update.c:         if( ch->Class == CLASS_VAMPIRE && ch->level >= 10 )
update.c:         if( CAN_PKILL( ch ) && ch->pcdata->condition[COND_THIRST] - 9 > 10 )
update.c:         if( !IS_NPC( ch ) && ch->pcdata->nuisance )
update.c:            value = ( ( 0 - ch->pcdata->nuisance->flags ) * ch->pcdata->nuisance->power );
update.c:      if( !IS_NPC( ch ) && !IS_IMMORTAL( ch ) && ch->pcdata->release_date > 0 && ch->pcdata->release_date <= current_time )
update.c:         if( ch->pcdata->clan )
update.c:            location = get_room_index( ch->pcdata->clan->recall );
update.c:            location = ch->in_room;
update.c:         STRFREE( ch->pcdata->helled_by );
update.c:         ch->pcdata->helled_by = NULL;
update.c:         ch->pcdata->release_date = 0;
update.c:            ch->mental_state = URANGE( 20, ch->mental_state + ( IS_NPC( ch ) ? 2 : IS_PKILL( ch ) ? 3 : 4 ), 100 );
update.c:         else if( ch->position == POS_INCAP )
update.c:         else if( ch->position == POS_MORTAL )
update.c:            for( paf = ch->first_affect; paf; paf = paf_next )
update.c:                     if( ( *skill->spell_fun ) ( paf->modifier, ch->level, ch, ch ) == rCHAR_DIED || char_died( ch ) )
update.c:               xREMOVE_BIT( ch->affected_by, AFF_RECURRINGSPELL );
update.c:         if( ch->mental_state >= 30 )
update.c:            switch ( ( ch->mental_state + 5 ) / 10 )
update.c:         if( ch->mental_state <= -30 )
update.c:            switch ( ( abs( ch->mental_state ) + 5 ) / 10 )
update.c:                  if( ch->position > POS_SLEEPING )
update.c:                     if( ( ch->position == POS_STANDING
update.c:                           || ch->position < POS_FIGHTING ) && number_percent(  ) + 10 < abs( ch->mental_state ) )
update.c:                  if( ch->position > POS_SLEEPING )
update.c:                     if( ( ch->position == POS_STANDING
update.c:                           || ch->position < POS_FIGHTING ) && ( number_percent(  ) + 20 ) < abs( ch->mental_state ) )
update.c:                  if( ch->position > POS_SLEEPING )
update.c:                     if( ch->position < POS_SITTING && ( number_percent(  ) + 30 ) < abs( ch->mental_state ) )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:                  if( ch->position > POS_RESTING )
update.c:         if( ch->timer > 24 )
update.c:            if( !IS_NPC( tch )   /* && ( tch->level < LEVEL_IMMORTAL ) */
update.c:               if( --obj->value[2] == 0 && tch->in_room )
update.c:                  tch->in_room->light -= obj->count;
update.c:                  if( tch->in_room->light < 0 )
update.c:                     tch->in_room->light = 0;
update.c:         if( xIS_SET( ch->act, ACT_RUNNING ) )
update.c:            if( !xIS_SET( ch->act, ACT_SENTINEL )
update.c:                && ch->position == POS_STANDING && !xIS_SET( ch->act, ACT_MOUNTED ) && !ch->fighting && ch->hunting )
update.c:            if( ch->spec_fun )
update.c:               if( ( *ch->spec_fun ) ( ch ) )
update.c:            if( !xIS_SET( ch->act, ACT_SENTINEL )
update.c:                && ch->position == POS_STANDING
update.c:                && !xIS_SET( ch->act, ACT_MOUNTED )
update.c:                && !xIS_SET( ch->act, ACT_PROTOTYPE )
update.c:                && ( pexit = get_exit( ch->in_room, door ) ) != NULL
update.c:                && ( !xIS_SET( ch->act, ACT_STAY_AREA ) || pexit->to_room->area == ch->in_room->area ) )
update.c:               if( retcode != rNONE || xIS_SET( ch->act, ACT_SENTINEL ) || ch->position < POS_STANDING )
update.c:         if( ch->mount && ch->in_room != ch->mount->in_room )
update.c:            xREMOVE_BIT( ch->mount->act, ACT_MOUNTED );
update.c:            ch->mount = NULL;
update.c:            ch->position = POS_STANDING;
update.c:         if( ( ch->in_room && ch->in_room->sector_type == SECT_UNDERWATER )
update.c:             || ( ch->in_room && ch->in_room->sector_type == SECT_OCEANFLOOR ) )
update.c:               if( ch->level < LEVEL_IMMORTAL )
update.c:                  dam = number_range( ch->max_hit / 100, ch->max_hit / 50 );
update.c:         if( ch->in_room
update.c:             && ( ( ch->in_room->sector_type == SECT_WATER_NOSWIM ) || ( ch->in_room->sector_type == SECT_WATER_SWIM ) ) )
update.c:                && !IS_AFFECTED( ch, AFF_FLOATING ) && !IS_AFFECTED( ch, AFF_AQUA_BREATH ) && !ch->mount )
update.c:               for( obj = ch->first_carrying; obj; obj = obj->next_content )
update.c:                  if( ch->level < LEVEL_IMMORTAL )
update.c:                     if( ch->move > 0 )
update.c:                        mov = number_range( ch->max_move / 20, ch->max_move / 5 );
update.c:                        if( ch->move - mov < 0 )
update.c:                           ch->move = 0;
update.c:                           ch->move -= mov;
update.c:                        dam = number_range( ch->max_hit / 20, ch->max_hit / 5 );
update.c:         if( !ch->desc )
update.c:            for( wch = ch->in_room->first_person; wch; wch = trvch_next( lc2 ) )
update.c:                   || wch->fighting
update.c:                   || !IS_AWAKE( wch ) || ( xIS_SET( wch->act, ACT_WIMPY ) && IS_AWAKE( ch ) ) || !can_see( wch, ch ) )
update.c:               if( ( !xIS_SET( wch->act, ACT_AGGRESSIVE )
update.c:                     && !xIS_SET( wch->act, ACT_META_AGGR ) )
update.c:                   || xIS_SET( wch->act, ACT_MOUNTED ) || xIS_SET( wch->in_room->room_flags, ROOM_SAFE ) )
update.c:      if( !char_died( wch ) && wch->mpactnum > 0 )
update.c:         while( ( tmp_act = wch->mpact ) != NULL )
update.c:            wch->mpact = tmp_act->next;
update.c:         wch->mpactnum = 0;
update.c:         wch->mpact = NULL;
update.c:      if( char_died( wch ) || IS_NPC( wch ) || wch->level >= LEVEL_IMMORTAL || !wch->in_room )
update.c:      for( ch = wch->in_room->first_person; ch; ch = trvch_next( lc ) )
update.c:             || ch->fighting
update.c:             || !IS_AWAKE( ch ) || ( xIS_SET( ch->act, ACT_WIMPY ) && IS_AWAKE( wch ) ) || !can_see( ch, wch ) )
update.c:         if( ( !xIS_SET( ch->act, ACT_AGGRESSIVE )
update.c:               && !xIS_SET( ch->act, ACT_META_AGGR ) )
update.c:             || xIS_SET( ch->act, ACT_MOUNTED ) || xIS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
update.c:         for( vch = wch->in_room->first_person; vch; vch = vch->next_in_room )
update.c:            if( ( !IS_NPC( vch ) || xIS_SET( ch->act, ACT_META_AGGR )
update.c:                  || xIS_SET( vch->act, ACT_ANNOYING ) )
update.c:                && vch->level < LEVEL_IMMORTAL
update.c:                && ( !xIS_SET( ch->act, ACT_WIMPY ) || !IS_AWAKE( vch ) ) && can_see( ch, vch ) )
update.c:         if( IS_NPC( ch ) && xIS_SET( ch->attacks, ATCK_BACKSTAB ) )
update.c:            if( !ch->mount
update.c:               if( !IS_AWAKE( victim ) || number_percent(  ) + 5 < ch->level )
update.c:         else if( IS_NPC( ch ) && xIS_SET( ch->attacks, ATCK_POUNCE ) )
update.c:            if( !ch->mount && !victim->fighting )
update.c:               if( !IS_AWAKE( victim ) || number_percent(  ) + 5 < ch->level )
update.c:   if( IS_NPC( ch ) || ch->pcdata->condition[COND_DRUNK] <= 0 )
update.c:   drunk = ch->pcdata->condition[COND_DRUNK];
update.c:   position = ch->position;
update.c:   ch->position = POS_STANDING;
update.c:      for( vch = ch->in_room->first_person; vch; vch = vch->next_in_room )
update.c:      check_social( ch, "puke", ( rvch ? rvch->name : ( char * )"" ) );
update.c:   ch->position = position;
update.c:   if( ch->mental_state >= 30 && number_bits( 5 - ( ch->mental_state >= 50 ) - ( ch->mental_state >= 75 ) ) == 0 )
update.c:      switch ( number_range( 1, UMIN( 21, ( ch->mental_state + 5 ) / 5 ) ) )
update.c:      for( vch = first_char; vch; vch = vch->next )
variables.c:   for( vd = ch->variables; vd; vd = vd->next )
variables.c:   VARIABLE_DATA *vd_next, *vd = ch->variables;
variables.c:      ch->variables = vd->next;
variables.c:   pvd = vd = ch->variables;
variables.c:      if( vd == ch->variables )
variables.c:         ch->variables = var;
variables.c:   var->next = ch->variables;
variables.c:   ch->variables = var;
variables.c:      exp = ch->level * get_curr_int( ch );
variables.c:      vnum = ch->pIndexData ? ch->pIndexData->vnum : 0;
variables.c:      vnum = ch->pIndexData ? ch->pIndexData->vnum : 0;
variables.c:      exp = ch->level * get_curr_int( ch );
variables.c:      vnum = ch->pIndexData ? ch->pIndexData->vnum : 0;
variables.c:      vnum = ch->pIndexData ? ch->pIndexData->vnum : 0;
variables.c:   for( vd = ch->variables; vd; vd = vd->next )
weather.c:   if( !ch->desc )
weather.c:   if( !ch->desc )
weather.c:   struct WeatherCell *cell = getWeatherCell( ch->in_room->area );
weather.c:   if( !ch->desc )
weather.c:   if( !IS_OUTSIDE( ch ) && NO_WEATHER_SECT( ch->in_room->sector_type ) )
